// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: mesos.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "mesos.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace mesos {

namespace {

const ::google::protobuf::Descriptor* FrameworkID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkID_reflection_ = NULL;
const ::google::protobuf::Descriptor* OfferID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OfferID_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveID_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskID_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorID_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerID_reflection_ = NULL;
const ::google::protobuf::Descriptor* TimeInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TimeInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* DurationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DurationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Address_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Address_reflection_ = NULL;
const ::google::protobuf::Descriptor* URL_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  URL_reflection_ = NULL;
const ::google::protobuf::Descriptor* Unavailability_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Unavailability_reflection_ = NULL;
const ::google::protobuf::Descriptor* MachineID_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MachineID_reflection_ = NULL;
const ::google::protobuf::Descriptor* MachineInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MachineInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* MachineInfo_Mode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FrameworkInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* FrameworkInfo_Capability_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FrameworkInfo_Capability_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FrameworkInfo_Capability_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_Command_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_Command_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckInfo_Http_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckInfo_Http_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CheckInfo_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* HealthCheck_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HealthCheck_reflection_ = NULL;
const ::google::protobuf::Descriptor* HealthCheck_HTTPCheckInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HealthCheck_HTTPCheckInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* HealthCheck_TCPCheckInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HealthCheck_TCPCheckInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HealthCheck_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* KillPolicy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KillPolicy_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommandInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommandInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CommandInfo_URI_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CommandInfo_URI_reflection_ = NULL;
const ::google::protobuf::Descriptor* ExecutorInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ExecutorInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ExecutorInfo_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* MasterInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MasterInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* SlaveInfo_Capability_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SlaveInfo_Capability_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* SlaveInfo_Capability_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Value_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Scalar_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Scalar_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Range_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Range_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Ranges_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Ranges_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Set_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Set_reflection_ = NULL;
const ::google::protobuf::Descriptor* Value_Text_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Value_Text_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Value_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Attribute_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Attribute_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_AllocationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_AllocationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_ReservationInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_ReservationInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Persistence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Persistence_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Source_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Path_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Source_Path_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Mount_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_DiskInfo_Source_Mount_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Resource_DiskInfo_Source_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Resource_RevocableInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_RevocableInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Resource_SharedInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Resource_SharedInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* TrafficControlStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TrafficControlStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* IpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* IcmpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  IcmpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* TcpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TcpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* UdpStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  UdpStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* SNMPStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SNMPStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceUsage_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceUsage_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceUsage_Executor_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceUsage_Executor_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResourceUsage_Executor_Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResourceUsage_Executor_Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* PerfStatistics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PerfStatistics_reflection_ = NULL;
const ::google::protobuf::Descriptor* Request_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Request_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Launch_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Launch_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_LaunchGroup_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_LaunchGroup_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Reserve_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Reserve_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Unreserve_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Unreserve_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Create_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Create_reflection_ = NULL;
const ::google::protobuf::Descriptor* Offer_Operation_Destroy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Offer_Operation_Destroy_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* InverseOffer_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  InverseOffer_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskGroupInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskGroupInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Task_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Task_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_Command_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_Command_reflection_ = NULL;
const ::google::protobuf::Descriptor* CheckStatusInfo_Http_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CheckStatusInfo_Http_reflection_ = NULL;
const ::google::protobuf::Descriptor* TaskStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TaskStatus_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Filters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Filters_reflection_ = NULL;
const ::google::protobuf::Descriptor* Environment_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Environment_reflection_ = NULL;
const ::google::protobuf::Descriptor* Environment_Variable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Environment_Variable_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Environment_Variable_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Parameter_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Parameter_reflection_ = NULL;
const ::google::protobuf::Descriptor* Parameters_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Parameters_reflection_ = NULL;
const ::google::protobuf::Descriptor* Credential_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Credential_reflection_ = NULL;
const ::google::protobuf::Descriptor* Credentials_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Credentials_reflection_ = NULL;
const ::google::protobuf::Descriptor* Secret_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Secret_reflection_ = NULL;
const ::google::protobuf::Descriptor* Secret_Reference_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Secret_Reference_reflection_ = NULL;
const ::google::protobuf::Descriptor* Secret_Value_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Secret_Value_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Secret_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* RateLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RateLimit_reflection_ = NULL;
const ::google::protobuf::Descriptor* RateLimits_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RateLimits_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_Appc_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_Appc_reflection_ = NULL;
const ::google::protobuf::Descriptor* Image_Docker_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Image_Docker_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Image_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* Volume_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_reflection_ = NULL;
const ::google::protobuf::Descriptor* Volume_Source_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_Source_reflection_ = NULL;
const ::google::protobuf::Descriptor* Volume_Source_DockerVolume_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_Source_DockerVolume_reflection_ = NULL;
const ::google::protobuf::Descriptor* Volume_Source_SandboxPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Volume_Source_SandboxPath_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Volume_Source_SandboxPath_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Volume_Source_Type_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor_ = NULL;
const ::google::protobuf::Descriptor* NetworkInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetworkInfo_IPAddress_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkInfo_IPAddress_reflection_ = NULL;
const ::google::protobuf::Descriptor* NetworkInfo_PortMapping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetworkInfo_PortMapping_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* NetworkInfo_Protocol_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CapabilityInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CapabilityInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* CapabilityInfo_Capability_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LinuxInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LinuxInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* RLimitInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RLimitInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* RLimitInfo_RLimit_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RLimitInfo_RLimit_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* RLimitInfo_RLimit_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* TTYInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TTYInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* TTYInfo_WindowSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TTYInfo_WindowSize_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_DockerInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo_PortMapping_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_DockerInfo_PortMapping_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ContainerInfo_MesosInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerInfo_MesosInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ContainerStatus_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ContainerStatus_reflection_ = NULL;
const ::google::protobuf::Descriptor* CgroupInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CgroupInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* CgroupInfo_NetCls_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CgroupInfo_NetCls_reflection_ = NULL;
const ::google::protobuf::Descriptor* Labels_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Labels_reflection_ = NULL;
const ::google::protobuf::Descriptor* Label_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Label_reflection_ = NULL;
const ::google::protobuf::Descriptor* Port_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Port_reflection_ = NULL;
const ::google::protobuf::Descriptor* Ports_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Ports_reflection_ = NULL;
const ::google::protobuf::Descriptor* DiscoveryInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DiscoveryInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor_ = NULL;
const ::google::protobuf::Descriptor* WeightInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WeightInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* VersionInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VersionInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* Flag_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Flag_reflection_ = NULL;
const ::google::protobuf::Descriptor* Role_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Role_reflection_ = NULL;
const ::google::protobuf::Descriptor* Metric_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Metric_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileInfo_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Status_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* TaskState_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_mesos_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_mesos_2eproto() {
  protobuf_AddDesc_mesos_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "mesos.proto");
  GOOGLE_CHECK(file != NULL);
  FrameworkID_descriptor_ = file->message_type(0);
  static const int FrameworkID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkID, value_),
  };
  FrameworkID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FrameworkID_descriptor_,
      FrameworkID::default_instance_,
      FrameworkID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkID, _has_bits_[0]),
      -1,
      -1,
      sizeof(FrameworkID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkID, _internal_metadata_),
      -1);
  OfferID_descriptor_ = file->message_type(1);
  static const int OfferID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OfferID, value_),
  };
  OfferID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OfferID_descriptor_,
      OfferID::default_instance_,
      OfferID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OfferID, _has_bits_[0]),
      -1,
      -1,
      sizeof(OfferID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OfferID, _internal_metadata_),
      -1);
  SlaveID_descriptor_ = file->message_type(2);
  static const int SlaveID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveID, value_),
  };
  SlaveID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SlaveID_descriptor_,
      SlaveID::default_instance_,
      SlaveID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveID, _has_bits_[0]),
      -1,
      -1,
      sizeof(SlaveID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveID, _internal_metadata_),
      -1);
  TaskID_descriptor_ = file->message_type(3);
  static const int TaskID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskID, value_),
  };
  TaskID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TaskID_descriptor_,
      TaskID::default_instance_,
      TaskID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskID, _has_bits_[0]),
      -1,
      -1,
      sizeof(TaskID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskID, _internal_metadata_),
      -1);
  ExecutorID_descriptor_ = file->message_type(4);
  static const int ExecutorID_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorID, value_),
  };
  ExecutorID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ExecutorID_descriptor_,
      ExecutorID::default_instance_,
      ExecutorID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorID, _has_bits_[0]),
      -1,
      -1,
      sizeof(ExecutorID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorID, _internal_metadata_),
      -1);
  ContainerID_descriptor_ = file->message_type(5);
  static const int ContainerID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, parent_),
  };
  ContainerID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ContainerID_descriptor_,
      ContainerID::default_instance_,
      ContainerID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, _has_bits_[0]),
      -1,
      -1,
      sizeof(ContainerID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerID, _internal_metadata_),
      -1);
  TimeInfo_descriptor_ = file->message_type(6);
  static const int TimeInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, nanoseconds_),
  };
  TimeInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TimeInfo_descriptor_,
      TimeInfo::default_instance_,
      TimeInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(TimeInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TimeInfo, _internal_metadata_),
      -1);
  DurationInfo_descriptor_ = file->message_type(7);
  static const int DurationInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DurationInfo, nanoseconds_),
  };
  DurationInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DurationInfo_descriptor_,
      DurationInfo::default_instance_,
      DurationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DurationInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(DurationInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DurationInfo, _internal_metadata_),
      -1);
  Address_descriptor_ = file->message_type(8);
  static const int Address_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, port_),
  };
  Address_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Address_descriptor_,
      Address::default_instance_,
      Address_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _has_bits_[0]),
      -1,
      -1,
      sizeof(Address),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Address, _internal_metadata_),
      -1);
  URL_descriptor_ = file->message_type(9);
  static const int URL_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, scheme_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, address_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, query_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, fragment_),
  };
  URL_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      URL_descriptor_,
      URL::default_instance_,
      URL_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, _has_bits_[0]),
      -1,
      -1,
      sizeof(URL),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(URL, _internal_metadata_),
      -1);
  Unavailability_descriptor_ = file->message_type(10);
  static const int Unavailability_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, start_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, duration_),
  };
  Unavailability_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Unavailability_descriptor_,
      Unavailability::default_instance_,
      Unavailability_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, _has_bits_[0]),
      -1,
      -1,
      sizeof(Unavailability),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Unavailability, _internal_metadata_),
      -1);
  MachineID_descriptor_ = file->message_type(11);
  static const int MachineID_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, ip_),
  };
  MachineID_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MachineID_descriptor_,
      MachineID::default_instance_,
      MachineID_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, _has_bits_[0]),
      -1,
      -1,
      sizeof(MachineID),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineID, _internal_metadata_),
      -1);
  MachineInfo_descriptor_ = file->message_type(12);
  static const int MachineInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, unavailability_),
  };
  MachineInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MachineInfo_descriptor_,
      MachineInfo::default_instance_,
      MachineInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(MachineInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MachineInfo, _internal_metadata_),
      -1);
  MachineInfo_Mode_descriptor_ = MachineInfo_descriptor_->enum_type(0);
  FrameworkInfo_descriptor_ = file->message_type(13);
  static const int FrameworkInfo_offsets_[16] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, cpus_per_task_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, mem_per_task_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, gpus_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, disk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, failover_timeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, checkpoint_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, role_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, roles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, webui_url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, capabilities_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, labels_),
  };
  FrameworkInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FrameworkInfo_descriptor_,
      FrameworkInfo::default_instance_,
      FrameworkInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(FrameworkInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo, _internal_metadata_),
      -1);
  FrameworkInfo_Capability_descriptor_ = FrameworkInfo_descriptor_->nested_type(0);
  static const int FrameworkInfo_Capability_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo_Capability, type_),
  };
  FrameworkInfo_Capability_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FrameworkInfo_Capability_descriptor_,
      FrameworkInfo_Capability::default_instance_,
      FrameworkInfo_Capability_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo_Capability, _has_bits_[0]),
      -1,
      -1,
      sizeof(FrameworkInfo_Capability),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FrameworkInfo_Capability, _internal_metadata_),
      -1);
  FrameworkInfo_Capability_Type_descriptor_ = FrameworkInfo_Capability_descriptor_->enum_type(0);
  CheckInfo_descriptor_ = file->message_type(14);
  static const int CheckInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, http_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, delay_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, interval_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, timeout_seconds_),
  };
  CheckInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckInfo_descriptor_,
      CheckInfo::default_instance_,
      CheckInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo, _internal_metadata_),
      -1);
  CheckInfo_Command_descriptor_ = CheckInfo_descriptor_->nested_type(0);
  static const int CheckInfo_Command_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Command, command_),
  };
  CheckInfo_Command_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckInfo_Command_descriptor_,
      CheckInfo_Command::default_instance_,
      CheckInfo_Command_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Command, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckInfo_Command),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Command, _internal_metadata_),
      -1);
  CheckInfo_Http_descriptor_ = CheckInfo_descriptor_->nested_type(1);
  static const int CheckInfo_Http_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, path_),
  };
  CheckInfo_Http_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckInfo_Http_descriptor_,
      CheckInfo_Http::default_instance_,
      CheckInfo_Http_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckInfo_Http),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckInfo_Http, _internal_metadata_),
      -1);
  CheckInfo_Type_descriptor_ = CheckInfo_descriptor_->enum_type(0);
  HealthCheck_descriptor_ = file->message_type(15);
  static const int HealthCheck_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, delay_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, interval_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, timeout_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, consecutive_failures_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, grace_period_seconds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, http_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, tcp_),
  };
  HealthCheck_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HealthCheck_descriptor_,
      HealthCheck::default_instance_,
      HealthCheck_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, _has_bits_[0]),
      -1,
      -1,
      sizeof(HealthCheck),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck, _internal_metadata_),
      -1);
  HealthCheck_HTTPCheckInfo_descriptor_ = HealthCheck_descriptor_->nested_type(0);
  static const int HealthCheck_HTTPCheckInfo_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, scheme_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, statuses_),
  };
  HealthCheck_HTTPCheckInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HealthCheck_HTTPCheckInfo_descriptor_,
      HealthCheck_HTTPCheckInfo::default_instance_,
      HealthCheck_HTTPCheckInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(HealthCheck_HTTPCheckInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_HTTPCheckInfo, _internal_metadata_),
      -1);
  HealthCheck_TCPCheckInfo_descriptor_ = HealthCheck_descriptor_->nested_type(1);
  static const int HealthCheck_TCPCheckInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_TCPCheckInfo, port_),
  };
  HealthCheck_TCPCheckInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HealthCheck_TCPCheckInfo_descriptor_,
      HealthCheck_TCPCheckInfo::default_instance_,
      HealthCheck_TCPCheckInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_TCPCheckInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(HealthCheck_TCPCheckInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HealthCheck_TCPCheckInfo, _internal_metadata_),
      -1);
  HealthCheck_Type_descriptor_ = HealthCheck_descriptor_->enum_type(0);
  KillPolicy_descriptor_ = file->message_type(16);
  static const int KillPolicy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillPolicy, grace_period_),
  };
  KillPolicy_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      KillPolicy_descriptor_,
      KillPolicy::default_instance_,
      KillPolicy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillPolicy, _has_bits_[0]),
      -1,
      -1,
      sizeof(KillPolicy),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KillPolicy, _internal_metadata_),
      -1);
  CommandInfo_descriptor_ = file->message_type(17);
  static const int CommandInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, uris_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, environment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, shell_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, arguments_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, user_),
  };
  CommandInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CommandInfo_descriptor_,
      CommandInfo::default_instance_,
      CommandInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(CommandInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo, _internal_metadata_),
      -1);
  CommandInfo_URI_descriptor_ = CommandInfo_descriptor_->nested_type(0);
  static const int CommandInfo_URI_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, executable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, extract_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, cache_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, output_file_),
  };
  CommandInfo_URI_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CommandInfo_URI_descriptor_,
      CommandInfo_URI::default_instance_,
      CommandInfo_URI_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, _has_bits_[0]),
      -1,
      -1,
      sizeof(CommandInfo_URI),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CommandInfo_URI, _internal_metadata_),
      -1);
  ExecutorInfo_descriptor_ = file->message_type(18);
  static const int ExecutorInfo_offsets_[12] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, discovery_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, shutdown_grace_period_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, labels_),
  };
  ExecutorInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ExecutorInfo_descriptor_,
      ExecutorInfo::default_instance_,
      ExecutorInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(ExecutorInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ExecutorInfo, _internal_metadata_),
      -1);
  ExecutorInfo_Type_descriptor_ = ExecutorInfo_descriptor_->enum_type(0);
  MasterInfo_descriptor_ = file->message_type(19);
  static const int MasterInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, ip_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, pid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, address_),
  };
  MasterInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      MasterInfo_descriptor_,
      MasterInfo::default_instance_,
      MasterInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(MasterInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MasterInfo, _internal_metadata_),
      -1);
  SlaveInfo_descriptor_ = file->message_type(20);
  static const int SlaveInfo_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, attributes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, checkpoint_),
  };
  SlaveInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SlaveInfo_descriptor_,
      SlaveInfo::default_instance_,
      SlaveInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(SlaveInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo, _internal_metadata_),
      -1);
  SlaveInfo_Capability_descriptor_ = SlaveInfo_descriptor_->nested_type(0);
  static const int SlaveInfo_Capability_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo_Capability, type_),
  };
  SlaveInfo_Capability_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SlaveInfo_Capability_descriptor_,
      SlaveInfo_Capability::default_instance_,
      SlaveInfo_Capability_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo_Capability, _has_bits_[0]),
      -1,
      -1,
      sizeof(SlaveInfo_Capability),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SlaveInfo_Capability, _internal_metadata_),
      -1);
  SlaveInfo_Capability_Type_descriptor_ = SlaveInfo_Capability_descriptor_->enum_type(0);
  Value_descriptor_ = file->message_type(21);
  static const int Value_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, scalar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, text_),
  };
  Value_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Value_descriptor_,
      Value::default_instance_,
      Value_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, _has_bits_[0]),
      -1,
      -1,
      sizeof(Value),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value, _internal_metadata_),
      -1);
  Value_Scalar_descriptor_ = Value_descriptor_->nested_type(0);
  static const int Value_Scalar_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Scalar, value_),
  };
  Value_Scalar_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Value_Scalar_descriptor_,
      Value_Scalar::default_instance_,
      Value_Scalar_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Scalar, _has_bits_[0]),
      -1,
      -1,
      sizeof(Value_Scalar),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Scalar, _internal_metadata_),
      -1);
  Value_Range_descriptor_ = Value_descriptor_->nested_type(1);
  static const int Value_Range_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, begin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, end_),
  };
  Value_Range_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Value_Range_descriptor_,
      Value_Range::default_instance_,
      Value_Range_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, _has_bits_[0]),
      -1,
      -1,
      sizeof(Value_Range),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Range, _internal_metadata_),
      -1);
  Value_Ranges_descriptor_ = Value_descriptor_->nested_type(2);
  static const int Value_Ranges_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Ranges, range_),
  };
  Value_Ranges_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Value_Ranges_descriptor_,
      Value_Ranges::default_instance_,
      Value_Ranges_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Ranges, _has_bits_[0]),
      -1,
      -1,
      sizeof(Value_Ranges),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Ranges, _internal_metadata_),
      -1);
  Value_Set_descriptor_ = Value_descriptor_->nested_type(3);
  static const int Value_Set_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Set, item_),
  };
  Value_Set_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Value_Set_descriptor_,
      Value_Set::default_instance_,
      Value_Set_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Set, _has_bits_[0]),
      -1,
      -1,
      sizeof(Value_Set),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Set, _internal_metadata_),
      -1);
  Value_Text_descriptor_ = Value_descriptor_->nested_type(4);
  static const int Value_Text_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Text, value_),
  };
  Value_Text_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Value_Text_descriptor_,
      Value_Text::default_instance_,
      Value_Text_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Text, _has_bits_[0]),
      -1,
      -1,
      sizeof(Value_Text),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Value_Text, _internal_metadata_),
      -1);
  Value_Type_descriptor_ = Value_descriptor_->enum_type(0);
  Attribute_descriptor_ = file->message_type(22);
  static const int Attribute_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, scalar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, text_),
  };
  Attribute_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Attribute_descriptor_,
      Attribute::default_instance_,
      Attribute_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, _has_bits_[0]),
      -1,
      -1,
      sizeof(Attribute),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Attribute, _internal_metadata_),
      -1);
  Resource_descriptor_ = file->message_type(23);
  static const int Resource_offsets_[11] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, scalar_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, ranges_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, set_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, role_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, allocation_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, reservation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, disk_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, revocable_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, shared_),
  };
  Resource_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_descriptor_,
      Resource::default_instance_,
      Resource_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource, _internal_metadata_),
      -1);
  Resource_AllocationInfo_descriptor_ = Resource_descriptor_->nested_type(0);
  static const int Resource_AllocationInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_AllocationInfo, role_),
  };
  Resource_AllocationInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_AllocationInfo_descriptor_,
      Resource_AllocationInfo::default_instance_,
      Resource_AllocationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_AllocationInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_AllocationInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_AllocationInfo, _internal_metadata_),
      -1);
  Resource_ReservationInfo_descriptor_ = Resource_descriptor_->nested_type(1);
  static const int Resource_ReservationInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, labels_),
  };
  Resource_ReservationInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_ReservationInfo_descriptor_,
      Resource_ReservationInfo::default_instance_,
      Resource_ReservationInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_ReservationInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_ReservationInfo, _internal_metadata_),
      -1);
  Resource_DiskInfo_descriptor_ = Resource_descriptor_->nested_type(2);
  static const int Resource_DiskInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, persistence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, volume_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, source_),
  };
  Resource_DiskInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_DiskInfo_descriptor_,
      Resource_DiskInfo::default_instance_,
      Resource_DiskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_DiskInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo, _internal_metadata_),
      -1);
  Resource_DiskInfo_Persistence_descriptor_ = Resource_DiskInfo_descriptor_->nested_type(0);
  static const int Resource_DiskInfo_Persistence_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, principal_),
  };
  Resource_DiskInfo_Persistence_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_DiskInfo_Persistence_descriptor_,
      Resource_DiskInfo_Persistence::default_instance_,
      Resource_DiskInfo_Persistence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_DiskInfo_Persistence),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Persistence, _internal_metadata_),
      -1);
  Resource_DiskInfo_Source_descriptor_ = Resource_DiskInfo_descriptor_->nested_type(1);
  static const int Resource_DiskInfo_Source_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, mount_),
  };
  Resource_DiskInfo_Source_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_DiskInfo_Source_descriptor_,
      Resource_DiskInfo_Source::default_instance_,
      Resource_DiskInfo_Source_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_DiskInfo_Source),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source, _internal_metadata_),
      -1);
  Resource_DiskInfo_Source_Path_descriptor_ = Resource_DiskInfo_Source_descriptor_->nested_type(0);
  static const int Resource_DiskInfo_Source_Path_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Path, root_),
  };
  Resource_DiskInfo_Source_Path_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_DiskInfo_Source_Path_descriptor_,
      Resource_DiskInfo_Source_Path::default_instance_,
      Resource_DiskInfo_Source_Path_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Path, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_DiskInfo_Source_Path),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Path, _internal_metadata_),
      -1);
  Resource_DiskInfo_Source_Mount_descriptor_ = Resource_DiskInfo_Source_descriptor_->nested_type(1);
  static const int Resource_DiskInfo_Source_Mount_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Mount, root_),
  };
  Resource_DiskInfo_Source_Mount_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_DiskInfo_Source_Mount_descriptor_,
      Resource_DiskInfo_Source_Mount::default_instance_,
      Resource_DiskInfo_Source_Mount_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Mount, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_DiskInfo_Source_Mount),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_DiskInfo_Source_Mount, _internal_metadata_),
      -1);
  Resource_DiskInfo_Source_Type_descriptor_ = Resource_DiskInfo_Source_descriptor_->enum_type(0);
  Resource_RevocableInfo_descriptor_ = Resource_descriptor_->nested_type(3);
  static const int Resource_RevocableInfo_offsets_[1] = {
  };
  Resource_RevocableInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_RevocableInfo_descriptor_,
      Resource_RevocableInfo::default_instance_,
      Resource_RevocableInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_RevocableInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_RevocableInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_RevocableInfo, _internal_metadata_),
      -1);
  Resource_SharedInfo_descriptor_ = Resource_descriptor_->nested_type(4);
  static const int Resource_SharedInfo_offsets_[1] = {
  };
  Resource_SharedInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Resource_SharedInfo_descriptor_,
      Resource_SharedInfo::default_instance_,
      Resource_SharedInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_SharedInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(Resource_SharedInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Resource_SharedInfo, _internal_metadata_),
      -1);
  TrafficControlStatistics_descriptor_ = file->message_type(24);
  static const int TrafficControlStatistics_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, backlog_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, drops_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, overlimits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, qlen_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, ratebps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, ratepps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, requeues_),
  };
  TrafficControlStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TrafficControlStatistics_descriptor_,
      TrafficControlStatistics::default_instance_,
      TrafficControlStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(TrafficControlStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TrafficControlStatistics, _internal_metadata_),
      -1);
  IpStatistics_descriptor_ = file->message_type(25);
  static const int IpStatistics_offsets_[19] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, forwarding_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, defaultttl_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inreceives_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inhdrerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inaddrerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, forwdatagrams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, inunknownprotos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, indiscards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, indelivers_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, outrequests_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, outdiscards_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, outnoroutes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmtimeout_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmreqds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmoks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, reasmfails_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, fragoks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, fragfails_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, fragcreates_),
  };
  IpStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IpStatistics_descriptor_,
      IpStatistics::default_instance_,
      IpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(IpStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IpStatistics, _internal_metadata_),
      -1);
  IcmpStatistics_descriptor_ = file->message_type(26);
  static const int IcmpStatistics_offsets_[27] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inmsgs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, incsumerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, indestunreachs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, intimeexcds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inparmprobs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, insrcquenchs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inredirects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inechos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inechoreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, intimestamps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, intimestampreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inaddrmasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, inaddrmaskreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outmsgs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outdestunreachs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outtimeexcds_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outparmprobs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outsrcquenchs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outredirects_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outechos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outechoreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outtimestamps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outtimestampreps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outaddrmasks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, outaddrmaskreps_),
  };
  IcmpStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      IcmpStatistics_descriptor_,
      IcmpStatistics::default_instance_,
      IcmpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(IcmpStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(IcmpStatistics, _internal_metadata_),
      -1);
  TcpStatistics_descriptor_ = file->message_type(27);
  static const int TcpStatistics_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, rtoalgorithm_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, rtomin_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, rtomax_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, maxconn_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, activeopens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, passiveopens_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, attemptfails_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, estabresets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, currestab_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, insegs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, outsegs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, retranssegs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, inerrs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, outrsts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, incsumerrors_),
  };
  TcpStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TcpStatistics_descriptor_,
      TcpStatistics::default_instance_,
      TcpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(TcpStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TcpStatistics, _internal_metadata_),
      -1);
  UdpStatistics_descriptor_ = file->message_type(28);
  static const int UdpStatistics_offsets_[8] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, indatagrams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, noports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, inerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, outdatagrams_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, rcvbuferrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, sndbuferrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, incsumerrors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, ignoredmulti_),
  };
  UdpStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      UdpStatistics_descriptor_,
      UdpStatistics::default_instance_,
      UdpStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(UdpStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(UdpStatistics, _internal_metadata_),
      -1);
  SNMPStatistics_descriptor_ = file->message_type(29);
  static const int SNMPStatistics_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, ip_stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, icmp_stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, tcp_stats_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, udp_stats_),
  };
  SNMPStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SNMPStatistics_descriptor_,
      SNMPStatistics::default_instance_,
      SNMPStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(SNMPStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SNMPStatistics, _internal_metadata_),
      -1);
  ResourceStatistics_descriptor_ = file->message_type(30);
  static const int ResourceStatistics_offsets_[42] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, processes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, threads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_user_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_system_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_limit_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_nr_periods_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_nr_throttled_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, cpus_throttled_time_secs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_total_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_total_memsw_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_soft_limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_file_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_anon_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_cache_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_rss_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_mapped_file_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_swap_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_unevictable_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_low_pressure_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_medium_pressure_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, mem_critical_pressure_counter_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, disk_limit_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, disk_used_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, perf_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_errors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_rx_dropped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_packets_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_errors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tx_dropped_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p50_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p90_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p95_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_rtt_microsecs_p99_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_active_connections_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_tcp_time_wait_connections_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_traffic_control_statistics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, net_snmp_statistics_),
  };
  ResourceStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResourceStatistics_descriptor_,
      ResourceStatistics::default_instance_,
      ResourceStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResourceStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceStatistics, _internal_metadata_),
      -1);
  ResourceUsage_descriptor_ = file->message_type(31);
  static const int ResourceUsage_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, executors_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, total_),
  };
  ResourceUsage_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResourceUsage_descriptor_,
      ResourceUsage::default_instance_,
      ResourceUsage_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResourceUsage),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage, _internal_metadata_),
      -1);
  ResourceUsage_Executor_descriptor_ = ResourceUsage_descriptor_->nested_type(0);
  static const int ResourceUsage_Executor_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, executor_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, allocated_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, statistics_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, container_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, tasks_),
  };
  ResourceUsage_Executor_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResourceUsage_Executor_descriptor_,
      ResourceUsage_Executor::default_instance_,
      ResourceUsage_Executor_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResourceUsage_Executor),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor, _internal_metadata_),
      -1);
  ResourceUsage_Executor_Task_descriptor_ = ResourceUsage_Executor_descriptor_->nested_type(0);
  static const int ResourceUsage_Executor_Task_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, labels_),
  };
  ResourceUsage_Executor_Task_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ResourceUsage_Executor_Task_descriptor_,
      ResourceUsage_Executor_Task::default_instance_,
      ResourceUsage_Executor_Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, _has_bits_[0]),
      -1,
      -1,
      sizeof(ResourceUsage_Executor_Task),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResourceUsage_Executor_Task, _internal_metadata_),
      -1);
  PerfStatistics_descriptor_ = file->message_type(32);
  static const int PerfStatistics_offsets_[53] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, duration_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cycles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, stalled_cycles_frontend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, stalled_cycles_backend_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, instructions_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cache_references_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cache_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, bus_cycles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, ref_cycles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cpu_clock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, task_clock_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, page_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, minor_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, major_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, context_switches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, cpu_migrations_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, alignment_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, emulation_faults_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_dcache_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, l1_icache_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, llc_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, dtlb_prefetch_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, itlb_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, itlb_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branch_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, branch_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_loads_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_load_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_stores_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_store_misses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_prefetches_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, node_prefetch_misses_),
  };
  PerfStatistics_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PerfStatistics_descriptor_,
      PerfStatistics::default_instance_,
      PerfStatistics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, _has_bits_[0]),
      -1,
      -1,
      sizeof(PerfStatistics),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PerfStatistics, _internal_metadata_),
      -1);
  Request_descriptor_ = file->message_type(33);
  static const int Request_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, resources_),
  };
  Request_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Request_descriptor_,
      Request::default_instance_,
      Request_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _has_bits_[0]),
      -1,
      -1,
      sizeof(Request),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Request, _internal_metadata_),
      -1);
  Offer_descriptor_ = file->message_type(34);
  static const int Offer_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, attributes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, executor_ids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, unavailability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, allocation_info_),
  };
  Offer_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_descriptor_,
      Offer::default_instance_,
      Offer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer, _internal_metadata_),
      -1);
  Offer_Operation_descriptor_ = Offer_descriptor_->nested_type(0);
  static const int Offer_Operation_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, launch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, launch_group_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, reserve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, unreserve_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, create_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, destroy_),
  };
  Offer_Operation_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_descriptor_,
      Offer_Operation::default_instance_,
      Offer_Operation_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation, _internal_metadata_),
      -1);
  Offer_Operation_Launch_descriptor_ = Offer_Operation_descriptor_->nested_type(0);
  static const int Offer_Operation_Launch_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Launch, task_infos_),
  };
  Offer_Operation_Launch_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_Launch_descriptor_,
      Offer_Operation_Launch::default_instance_,
      Offer_Operation_Launch_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Launch, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation_Launch),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Launch, _internal_metadata_),
      -1);
  Offer_Operation_LaunchGroup_descriptor_ = Offer_Operation_descriptor_->nested_type(1);
  static const int Offer_Operation_LaunchGroup_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, executor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, task_group_),
  };
  Offer_Operation_LaunchGroup_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_LaunchGroup_descriptor_,
      Offer_Operation_LaunchGroup::default_instance_,
      Offer_Operation_LaunchGroup_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation_LaunchGroup),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_LaunchGroup, _internal_metadata_),
      -1);
  Offer_Operation_Reserve_descriptor_ = Offer_Operation_descriptor_->nested_type(2);
  static const int Offer_Operation_Reserve_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Reserve, resources_),
  };
  Offer_Operation_Reserve_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_Reserve_descriptor_,
      Offer_Operation_Reserve::default_instance_,
      Offer_Operation_Reserve_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Reserve, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation_Reserve),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Reserve, _internal_metadata_),
      -1);
  Offer_Operation_Unreserve_descriptor_ = Offer_Operation_descriptor_->nested_type(3);
  static const int Offer_Operation_Unreserve_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Unreserve, resources_),
  };
  Offer_Operation_Unreserve_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_Unreserve_descriptor_,
      Offer_Operation_Unreserve::default_instance_,
      Offer_Operation_Unreserve_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Unreserve, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation_Unreserve),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Unreserve, _internal_metadata_),
      -1);
  Offer_Operation_Create_descriptor_ = Offer_Operation_descriptor_->nested_type(4);
  static const int Offer_Operation_Create_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Create, volumes_),
  };
  Offer_Operation_Create_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_Create_descriptor_,
      Offer_Operation_Create::default_instance_,
      Offer_Operation_Create_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Create, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation_Create),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Create, _internal_metadata_),
      -1);
  Offer_Operation_Destroy_descriptor_ = Offer_Operation_descriptor_->nested_type(5);
  static const int Offer_Operation_Destroy_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Destroy, volumes_),
  };
  Offer_Operation_Destroy_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Offer_Operation_Destroy_descriptor_,
      Offer_Operation_Destroy::default_instance_,
      Offer_Operation_Destroy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Destroy, _has_bits_[0]),
      -1,
      -1,
      sizeof(Offer_Operation_Destroy),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Offer_Operation_Destroy, _internal_metadata_),
      -1);
  Offer_Operation_Type_descriptor_ = Offer_Operation_descriptor_->enum_type(0);
  InverseOffer_descriptor_ = file->message_type(35);
  static const int InverseOffer_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, url_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, unavailability_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, resources_),
  };
  InverseOffer_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      InverseOffer_descriptor_,
      InverseOffer::default_instance_,
      InverseOffer_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, _has_bits_[0]),
      -1,
      -1,
      sizeof(InverseOffer),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(InverseOffer, _internal_metadata_),
      -1);
  TaskInfo_descriptor_ = file->message_type(36);
  static const int TaskInfo_offsets_[13] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, executor_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, health_check_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, check_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, kill_policy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, discovery_),
  };
  TaskInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TaskInfo_descriptor_,
      TaskInfo::default_instance_,
      TaskInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(TaskInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskInfo, _internal_metadata_),
      -1);
  TaskGroupInfo_descriptor_ = file->message_type(37);
  static const int TaskGroupInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskGroupInfo, tasks_),
  };
  TaskGroupInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TaskGroupInfo_descriptor_,
      TaskGroupInfo::default_instance_,
      TaskGroupInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskGroupInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(TaskGroupInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskGroupInfo, _internal_metadata_),
      -1);
  Task_descriptor_ = file->message_type(38);
  static const int Task_offsets_[14] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, framework_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, resources_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, statuses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, status_update_state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, status_update_uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, discovery_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, container_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, user_),
  };
  Task_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Task_descriptor_,
      Task::default_instance_,
      Task_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _has_bits_[0]),
      -1,
      -1,
      sizeof(Task),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Task, _internal_metadata_),
      -1);
  CheckStatusInfo_descriptor_ = file->message_type(39);
  static const int CheckStatusInfo_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, command_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, http_),
  };
  CheckStatusInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckStatusInfo_descriptor_,
      CheckStatusInfo::default_instance_,
      CheckStatusInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckStatusInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo, _internal_metadata_),
      -1);
  CheckStatusInfo_Command_descriptor_ = CheckStatusInfo_descriptor_->nested_type(0);
  static const int CheckStatusInfo_Command_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Command, exit_code_),
  };
  CheckStatusInfo_Command_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckStatusInfo_Command_descriptor_,
      CheckStatusInfo_Command::default_instance_,
      CheckStatusInfo_Command_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Command, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckStatusInfo_Command),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Command, _internal_metadata_),
      -1);
  CheckStatusInfo_Http_descriptor_ = CheckStatusInfo_descriptor_->nested_type(1);
  static const int CheckStatusInfo_Http_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Http, status_code_),
  };
  CheckStatusInfo_Http_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CheckStatusInfo_Http_descriptor_,
      CheckStatusInfo_Http::default_instance_,
      CheckStatusInfo_Http_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Http, _has_bits_[0]),
      -1,
      -1,
      sizeof(CheckStatusInfo_Http),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CheckStatusInfo_Http, _internal_metadata_),
      -1);
  TaskStatus_descriptor_ = file->message_type(40);
  static const int TaskStatus_offsets_[15] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, task_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, state_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, message_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, source_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, reason_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, data_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, slave_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, executor_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, timestamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, uuid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, healthy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, check_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, container_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, unreachable_time_),
  };
  TaskStatus_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TaskStatus_descriptor_,
      TaskStatus::default_instance_,
      TaskStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, _has_bits_[0]),
      -1,
      -1,
      sizeof(TaskStatus),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TaskStatus, _internal_metadata_),
      -1);
  TaskStatus_Source_descriptor_ = TaskStatus_descriptor_->enum_type(0);
  TaskStatus_Reason_descriptor_ = TaskStatus_descriptor_->enum_type(1);
  Filters_descriptor_ = file->message_type(41);
  static const int Filters_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filters, refuse_seconds_),
  };
  Filters_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Filters_descriptor_,
      Filters::default_instance_,
      Filters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filters, _has_bits_[0]),
      -1,
      -1,
      sizeof(Filters),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Filters, _internal_metadata_),
      -1);
  Environment_descriptor_ = file->message_type(42);
  static const int Environment_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, variables_),
  };
  Environment_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Environment_descriptor_,
      Environment::default_instance_,
      Environment_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, _has_bits_[0]),
      -1,
      -1,
      sizeof(Environment),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment, _internal_metadata_),
      -1);
  Environment_Variable_descriptor_ = Environment_descriptor_->nested_type(0);
  static const int Environment_Variable_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, value_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, secret_),
  };
  Environment_Variable_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Environment_Variable_descriptor_,
      Environment_Variable::default_instance_,
      Environment_Variable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, _has_bits_[0]),
      -1,
      -1,
      sizeof(Environment_Variable),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Environment_Variable, _internal_metadata_),
      -1);
  Environment_Variable_Type_descriptor_ = Environment_Variable_descriptor_->enum_type(0);
  Parameter_descriptor_ = file->message_type(43);
  static const int Parameter_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, value_),
  };
  Parameter_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Parameter_descriptor_,
      Parameter::default_instance_,
      Parameter_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, _has_bits_[0]),
      -1,
      -1,
      sizeof(Parameter),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameter, _internal_metadata_),
      -1);
  Parameters_descriptor_ = file->message_type(44);
  static const int Parameters_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameters, parameter_),
  };
  Parameters_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Parameters_descriptor_,
      Parameters::default_instance_,
      Parameters_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameters, _has_bits_[0]),
      -1,
      -1,
      sizeof(Parameters),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Parameters, _internal_metadata_),
      -1);
  Credential_descriptor_ = file->message_type(45);
  static const int Credential_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, secret_),
  };
  Credential_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Credential_descriptor_,
      Credential::default_instance_,
      Credential_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, _has_bits_[0]),
      -1,
      -1,
      sizeof(Credential),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credential, _internal_metadata_),
      -1);
  Credentials_descriptor_ = file->message_type(46);
  static const int Credentials_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credentials, credentials_),
  };
  Credentials_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Credentials_descriptor_,
      Credentials::default_instance_,
      Credentials_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credentials, _has_bits_[0]),
      -1,
      -1,
      sizeof(Credentials),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Credentials, _internal_metadata_),
      -1);
  Secret_descriptor_ = file->message_type(47);
  static const int Secret_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, reference_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, value_),
  };
  Secret_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Secret_descriptor_,
      Secret::default_instance_,
      Secret_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, _has_bits_[0]),
      -1,
      -1,
      sizeof(Secret),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret, _internal_metadata_),
      -1);
  Secret_Reference_descriptor_ = Secret_descriptor_->nested_type(0);
  static const int Secret_Reference_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, key_),
  };
  Secret_Reference_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Secret_Reference_descriptor_,
      Secret_Reference::default_instance_,
      Secret_Reference_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, _has_bits_[0]),
      -1,
      -1,
      sizeof(Secret_Reference),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Reference, _internal_metadata_),
      -1);
  Secret_Value_descriptor_ = Secret_descriptor_->nested_type(1);
  static const int Secret_Value_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Value, data_),
  };
  Secret_Value_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Secret_Value_descriptor_,
      Secret_Value::default_instance_,
      Secret_Value_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Value, _has_bits_[0]),
      -1,
      -1,
      sizeof(Secret_Value),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Secret_Value, _internal_metadata_),
      -1);
  Secret_Type_descriptor_ = Secret_descriptor_->enum_type(0);
  RateLimit_descriptor_ = file->message_type(48);
  static const int RateLimit_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, qps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, principal_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, capacity_),
  };
  RateLimit_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RateLimit_descriptor_,
      RateLimit::default_instance_,
      RateLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, _has_bits_[0]),
      -1,
      -1,
      sizeof(RateLimit),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimit, _internal_metadata_),
      -1);
  RateLimits_descriptor_ = file->message_type(49);
  static const int RateLimits_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, limits_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, aggregate_default_qps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, aggregate_default_capacity_),
  };
  RateLimits_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RateLimits_descriptor_,
      RateLimits::default_instance_,
      RateLimits_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, _has_bits_[0]),
      -1,
      -1,
      sizeof(RateLimits),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RateLimits, _internal_metadata_),
      -1);
  Image_descriptor_ = file->message_type(50);
  static const int Image_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, appc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, docker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, cached_),
  };
  Image_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Image_descriptor_,
      Image::default_instance_,
      Image_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _has_bits_[0]),
      -1,
      -1,
      sizeof(Image),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image, _internal_metadata_),
      -1);
  Image_Appc_descriptor_ = Image_descriptor_->nested_type(0);
  static const int Image_Appc_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, labels_),
  };
  Image_Appc_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Image_Appc_descriptor_,
      Image_Appc::default_instance_,
      Image_Appc_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, _has_bits_[0]),
      -1,
      -1,
      sizeof(Image_Appc),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Appc, _internal_metadata_),
      -1);
  Image_Docker_descriptor_ = Image_descriptor_->nested_type(1);
  static const int Image_Docker_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, credential_),
  };
  Image_Docker_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Image_Docker_descriptor_,
      Image_Docker::default_instance_,
      Image_Docker_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, _has_bits_[0]),
      -1,
      -1,
      sizeof(Image_Docker),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Image_Docker, _internal_metadata_),
      -1);
  Image_Type_descriptor_ = Image_descriptor_->enum_type(0);
  Volume_descriptor_ = file->message_type(51);
  static const int Volume_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, container_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, host_path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, source_),
  };
  Volume_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Volume_descriptor_,
      Volume::default_instance_,
      Volume_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, _has_bits_[0]),
      -1,
      -1,
      sizeof(Volume),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume, _internal_metadata_),
      -1);
  Volume_Source_descriptor_ = Volume_descriptor_->nested_type(0);
  static const int Volume_Source_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, docker_volume_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, sandbox_path_),
  };
  Volume_Source_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Volume_Source_descriptor_,
      Volume_Source::default_instance_,
      Volume_Source_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, _has_bits_[0]),
      -1,
      -1,
      sizeof(Volume_Source),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source, _internal_metadata_),
      -1);
  Volume_Source_DockerVolume_descriptor_ = Volume_Source_descriptor_->nested_type(0);
  static const int Volume_Source_DockerVolume_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, driver_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, driver_options_),
  };
  Volume_Source_DockerVolume_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Volume_Source_DockerVolume_descriptor_,
      Volume_Source_DockerVolume::default_instance_,
      Volume_Source_DockerVolume_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, _has_bits_[0]),
      -1,
      -1,
      sizeof(Volume_Source_DockerVolume),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_DockerVolume, _internal_metadata_),
      -1);
  Volume_Source_SandboxPath_descriptor_ = Volume_Source_descriptor_->nested_type(1);
  static const int Volume_Source_SandboxPath_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, path_),
  };
  Volume_Source_SandboxPath_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Volume_Source_SandboxPath_descriptor_,
      Volume_Source_SandboxPath::default_instance_,
      Volume_Source_SandboxPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, _has_bits_[0]),
      -1,
      -1,
      sizeof(Volume_Source_SandboxPath),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Volume_Source_SandboxPath, _internal_metadata_),
      -1);
  Volume_Source_SandboxPath_Type_descriptor_ = Volume_Source_SandboxPath_descriptor_->enum_type(0);
  Volume_Source_Type_descriptor_ = Volume_Source_descriptor_->enum_type(0);
  Volume_Mode_descriptor_ = Volume_descriptor_->enum_type(0);
  NetworkInfo_descriptor_ = file->message_type(52);
  static const int NetworkInfo_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, ip_addresses_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, groups_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, labels_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, port_mappings_),
  };
  NetworkInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NetworkInfo_descriptor_,
      NetworkInfo::default_instance_,
      NetworkInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(NetworkInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo, _internal_metadata_),
      -1);
  NetworkInfo_IPAddress_descriptor_ = NetworkInfo_descriptor_->nested_type(0);
  static const int NetworkInfo_IPAddress_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, protocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, ip_address_),
  };
  NetworkInfo_IPAddress_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NetworkInfo_IPAddress_descriptor_,
      NetworkInfo_IPAddress::default_instance_,
      NetworkInfo_IPAddress_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, _has_bits_[0]),
      -1,
      -1,
      sizeof(NetworkInfo_IPAddress),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_IPAddress, _internal_metadata_),
      -1);
  NetworkInfo_PortMapping_descriptor_ = NetworkInfo_descriptor_->nested_type(1);
  static const int NetworkInfo_PortMapping_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, host_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, container_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, protocol_),
  };
  NetworkInfo_PortMapping_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NetworkInfo_PortMapping_descriptor_,
      NetworkInfo_PortMapping::default_instance_,
      NetworkInfo_PortMapping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, _has_bits_[0]),
      -1,
      -1,
      sizeof(NetworkInfo_PortMapping),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetworkInfo_PortMapping, _internal_metadata_),
      -1);
  NetworkInfo_Protocol_descriptor_ = NetworkInfo_descriptor_->enum_type(0);
  CapabilityInfo_descriptor_ = file->message_type(53);
  static const int CapabilityInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CapabilityInfo, capabilities_),
  };
  CapabilityInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CapabilityInfo_descriptor_,
      CapabilityInfo::default_instance_,
      CapabilityInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CapabilityInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(CapabilityInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CapabilityInfo, _internal_metadata_),
      -1);
  CapabilityInfo_Capability_descriptor_ = CapabilityInfo_descriptor_->enum_type(0);
  LinuxInfo_descriptor_ = file->message_type(54);
  static const int LinuxInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinuxInfo, capability_info_),
  };
  LinuxInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      LinuxInfo_descriptor_,
      LinuxInfo::default_instance_,
      LinuxInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinuxInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(LinuxInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LinuxInfo, _internal_metadata_),
      -1);
  RLimitInfo_descriptor_ = file->message_type(55);
  static const int RLimitInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo, rlimits_),
  };
  RLimitInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RLimitInfo_descriptor_,
      RLimitInfo::default_instance_,
      RLimitInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(RLimitInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo, _internal_metadata_),
      -1);
  RLimitInfo_RLimit_descriptor_ = RLimitInfo_descriptor_->nested_type(0);
  static const int RLimitInfo_RLimit_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, hard_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, soft_),
  };
  RLimitInfo_RLimit_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RLimitInfo_RLimit_descriptor_,
      RLimitInfo_RLimit::default_instance_,
      RLimitInfo_RLimit_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, _has_bits_[0]),
      -1,
      -1,
      sizeof(RLimitInfo_RLimit),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RLimitInfo_RLimit, _internal_metadata_),
      -1);
  RLimitInfo_RLimit_Type_descriptor_ = RLimitInfo_RLimit_descriptor_->enum_type(0);
  TTYInfo_descriptor_ = file->message_type(56);
  static const int TTYInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo, window_size_),
  };
  TTYInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TTYInfo_descriptor_,
      TTYInfo::default_instance_,
      TTYInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(TTYInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo, _internal_metadata_),
      -1);
  TTYInfo_WindowSize_descriptor_ = TTYInfo_descriptor_->nested_type(0);
  static const int TTYInfo_WindowSize_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, rows_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, columns_),
  };
  TTYInfo_WindowSize_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TTYInfo_WindowSize_descriptor_,
      TTYInfo_WindowSize::default_instance_,
      TTYInfo_WindowSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, _has_bits_[0]),
      -1,
      -1,
      sizeof(TTYInfo_WindowSize),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TTYInfo_WindowSize, _internal_metadata_),
      -1);
  ContainerInfo_descriptor_ = file->message_type(57);
  static const int ContainerInfo_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, volumes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, hostname_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, docker_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, mesos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, network_infos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, linux_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, rlimit_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, tty_info_),
  };
  ContainerInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ContainerInfo_descriptor_,
      ContainerInfo::default_instance_,
      ContainerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(ContainerInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo, _internal_metadata_),
      -1);
  ContainerInfo_DockerInfo_descriptor_ = ContainerInfo_descriptor_->nested_type(0);
  static const int ContainerInfo_DockerInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, network_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, port_mappings_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, privileged_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, parameters_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, force_pull_image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, volume_driver_),
  };
  ContainerInfo_DockerInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ContainerInfo_DockerInfo_descriptor_,
      ContainerInfo_DockerInfo::default_instance_,
      ContainerInfo_DockerInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(ContainerInfo_DockerInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo, _internal_metadata_),
      -1);
  ContainerInfo_DockerInfo_PortMapping_descriptor_ = ContainerInfo_DockerInfo_descriptor_->nested_type(0);
  static const int ContainerInfo_DockerInfo_PortMapping_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, host_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, container_port_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, protocol_),
  };
  ContainerInfo_DockerInfo_PortMapping_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ContainerInfo_DockerInfo_PortMapping_descriptor_,
      ContainerInfo_DockerInfo_PortMapping::default_instance_,
      ContainerInfo_DockerInfo_PortMapping_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, _has_bits_[0]),
      -1,
      -1,
      sizeof(ContainerInfo_DockerInfo_PortMapping),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_DockerInfo_PortMapping, _internal_metadata_),
      -1);
  ContainerInfo_DockerInfo_Network_descriptor_ = ContainerInfo_DockerInfo_descriptor_->enum_type(0);
  ContainerInfo_MesosInfo_descriptor_ = ContainerInfo_descriptor_->nested_type(1);
  static const int ContainerInfo_MesosInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_MesosInfo, image_),
  };
  ContainerInfo_MesosInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ContainerInfo_MesosInfo_descriptor_,
      ContainerInfo_MesosInfo::default_instance_,
      ContainerInfo_MesosInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_MesosInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(ContainerInfo_MesosInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerInfo_MesosInfo, _internal_metadata_),
      -1);
  ContainerInfo_Type_descriptor_ = ContainerInfo_descriptor_->enum_type(0);
  ContainerStatus_descriptor_ = file->message_type(58);
  static const int ContainerStatus_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, container_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, network_infos_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, cgroup_info_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, executor_pid_),
  };
  ContainerStatus_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ContainerStatus_descriptor_,
      ContainerStatus::default_instance_,
      ContainerStatus_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, _has_bits_[0]),
      -1,
      -1,
      sizeof(ContainerStatus),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ContainerStatus, _internal_metadata_),
      -1);
  CgroupInfo_descriptor_ = file->message_type(59);
  static const int CgroupInfo_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo, net_cls_),
  };
  CgroupInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CgroupInfo_descriptor_,
      CgroupInfo::default_instance_,
      CgroupInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(CgroupInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo, _internal_metadata_),
      -1);
  CgroupInfo_NetCls_descriptor_ = CgroupInfo_descriptor_->nested_type(0);
  static const int CgroupInfo_NetCls_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo_NetCls, classid_),
  };
  CgroupInfo_NetCls_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CgroupInfo_NetCls_descriptor_,
      CgroupInfo_NetCls::default_instance_,
      CgroupInfo_NetCls_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo_NetCls, _has_bits_[0]),
      -1,
      -1,
      sizeof(CgroupInfo_NetCls),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CgroupInfo_NetCls, _internal_metadata_),
      -1);
  Labels_descriptor_ = file->message_type(60);
  static const int Labels_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labels, labels_),
  };
  Labels_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Labels_descriptor_,
      Labels::default_instance_,
      Labels_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labels, _has_bits_[0]),
      -1,
      -1,
      sizeof(Labels),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labels, _internal_metadata_),
      -1);
  Label_descriptor_ = file->message_type(61);
  static const int Label_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, value_),
  };
  Label_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Label_descriptor_,
      Label::default_instance_,
      Label_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, _has_bits_[0]),
      -1,
      -1,
      sizeof(Label),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, _internal_metadata_),
      -1);
  Port_descriptor_ = file->message_type(62);
  static const int Port_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, number_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, protocol_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, visibility_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, labels_),
  };
  Port_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Port_descriptor_,
      Port::default_instance_,
      Port_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, _has_bits_[0]),
      -1,
      -1,
      sizeof(Port),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Port, _internal_metadata_),
      -1);
  Ports_descriptor_ = file->message_type(63);
  static const int Ports_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ports, ports_),
  };
  Ports_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Ports_descriptor_,
      Ports::default_instance_,
      Ports_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ports, _has_bits_[0]),
      -1,
      -1,
      sizeof(Ports),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Ports, _internal_metadata_),
      -1);
  DiscoveryInfo_descriptor_ = file->message_type(64);
  static const int DiscoveryInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, visibility_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, environment_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, ports_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, labels_),
  };
  DiscoveryInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DiscoveryInfo_descriptor_,
      DiscoveryInfo::default_instance_,
      DiscoveryInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(DiscoveryInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DiscoveryInfo, _internal_metadata_),
      -1);
  DiscoveryInfo_Visibility_descriptor_ = DiscoveryInfo_descriptor_->enum_type(0);
  WeightInfo_descriptor_ = file->message_type(65);
  static const int WeightInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, weight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, role_),
  };
  WeightInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      WeightInfo_descriptor_,
      WeightInfo::default_instance_,
      WeightInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(WeightInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WeightInfo, _internal_metadata_),
      -1);
  VersionInfo_descriptor_ = file->message_type(66);
  static const int VersionInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, build_date_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, build_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, build_user_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, git_sha_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, git_branch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, git_tag_),
  };
  VersionInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      VersionInfo_descriptor_,
      VersionInfo::default_instance_,
      VersionInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(VersionInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VersionInfo, _internal_metadata_),
      -1);
  Flag_descriptor_ = file->message_type(67);
  static const int Flag_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, value_),
  };
  Flag_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Flag_descriptor_,
      Flag::default_instance_,
      Flag_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, _has_bits_[0]),
      -1,
      -1,
      sizeof(Flag),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Flag, _internal_metadata_),
      -1);
  Role_descriptor_ = file->message_type(68);
  static const int Role_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, weight_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, frameworks_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, resources_),
  };
  Role_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Role_descriptor_,
      Role::default_instance_,
      Role_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, _has_bits_[0]),
      -1,
      -1,
      sizeof(Role),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Role, _internal_metadata_),
      -1);
  Metric_descriptor_ = file->message_type(69);
  static const int Metric_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, value_),
  };
  Metric_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Metric_descriptor_,
      Metric::default_instance_,
      Metric_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, _has_bits_[0]),
      -1,
      -1,
      sizeof(Metric),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Metric, _internal_metadata_),
      -1);
  FileInfo_descriptor_ = file->message_type(70);
  static const int FileInfo_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, nlink_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, mtime_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, uid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, gid_),
  };
  FileInfo_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      FileInfo_descriptor_,
      FileInfo::default_instance_,
      FileInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, _has_bits_[0]),
      -1,
      -1,
      sizeof(FileInfo),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileInfo, _internal_metadata_),
      -1);
  Status_descriptor_ = file->enum_type(0);
  TaskState_descriptor_ = file->enum_type(1);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_mesos_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FrameworkID_descriptor_, &FrameworkID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OfferID_descriptor_, &OfferID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SlaveID_descriptor_, &SlaveID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TaskID_descriptor_, &TaskID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ExecutorID_descriptor_, &ExecutorID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ContainerID_descriptor_, &ContainerID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TimeInfo_descriptor_, &TimeInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DurationInfo_descriptor_, &DurationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Address_descriptor_, &Address::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      URL_descriptor_, &URL::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Unavailability_descriptor_, &Unavailability::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MachineID_descriptor_, &MachineID::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MachineInfo_descriptor_, &MachineInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FrameworkInfo_descriptor_, &FrameworkInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FrameworkInfo_Capability_descriptor_, &FrameworkInfo_Capability::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckInfo_descriptor_, &CheckInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckInfo_Command_descriptor_, &CheckInfo_Command::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckInfo_Http_descriptor_, &CheckInfo_Http::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HealthCheck_descriptor_, &HealthCheck::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HealthCheck_HTTPCheckInfo_descriptor_, &HealthCheck_HTTPCheckInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HealthCheck_TCPCheckInfo_descriptor_, &HealthCheck_TCPCheckInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      KillPolicy_descriptor_, &KillPolicy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CommandInfo_descriptor_, &CommandInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CommandInfo_URI_descriptor_, &CommandInfo_URI::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ExecutorInfo_descriptor_, &ExecutorInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      MasterInfo_descriptor_, &MasterInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SlaveInfo_descriptor_, &SlaveInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SlaveInfo_Capability_descriptor_, &SlaveInfo_Capability::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Value_descriptor_, &Value::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Value_Scalar_descriptor_, &Value_Scalar::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Value_Range_descriptor_, &Value_Range::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Value_Ranges_descriptor_, &Value_Ranges::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Value_Set_descriptor_, &Value_Set::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Value_Text_descriptor_, &Value_Text::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Attribute_descriptor_, &Attribute::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_descriptor_, &Resource::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_AllocationInfo_descriptor_, &Resource_AllocationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_ReservationInfo_descriptor_, &Resource_ReservationInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_DiskInfo_descriptor_, &Resource_DiskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_DiskInfo_Persistence_descriptor_, &Resource_DiskInfo_Persistence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_DiskInfo_Source_descriptor_, &Resource_DiskInfo_Source::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_DiskInfo_Source_Path_descriptor_, &Resource_DiskInfo_Source_Path::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_DiskInfo_Source_Mount_descriptor_, &Resource_DiskInfo_Source_Mount::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_RevocableInfo_descriptor_, &Resource_RevocableInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Resource_SharedInfo_descriptor_, &Resource_SharedInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TrafficControlStatistics_descriptor_, &TrafficControlStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IpStatistics_descriptor_, &IpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      IcmpStatistics_descriptor_, &IcmpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TcpStatistics_descriptor_, &TcpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      UdpStatistics_descriptor_, &UdpStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SNMPStatistics_descriptor_, &SNMPStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResourceStatistics_descriptor_, &ResourceStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResourceUsage_descriptor_, &ResourceUsage::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResourceUsage_Executor_descriptor_, &ResourceUsage_Executor::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ResourceUsage_Executor_Task_descriptor_, &ResourceUsage_Executor_Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PerfStatistics_descriptor_, &PerfStatistics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Request_descriptor_, &Request::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_descriptor_, &Offer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_descriptor_, &Offer_Operation::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_Launch_descriptor_, &Offer_Operation_Launch::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_LaunchGroup_descriptor_, &Offer_Operation_LaunchGroup::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_Reserve_descriptor_, &Offer_Operation_Reserve::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_Unreserve_descriptor_, &Offer_Operation_Unreserve::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_Create_descriptor_, &Offer_Operation_Create::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Offer_Operation_Destroy_descriptor_, &Offer_Operation_Destroy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      InverseOffer_descriptor_, &InverseOffer::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TaskInfo_descriptor_, &TaskInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TaskGroupInfo_descriptor_, &TaskGroupInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Task_descriptor_, &Task::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckStatusInfo_descriptor_, &CheckStatusInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckStatusInfo_Command_descriptor_, &CheckStatusInfo_Command::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CheckStatusInfo_Http_descriptor_, &CheckStatusInfo_Http::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TaskStatus_descriptor_, &TaskStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Filters_descriptor_, &Filters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Environment_descriptor_, &Environment::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Environment_Variable_descriptor_, &Environment_Variable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Parameter_descriptor_, &Parameter::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Parameters_descriptor_, &Parameters::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Credential_descriptor_, &Credential::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Credentials_descriptor_, &Credentials::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Secret_descriptor_, &Secret::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Secret_Reference_descriptor_, &Secret_Reference::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Secret_Value_descriptor_, &Secret_Value::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RateLimit_descriptor_, &RateLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RateLimits_descriptor_, &RateLimits::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Image_descriptor_, &Image::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Image_Appc_descriptor_, &Image_Appc::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Image_Docker_descriptor_, &Image_Docker::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Volume_descriptor_, &Volume::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Volume_Source_descriptor_, &Volume_Source::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Volume_Source_DockerVolume_descriptor_, &Volume_Source_DockerVolume::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Volume_Source_SandboxPath_descriptor_, &Volume_Source_SandboxPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NetworkInfo_descriptor_, &NetworkInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NetworkInfo_IPAddress_descriptor_, &NetworkInfo_IPAddress::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NetworkInfo_PortMapping_descriptor_, &NetworkInfo_PortMapping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CapabilityInfo_descriptor_, &CapabilityInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      LinuxInfo_descriptor_, &LinuxInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RLimitInfo_descriptor_, &RLimitInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RLimitInfo_RLimit_descriptor_, &RLimitInfo_RLimit::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TTYInfo_descriptor_, &TTYInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TTYInfo_WindowSize_descriptor_, &TTYInfo_WindowSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ContainerInfo_descriptor_, &ContainerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ContainerInfo_DockerInfo_descriptor_, &ContainerInfo_DockerInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ContainerInfo_DockerInfo_PortMapping_descriptor_, &ContainerInfo_DockerInfo_PortMapping::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ContainerInfo_MesosInfo_descriptor_, &ContainerInfo_MesosInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ContainerStatus_descriptor_, &ContainerStatus::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CgroupInfo_descriptor_, &CgroupInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CgroupInfo_NetCls_descriptor_, &CgroupInfo_NetCls::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Labels_descriptor_, &Labels::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Label_descriptor_, &Label::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Port_descriptor_, &Port::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Ports_descriptor_, &Ports::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DiscoveryInfo_descriptor_, &DiscoveryInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      WeightInfo_descriptor_, &WeightInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      VersionInfo_descriptor_, &VersionInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Flag_descriptor_, &Flag::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Role_descriptor_, &Role::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Metric_descriptor_, &Metric::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      FileInfo_descriptor_, &FileInfo::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_mesos_2eproto() {
  delete FrameworkID::default_instance_;
  delete FrameworkID_reflection_;
  delete OfferID::default_instance_;
  delete OfferID_reflection_;
  delete SlaveID::default_instance_;
  delete SlaveID_reflection_;
  delete TaskID::default_instance_;
  delete TaskID_reflection_;
  delete ExecutorID::default_instance_;
  delete ExecutorID_reflection_;
  delete ContainerID::default_instance_;
  delete ContainerID_reflection_;
  delete TimeInfo::default_instance_;
  delete TimeInfo_reflection_;
  delete DurationInfo::default_instance_;
  delete DurationInfo_reflection_;
  delete Address::default_instance_;
  delete Address_reflection_;
  delete URL::default_instance_;
  delete URL_reflection_;
  delete Unavailability::default_instance_;
  delete Unavailability_reflection_;
  delete MachineID::default_instance_;
  delete MachineID_reflection_;
  delete MachineInfo::default_instance_;
  delete MachineInfo_reflection_;
  delete FrameworkInfo::default_instance_;
  delete FrameworkInfo_reflection_;
  delete FrameworkInfo::_default_role_;
  delete FrameworkInfo_Capability::default_instance_;
  delete FrameworkInfo_Capability_reflection_;
  delete CheckInfo::default_instance_;
  delete CheckInfo_reflection_;
  delete CheckInfo_Command::default_instance_;
  delete CheckInfo_Command_reflection_;
  delete CheckInfo_Http::default_instance_;
  delete CheckInfo_Http_reflection_;
  delete HealthCheck::default_instance_;
  delete HealthCheck_reflection_;
  delete HealthCheck_HTTPCheckInfo::default_instance_;
  delete HealthCheck_HTTPCheckInfo_reflection_;
  delete HealthCheck_TCPCheckInfo::default_instance_;
  delete HealthCheck_TCPCheckInfo_reflection_;
  delete KillPolicy::default_instance_;
  delete KillPolicy_reflection_;
  delete CommandInfo::default_instance_;
  delete CommandInfo_reflection_;
  delete CommandInfo_URI::default_instance_;
  delete CommandInfo_URI_reflection_;
  delete ExecutorInfo::default_instance_;
  delete ExecutorInfo_reflection_;
  delete MasterInfo::default_instance_;
  delete MasterInfo_reflection_;
  delete SlaveInfo::default_instance_;
  delete SlaveInfo_reflection_;
  delete SlaveInfo_Capability::default_instance_;
  delete SlaveInfo_Capability_reflection_;
  delete Value::default_instance_;
  delete Value_reflection_;
  delete Value_Scalar::default_instance_;
  delete Value_Scalar_reflection_;
  delete Value_Range::default_instance_;
  delete Value_Range_reflection_;
  delete Value_Ranges::default_instance_;
  delete Value_Ranges_reflection_;
  delete Value_Set::default_instance_;
  delete Value_Set_reflection_;
  delete Value_Text::default_instance_;
  delete Value_Text_reflection_;
  delete Attribute::default_instance_;
  delete Attribute_reflection_;
  delete Resource::default_instance_;
  delete Resource_reflection_;
  delete Resource::_default_role_;
  delete Resource_AllocationInfo::default_instance_;
  delete Resource_AllocationInfo_reflection_;
  delete Resource_ReservationInfo::default_instance_;
  delete Resource_ReservationInfo_reflection_;
  delete Resource_DiskInfo::default_instance_;
  delete Resource_DiskInfo_reflection_;
  delete Resource_DiskInfo_Persistence::default_instance_;
  delete Resource_DiskInfo_Persistence_reflection_;
  delete Resource_DiskInfo_Source::default_instance_;
  delete Resource_DiskInfo_Source_reflection_;
  delete Resource_DiskInfo_Source_Path::default_instance_;
  delete Resource_DiskInfo_Source_Path_reflection_;
  delete Resource_DiskInfo_Source_Mount::default_instance_;
  delete Resource_DiskInfo_Source_Mount_reflection_;
  delete Resource_RevocableInfo::default_instance_;
  delete Resource_RevocableInfo_reflection_;
  delete Resource_SharedInfo::default_instance_;
  delete Resource_SharedInfo_reflection_;
  delete TrafficControlStatistics::default_instance_;
  delete TrafficControlStatistics_reflection_;
  delete IpStatistics::default_instance_;
  delete IpStatistics_reflection_;
  delete IcmpStatistics::default_instance_;
  delete IcmpStatistics_reflection_;
  delete TcpStatistics::default_instance_;
  delete TcpStatistics_reflection_;
  delete UdpStatistics::default_instance_;
  delete UdpStatistics_reflection_;
  delete SNMPStatistics::default_instance_;
  delete SNMPStatistics_reflection_;
  delete ResourceStatistics::default_instance_;
  delete ResourceStatistics_reflection_;
  delete ResourceUsage::default_instance_;
  delete ResourceUsage_reflection_;
  delete ResourceUsage_Executor::default_instance_;
  delete ResourceUsage_Executor_reflection_;
  delete ResourceUsage_Executor_Task::default_instance_;
  delete ResourceUsage_Executor_Task_reflection_;
  delete PerfStatistics::default_instance_;
  delete PerfStatistics_reflection_;
  delete Request::default_instance_;
  delete Request_reflection_;
  delete Offer::default_instance_;
  delete Offer_reflection_;
  delete Offer_Operation::default_instance_;
  delete Offer_Operation_reflection_;
  delete Offer_Operation_Launch::default_instance_;
  delete Offer_Operation_Launch_reflection_;
  delete Offer_Operation_LaunchGroup::default_instance_;
  delete Offer_Operation_LaunchGroup_reflection_;
  delete Offer_Operation_Reserve::default_instance_;
  delete Offer_Operation_Reserve_reflection_;
  delete Offer_Operation_Unreserve::default_instance_;
  delete Offer_Operation_Unreserve_reflection_;
  delete Offer_Operation_Create::default_instance_;
  delete Offer_Operation_Create_reflection_;
  delete Offer_Operation_Destroy::default_instance_;
  delete Offer_Operation_Destroy_reflection_;
  delete InverseOffer::default_instance_;
  delete InverseOffer_reflection_;
  delete TaskInfo::default_instance_;
  delete TaskInfo_reflection_;
  delete TaskGroupInfo::default_instance_;
  delete TaskGroupInfo_reflection_;
  delete Task::default_instance_;
  delete Task_reflection_;
  delete CheckStatusInfo::default_instance_;
  delete CheckStatusInfo_reflection_;
  delete CheckStatusInfo_Command::default_instance_;
  delete CheckStatusInfo_Command_reflection_;
  delete CheckStatusInfo_Http::default_instance_;
  delete CheckStatusInfo_Http_reflection_;
  delete TaskStatus::default_instance_;
  delete TaskStatus_reflection_;
  delete Filters::default_instance_;
  delete Filters_reflection_;
  delete Environment::default_instance_;
  delete Environment_reflection_;
  delete Environment_Variable::default_instance_;
  delete Environment_Variable_reflection_;
  delete Parameter::default_instance_;
  delete Parameter_reflection_;
  delete Parameters::default_instance_;
  delete Parameters_reflection_;
  delete Credential::default_instance_;
  delete Credential_reflection_;
  delete Credentials::default_instance_;
  delete Credentials_reflection_;
  delete Secret::default_instance_;
  delete Secret_reflection_;
  delete Secret_Reference::default_instance_;
  delete Secret_Reference_reflection_;
  delete Secret_Value::default_instance_;
  delete Secret_Value_reflection_;
  delete RateLimit::default_instance_;
  delete RateLimit_reflection_;
  delete RateLimits::default_instance_;
  delete RateLimits_reflection_;
  delete Image::default_instance_;
  delete Image_reflection_;
  delete Image_Appc::default_instance_;
  delete Image_Appc_reflection_;
  delete Image_Docker::default_instance_;
  delete Image_Docker_reflection_;
  delete Volume::default_instance_;
  delete Volume_reflection_;
  delete Volume_Source::default_instance_;
  delete Volume_Source_reflection_;
  delete Volume_Source_DockerVolume::default_instance_;
  delete Volume_Source_DockerVolume_reflection_;
  delete Volume_Source_SandboxPath::default_instance_;
  delete Volume_Source_SandboxPath_reflection_;
  delete NetworkInfo::default_instance_;
  delete NetworkInfo_reflection_;
  delete NetworkInfo_IPAddress::default_instance_;
  delete NetworkInfo_IPAddress_reflection_;
  delete NetworkInfo_PortMapping::default_instance_;
  delete NetworkInfo_PortMapping_reflection_;
  delete CapabilityInfo::default_instance_;
  delete CapabilityInfo_reflection_;
  delete LinuxInfo::default_instance_;
  delete LinuxInfo_reflection_;
  delete RLimitInfo::default_instance_;
  delete RLimitInfo_reflection_;
  delete RLimitInfo_RLimit::default_instance_;
  delete RLimitInfo_RLimit_reflection_;
  delete TTYInfo::default_instance_;
  delete TTYInfo_reflection_;
  delete TTYInfo_WindowSize::default_instance_;
  delete TTYInfo_WindowSize_reflection_;
  delete ContainerInfo::default_instance_;
  delete ContainerInfo_reflection_;
  delete ContainerInfo_DockerInfo::default_instance_;
  delete ContainerInfo_DockerInfo_reflection_;
  delete ContainerInfo_DockerInfo_PortMapping::default_instance_;
  delete ContainerInfo_DockerInfo_PortMapping_reflection_;
  delete ContainerInfo_MesosInfo::default_instance_;
  delete ContainerInfo_MesosInfo_reflection_;
  delete ContainerStatus::default_instance_;
  delete ContainerStatus_reflection_;
  delete CgroupInfo::default_instance_;
  delete CgroupInfo_reflection_;
  delete CgroupInfo_NetCls::default_instance_;
  delete CgroupInfo_NetCls_reflection_;
  delete Labels::default_instance_;
  delete Labels_reflection_;
  delete Label::default_instance_;
  delete Label_reflection_;
  delete Port::default_instance_;
  delete Port_reflection_;
  delete Ports::default_instance_;
  delete Ports_reflection_;
  delete DiscoveryInfo::default_instance_;
  delete DiscoveryInfo_reflection_;
  delete WeightInfo::default_instance_;
  delete WeightInfo_reflection_;
  delete VersionInfo::default_instance_;
  delete VersionInfo_reflection_;
  delete Flag::default_instance_;
  delete Flag_reflection_;
  delete Role::default_instance_;
  delete Role_reflection_;
  delete Metric::default_instance_;
  delete Metric_reflection_;
  delete FileInfo::default_instance_;
  delete FileInfo_reflection_;
}

void protobuf_AddDesc_mesos_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_mesos_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013mesos.proto\022\005mesos\"\034\n\013FrameworkID\022\r\n\005v"
    "alue\030\001 \002(\t\"\030\n\007OfferID\022\r\n\005value\030\001 \002(\t\"\030\n\007"
    "SlaveID\022\r\n\005value\030\001 \002(\t\"\027\n\006TaskID\022\r\n\005valu"
    "e\030\001 \002(\t\"\033\n\nExecutorID\022\r\n\005value\030\001 \002(\t\"@\n\013"
    "ContainerID\022\r\n\005value\030\001 \002(\t\022\"\n\006parent\030\002 \001"
    "(\0132\022.mesos.ContainerID\"\037\n\010TimeInfo\022\023\n\013na"
    "noseconds\030\001 \002(\003\"#\n\014DurationInfo\022\023\n\013nanos"
    "econds\030\001 \002(\003\"5\n\007Address\022\020\n\010hostname\030\001 \001("
    "\t\022\n\n\002ip\030\002 \001(\t\022\014\n\004port\030\003 \002(\005\"w\n\003URL\022\016\n\006sc"
    "heme\030\001 \002(\t\022\037\n\007address\030\002 \002(\0132\016.mesos.Addr"
    "ess\022\014\n\004path\030\003 \001(\t\022\037\n\005query\030\004 \003(\0132\020.mesos"
    ".Parameter\022\020\n\010fragment\030\005 \001(\t\"W\n\016Unavaila"
    "bility\022\036\n\005start\030\001 \002(\0132\017.mesos.TimeInfo\022%"
    "\n\010duration\030\002 \001(\0132\023.mesos.DurationInfo\")\n"
    "\tMachineID\022\020\n\010hostname\030\001 \001(\t\022\n\n\002ip\030\002 \001(\t"
    "\"\251\001\n\013MachineInfo\022\034\n\002id\030\001 \002(\0132\020.mesos.Mac"
    "hineID\022%\n\004mode\030\002 \001(\0162\027.mesos.MachineInfo"
    ".Mode\022-\n\016unavailability\030\003 \001(\0132\025.mesos.Un"
    "availability\"&\n\004Mode\022\006\n\002UP\020\001\022\014\n\010DRAINING"
    "\020\002\022\010\n\004DOWN\020\003\"\326\004\n\rFrameworkInfo\022\014\n\004user\030\001"
    " \002(\t\022\014\n\004name\030\002 \002(\t\022\025\n\rCPUS_PER_TASK\030\003 \002("
    "\002\022\024\n\014MEM_PER_TASK\030\004 \002(\002\022\014\n\004GPUS\030\005 \001(\002\022\014\n"
    "\004DISK\030\007 \001(\002\022\036\n\002id\030\010 \001(\0132\022.mesos.Framewor"
    "kID\022\033\n\020failover_timeout\030\t \001(\001:\0010\022\031\n\nchec"
    "kpoint\030\n \001(\010:\005false\022\023\n\004role\030\006 \001(\t:\001*B\002\030\001"
    "\022\r\n\005roles\030\014 \003(\t\022\020\n\010hostname\030\013 \001(\t\022\021\n\tpri"
    "ncipal\030\r \001(\t\022\021\n\twebui_url\030\016 \001(\t\0225\n\014capab"
    "ilities\030\017 \003(\0132\037.mesos.FrameworkInfo.Capa"
    "bility\022\035\n\006labels\030\020 \001(\0132\r.mesos.Labels\032\325\001"
    "\n\nCapability\0222\n\004type\030\001 \001(\0162$.mesos.Frame"
    "workInfo.Capability.Type\"\222\001\n\004Type\022\013\n\007UNK"
    "NOWN\020\000\022\027\n\023REVOCABLE_RESOURCES\020\001\022\026\n\022TASK_"
    "KILLING_STATE\020\002\022\021\n\rGPU_RESOURCES\020\003\022\024\n\020SH"
    "ARED_RESOURCES\020\004\022\023\n\017PARTITION_AWARE\020\005\022\016\n"
    "\nMULTI_ROLE\020\006\"\326\002\n\tCheckInfo\022#\n\004type\030\001 \001("
    "\0162\025.mesos.CheckInfo.Type\022)\n\007command\030\002 \001("
    "\0132\030.mesos.CheckInfo.Command\022#\n\004http\030\003 \001("
    "\0132\025.mesos.CheckInfo.Http\022\031\n\rdelay_second"
    "s\030\004 \001(\001:\00215\022\034\n\020interval_seconds\030\005 \001(\001:\0021"
    "0\022\033\n\017timeout_seconds\030\006 \001(\001:\00220\032.\n\007Comman"
    "d\022#\n\007command\030\001 \002(\0132\022.mesos.CommandInfo\032\""
    "\n\004Http\022\014\n\004port\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\"*\n\004Ty"
    "pe\022\013\n\007UNKNOWN\020\000\022\013\n\007COMMAND\020\001\022\010\n\004HTTP\020\002\"\362"
    "\003\n\013HealthCheck\022\031\n\rdelay_seconds\030\002 \001(\001:\0021"
    "5\022\034\n\020interval_seconds\030\003 \001(\001:\00210\022\033\n\017timeo"
    "ut_seconds\030\004 \001(\001:\00220\022\037\n\024consecutive_fail"
    "ures\030\005 \001(\r:\0013\022 \n\024grace_period_seconds\030\006 "
    "\001(\001:\00210\022%\n\004type\030\010 \001(\0162\027.mesos.HealthChec"
    "k.Type\022#\n\007command\030\007 \001(\0132\022.mesos.CommandI"
    "nfo\022.\n\004http\030\001 \001(\0132 .mesos.HealthCheck.HT"
    "TPCheckInfo\022,\n\003tcp\030\t \001(\0132\037.mesos.HealthC"
    "heck.TCPCheckInfo\032M\n\rHTTPCheckInfo\022\016\n\006sc"
    "heme\030\003 \001(\t\022\014\n\004port\030\001 \002(\r\022\014\n\004path\030\002 \001(\t\022\020"
    "\n\010statuses\030\004 \003(\r\032\034\n\014TCPCheckInfo\022\014\n\004port"
    "\030\001 \002(\r\"3\n\004Type\022\013\n\007UNKNOWN\020\000\022\013\n\007COMMAND\020\001"
    "\022\010\n\004HTTP\020\002\022\007\n\003TCP\020\003\"7\n\nKillPolicy\022)\n\014gra"
    "ce_period\030\001 \001(\0132\023.mesos.DurationInfo\"\206\002\n"
    "\013CommandInfo\022$\n\004uris\030\001 \003(\0132\026.mesos.Comma"
    "ndInfo.URI\022\'\n\013environment\030\002 \001(\0132\022.mesos."
    "Environment\022\023\n\005shell\030\006 \001(\010:\004true\022\r\n\005valu"
    "e\030\003 \001(\t\022\021\n\targuments\030\007 \003(\t\022\014\n\004user\030\005 \001(\t"
    "\032c\n\003URI\022\r\n\005value\030\001 \002(\t\022\022\n\nexecutable\030\002 \001"
    "(\010\022\025\n\007extract\030\003 \001(\010:\004true\022\r\n\005cache\030\004 \001(\010"
    "\022\023\n\013output_file\030\005 \001(\t\"\324\003\n\014ExecutorInfo\022&"
    "\n\004type\030\017 \001(\0162\030.mesos.ExecutorInfo.Type\022&"
    "\n\013executor_id\030\001 \002(\0132\021.mesos.ExecutorID\022("
    "\n\014framework_id\030\010 \001(\0132\022.mesos.FrameworkID"
    "\022#\n\007command\030\007 \001(\0132\022.mesos.CommandInfo\022\'\n"
    "\tcontainer\030\013 \001(\0132\024.mesos.ContainerInfo\022\""
    "\n\tresources\030\005 \003(\0132\017.mesos.Resource\022\014\n\004na"
    "me\030\t \001(\t\022\022\n\006source\030\n \001(\tB\002\030\001\022\014\n\004data\030\004 \001"
    "(\014\022\'\n\tdiscovery\030\014 \001(\0132\024.mesos.DiscoveryI"
    "nfo\0222\n\025shutdown_grace_period\030\r \001(\0132\023.mes"
    "os.DurationInfo\022\035\n\006labels\030\016 \001(\0132\r.mesos."
    "Labels\",\n\004Type\022\013\n\007UNKNOWN\020\000\022\013\n\007DEFAULT\020\001"
    "\022\n\n\006CUSTOM\020\002\"\211\001\n\nMasterInfo\022\n\n\002id\030\001 \002(\t\022"
    "\n\n\002ip\030\002 \002(\r\022\022\n\004port\030\003 \002(\r:\0045050\022\013\n\003pid\030\004"
    " \001(\t\022\020\n\010hostname\030\005 \001(\t\022\017\n\007version\030\006 \001(\t\022"
    "\037\n\007address\030\007 \001(\0132\016.mesos.Address\"\225\002\n\tSla"
    "veInfo\022\020\n\010hostname\030\001 \002(\t\022\022\n\004port\030\010 \001(\005:\004"
    "5051\022\"\n\tresources\030\003 \003(\0132\017.mesos.Resource"
    "\022$\n\nattributes\030\005 \003(\0132\020.mesos.Attribute\022\032"
    "\n\002id\030\006 \001(\0132\016.mesos.SlaveID\022\031\n\ncheckpoint"
    "\030\007 \001(\010:\005false\032a\n\nCapability\022.\n\004type\030\001 \001("
    "\0162 .mesos.SlaveInfo.Capability.Type\"#\n\004T"
    "ype\022\013\n\007UNKNOWN\020\000\022\016\n\nMULTI_ROLE\020\001\"\374\002\n\005Val"
    "ue\022\037\n\004type\030\001 \002(\0162\021.mesos.Value.Type\022#\n\006s"
    "calar\030\002 \001(\0132\023.mesos.Value.Scalar\022#\n\006rang"
    "es\030\003 \001(\0132\023.mesos.Value.Ranges\022\035\n\003set\030\004 \001"
    "(\0132\020.mesos.Value.Set\022\037\n\004text\030\005 \001(\0132\021.mes"
    "os.Value.Text\032\027\n\006Scalar\022\r\n\005value\030\001 \002(\001\032#"
    "\n\005Range\022\r\n\005begin\030\001 \002(\004\022\013\n\003end\030\002 \002(\004\032+\n\006R"
    "anges\022!\n\005range\030\001 \003(\0132\022.mesos.Value.Range"
    "\032\023\n\003Set\022\014\n\004item\030\001 \003(\t\032\025\n\004Text\022\r\n\005value\030\001"
    " \002(\t\"1\n\004Type\022\n\n\006SCALAR\020\000\022\n\n\006RANGES\020\001\022\007\n\003"
    "SET\020\002\022\010\n\004TEXT\020\003\"\304\001\n\tAttribute\022\014\n\004name\030\001 "
    "\002(\t\022\037\n\004type\030\002 \002(\0162\021.mesos.Value.Type\022#\n\006"
    "scalar\030\003 \001(\0132\023.mesos.Value.Scalar\022#\n\006ran"
    "ges\030\004 \001(\0132\023.mesos.Value.Ranges\022\035\n\003set\030\006 "
    "\001(\0132\020.mesos.Value.Set\022\037\n\004text\030\005 \001(\0132\021.me"
    "sos.Value.Text\"\345\007\n\010Resource\022\014\n\004name\030\001 \002("
    "\t\022\037\n\004type\030\002 \002(\0162\021.mesos.Value.Type\022#\n\006sc"
    "alar\030\003 \001(\0132\023.mesos.Value.Scalar\022#\n\006range"
    "s\030\004 \001(\0132\023.mesos.Value.Ranges\022\035\n\003set\030\005 \001("
    "\0132\020.mesos.Value.Set\022\017\n\004role\030\006 \001(\t:\001*\0227\n\017"
    "allocation_info\030\013 \001(\0132\036.mesos.Resource.A"
    "llocationInfo\0224\n\013reservation\030\010 \001(\0132\037.mes"
    "os.Resource.ReservationInfo\022&\n\004disk\030\007 \001("
    "\0132\030.mesos.Resource.DiskInfo\0220\n\trevocable"
    "\030\t \001(\0132\035.mesos.Resource.RevocableInfo\022*\n"
    "\006shared\030\n \001(\0132\032.mesos.Resource.SharedInf"
    "o\032\036\n\016AllocationInfo\022\014\n\004role\030\001 \001(\t\032C\n\017Res"
    "ervationInfo\022\021\n\tprincipal\030\001 \001(\t\022\035\n\006label"
    "s\030\002 \001(\0132\r.mesos.Labels\032\266\003\n\010DiskInfo\0229\n\013p"
    "ersistence\030\001 \001(\0132$.mesos.Resource.DiskIn"
    "fo.Persistence\022\035\n\006volume\030\002 \001(\0132\r.mesos.V"
    "olume\022/\n\006source\030\003 \001(\0132\037.mesos.Resource.D"
    "iskInfo.Source\032,\n\013Persistence\022\n\n\002id\030\001 \002("
    "\t\022\021\n\tprincipal\030\002 \001(\t\032\360\001\n\006Source\0222\n\004type\030"
    "\001 \002(\0162$.mesos.Resource.DiskInfo.Source.T"
    "ype\0222\n\004path\030\002 \001(\0132$.mesos.Resource.DiskI"
    "nfo.Source.Path\0224\n\005mount\030\003 \001(\0132%.mesos.R"
    "esource.DiskInfo.Source.Mount\032\024\n\004Path\022\014\n"
    "\004root\030\001 \002(\t\032\025\n\005Mount\022\014\n\004root\030\001 \002(\t\"\033\n\004Ty"
    "pe\022\010\n\004PATH\020\001\022\t\n\005MOUNT\020\002\032\017\n\rRevocableInfo"
    "\032\014\n\nSharedInfo\"\274\001\n\030TrafficControlStatist"
    "ics\022\n\n\002id\030\001 \002(\t\022\017\n\007backlog\030\002 \001(\004\022\r\n\005byte"
    "s\030\003 \001(\004\022\r\n\005drops\030\004 \001(\004\022\022\n\noverlimits\030\005 \001"
    "(\004\022\017\n\007packets\030\006 \001(\004\022\014\n\004qlen\030\007 \001(\004\022\017\n\007rat"
    "ebps\030\010 \001(\004\022\017\n\007ratepps\030\t \001(\004\022\020\n\010requeues\030"
    "\n \001(\004\"\225\003\n\014IpStatistics\022\022\n\nForwarding\030\001 \001"
    "(\003\022\022\n\nDefaultTTL\030\002 \001(\003\022\022\n\nInReceives\030\003 \001"
    "(\003\022\023\n\013InHdrErrors\030\004 \001(\003\022\024\n\014InAddrErrors\030"
    "\005 \001(\003\022\025\n\rForwDatagrams\030\006 \001(\003\022\027\n\017InUnknow"
    "nProtos\030\007 \001(\003\022\022\n\nInDiscards\030\010 \001(\003\022\022\n\nInD"
    "elivers\030\t \001(\003\022\023\n\013OutRequests\030\n \001(\003\022\023\n\013Ou"
    "tDiscards\030\013 \001(\003\022\023\n\013OutNoRoutes\030\014 \001(\003\022\024\n\014"
    "ReasmTimeout\030\r \001(\003\022\022\n\nReasmReqds\030\016 \001(\003\022\020"
    "\n\010ReasmOKs\030\017 \001(\003\022\022\n\nReasmFails\030\020 \001(\003\022\017\n\007"
    "FragOKs\030\021 \001(\003\022\021\n\tFragFails\030\022 \001(\003\022\023\n\013Frag"
    "Creates\030\023 \001(\003\"\323\004\n\016IcmpStatistics\022\016\n\006InMs"
    "gs\030\001 \001(\003\022\020\n\010InErrors\030\002 \001(\003\022\024\n\014InCsumErro"
    "rs\030\003 \001(\003\022\026\n\016InDestUnreachs\030\004 \001(\003\022\023\n\013InTi"
    "meExcds\030\005 \001(\003\022\023\n\013InParmProbs\030\006 \001(\003\022\024\n\014In"
    "SrcQuenchs\030\007 \001(\003\022\023\n\013InRedirects\030\010 \001(\003\022\017\n"
    "\007InEchos\030\t \001(\003\022\022\n\nInEchoReps\030\n \001(\003\022\024\n\014In"
    "Timestamps\030\013 \001(\003\022\027\n\017InTimestampReps\030\014 \001("
    "\003\022\023\n\013InAddrMasks\030\r \001(\003\022\026\n\016InAddrMaskReps"
    "\030\016 \001(\003\022\017\n\007OutMsgs\030\017 \001(\003\022\021\n\tOutErrors\030\020 \001"
    "(\003\022\027\n\017OutDestUnreachs\030\021 \001(\003\022\024\n\014OutTimeEx"
    "cds\030\022 \001(\003\022\024\n\014OutParmProbs\030\023 \001(\003\022\025\n\rOutSr"
    "cQuenchs\030\024 \001(\003\022\024\n\014OutRedirects\030\025 \001(\003\022\020\n\010"
    "OutEchos\030\026 \001(\003\022\023\n\013OutEchoReps\030\027 \001(\003\022\025\n\rO"
    "utTimestamps\030\030 \001(\003\022\030\n\020OutTimestampReps\030\031"
    " \001(\003\022\024\n\014OutAddrMasks\030\032 \001(\003\022\027\n\017OutAddrMas"
    "kReps\030\033 \001(\003\"\254\002\n\rTcpStatistics\022\024\n\014RtoAlgo"
    "rithm\030\001 \001(\003\022\016\n\006RtoMin\030\002 \001(\003\022\016\n\006RtoMax\030\003 "
    "\001(\003\022\017\n\007MaxConn\030\004 \001(\003\022\023\n\013ActiveOpens\030\005 \001("
    "\003\022\024\n\014PassiveOpens\030\006 \001(\003\022\024\n\014AttemptFails\030"
    "\007 \001(\003\022\023\n\013EstabResets\030\010 \001(\003\022\021\n\tCurrEstab\030"
    "\t \001(\003\022\016\n\006InSegs\030\n \001(\003\022\017\n\007OutSegs\030\013 \001(\003\022\023"
    "\n\013RetransSegs\030\014 \001(\003\022\016\n\006InErrs\030\r \001(\003\022\017\n\007O"
    "utRsts\030\016 \001(\003\022\024\n\014InCsumErrors\030\017 \001(\003\"\265\001\n\rU"
    "dpStatistics\022\023\n\013InDatagrams\030\001 \001(\003\022\017\n\007NoP"
    "orts\030\002 \001(\003\022\020\n\010InErrors\030\003 \001(\003\022\024\n\014OutDatag"
    "rams\030\004 \001(\003\022\024\n\014RcvbufErrors\030\005 \001(\003\022\024\n\014Sndb"
    "ufErrors\030\006 \001(\003\022\024\n\014InCsumErrors\030\007 \001(\003\022\024\n\014"
    "IgnoredMulti\030\010 \001(\003\"\264\001\n\016SNMPStatistics\022%\n"
    "\010ip_stats\030\001 \001(\0132\023.mesos.IpStatistics\022)\n\n"
    "icmp_stats\030\002 \001(\0132\025.mesos.IcmpStatistics\022"
    "\'\n\ttcp_stats\030\003 \001(\0132\024.mesos.TcpStatistics"
    "\022\'\n\tudp_stats\030\004 \001(\0132\024.mesos.UdpStatistic"
    "s\"\352\t\n\022ResourceStatistics\022\021\n\ttimestamp\030\001 "
    "\002(\001\022\021\n\tprocesses\030\036 \001(\r\022\017\n\007threads\030\037 \001(\r\022"
    "\033\n\023cpus_user_time_secs\030\002 \001(\001\022\035\n\025cpus_sys"
    "tem_time_secs\030\003 \001(\001\022\022\n\ncpus_limit\030\004 \001(\001\022"
    "\027\n\017cpus_nr_periods\030\007 \001(\r\022\031\n\021cpus_nr_thro"
    "ttled\030\010 \001(\r\022 \n\030cpus_throttled_time_secs\030"
    "\t \001(\001\022\027\n\017mem_total_bytes\030$ \001(\004\022\035\n\025mem_to"
    "tal_memsw_bytes\030% \001(\004\022\027\n\017mem_limit_bytes"
    "\030\006 \001(\004\022\034\n\024mem_soft_limit_bytes\030& \001(\004\022\026\n\016"
    "mem_file_bytes\030\n \001(\004\022\026\n\016mem_anon_bytes\030\013"
    " \001(\004\022\027\n\017mem_cache_bytes\030\' \001(\004\022\025\n\rmem_rss"
    "_bytes\030\005 \001(\004\022\035\n\025mem_mapped_file_bytes\030\014 "
    "\001(\004\022\026\n\016mem_swap_bytes\030( \001(\004\022\035\n\025mem_unevi"
    "ctable_bytes\030) \001(\004\022 \n\030mem_low_pressure_c"
    "ounter\030  \001(\004\022#\n\033mem_medium_pressure_coun"
    "ter\030! \001(\004\022%\n\035mem_critical_pressure_count"
    "er\030\" \001(\004\022\030\n\020disk_limit_bytes\030\032 \001(\004\022\027\n\017di"
    "sk_used_bytes\030\033 \001(\004\022#\n\004perf\030\r \001(\0132\025.meso"
    "s.PerfStatistics\022\026\n\016net_rx_packets\030\016 \001(\004"
    "\022\024\n\014net_rx_bytes\030\017 \001(\004\022\025\n\rnet_rx_errors\030"
    "\020 \001(\004\022\026\n\016net_rx_dropped\030\021 \001(\004\022\026\n\016net_tx_"
    "packets\030\022 \001(\004\022\024\n\014net_tx_bytes\030\023 \001(\004\022\025\n\rn"
    "et_tx_errors\030\024 \001(\004\022\026\n\016net_tx_dropped\030\025 \001"
    "(\004\022!\n\031net_tcp_rtt_microsecs_p50\030\026 \001(\001\022!\n"
    "\031net_tcp_rtt_microsecs_p90\030\027 \001(\001\022!\n\031net_"
    "tcp_rtt_microsecs_p95\030\030 \001(\001\022!\n\031net_tcp_r"
    "tt_microsecs_p99\030\031 \001(\001\022\"\n\032net_tcp_active"
    "_connections\030\034 \001(\001\022%\n\035net_tcp_time_wait_"
    "connections\030\035 \001(\001\022G\n\036net_traffic_control"
    "_statistics\030# \003(\0132\037.mesos.TrafficControl"
    "Statistics\0222\n\023net_snmp_statistics\030* \001(\0132"
    "\025.mesos.SNMPStatistics\"\276\003\n\rResourceUsage"
    "\0220\n\texecutors\030\001 \003(\0132\035.mesos.ResourceUsag"
    "e.Executor\022\036\n\005total\030\002 \003(\0132\017.mesos.Resour"
    "ce\032\332\002\n\010Executor\022*\n\rexecutor_info\030\001 \002(\0132\023"
    ".mesos.ExecutorInfo\022\"\n\tallocated\030\002 \003(\0132\017"
    ".mesos.Resource\022-\n\nstatistics\030\003 \001(\0132\031.me"
    "sos.ResourceStatistics\022(\n\014container_id\030\004"
    " \002(\0132\022.mesos.ContainerID\0221\n\005tasks\030\005 \003(\0132"
    "\".mesos.ResourceUsage.Executor.Task\032r\n\004T"
    "ask\022\014\n\004name\030\001 \002(\t\022\031\n\002id\030\002 \002(\0132\r.mesos.Ta"
    "skID\022\"\n\tresources\030\003 \003(\0132\017.mesos.Resource"
    "\022\035\n\006labels\030\004 \001(\0132\r.mesos.Labels\"\260\n\n\016Perf"
    "Statistics\022\021\n\ttimestamp\030\001 \002(\001\022\020\n\010duratio"
    "n\030\002 \002(\001\022\016\n\006cycles\030\003 \001(\004\022\037\n\027stalled_cycle"
    "s_frontend\030\004 \001(\004\022\036\n\026stalled_cycles_backe"
    "nd\030\005 \001(\004\022\024\n\014instructions\030\006 \001(\004\022\030\n\020cache_"
    "references\030\007 \001(\004\022\024\n\014cache_misses\030\010 \001(\004\022\020"
    "\n\010branches\030\t \001(\004\022\025\n\rbranch_misses\030\n \001(\004\022"
    "\022\n\nbus_cycles\030\013 \001(\004\022\022\n\nref_cycles\030\014 \001(\004\022"
    "\021\n\tcpu_clock\030\r \001(\001\022\022\n\ntask_clock\030\016 \001(\001\022\023"
    "\n\013page_faults\030\017 \001(\004\022\024\n\014minor_faults\030\020 \001("
    "\004\022\024\n\014major_faults\030\021 \001(\004\022\030\n\020context_switc"
    "hes\030\022 \001(\004\022\026\n\016cpu_migrations\030\023 \001(\004\022\030\n\020ali"
    "gnment_faults\030\024 \001(\004\022\030\n\020emulation_faults\030"
    "\025 \001(\004\022\027\n\017l1_dcache_loads\030\026 \001(\004\022\035\n\025l1_dca"
    "che_load_misses\030\027 \001(\004\022\030\n\020l1_dcache_store"
    "s\030\030 \001(\004\022\036\n\026l1_dcache_store_misses\030\031 \001(\004\022"
    "\034\n\024l1_dcache_prefetches\030\032 \001(\004\022!\n\031l1_dcac"
    "he_prefetch_misses\030\033 \001(\004\022\027\n\017l1_icache_lo"
    "ads\030\034 \001(\004\022\035\n\025l1_icache_load_misses\030\035 \001(\004"
    "\022\034\n\024l1_icache_prefetches\030\036 \001(\004\022!\n\031l1_ica"
    "che_prefetch_misses\030\037 \001(\004\022\021\n\tllc_loads\030 "
    " \001(\004\022\027\n\017llc_load_misses\030! \001(\004\022\022\n\nllc_sto"
    "res\030\" \001(\004\022\030\n\020llc_store_misses\030# \001(\004\022\026\n\016l"
    "lc_prefetches\030$ \001(\004\022\033\n\023llc_prefetch_miss"
    "es\030% \001(\004\022\022\n\ndtlb_loads\030& \001(\004\022\030\n\020dtlb_loa"
    "d_misses\030\' \001(\004\022\023\n\013dtlb_stores\030( \001(\004\022\031\n\021d"
    "tlb_store_misses\030) \001(\004\022\027\n\017dtlb_prefetche"
    "s\030* \001(\004\022\034\n\024dtlb_prefetch_misses\030+ \001(\004\022\022\n"
    "\nitlb_loads\030, \001(\004\022\030\n\020itlb_load_misses\030- "
    "\001(\004\022\024\n\014branch_loads\030. \001(\004\022\032\n\022branch_load"
    "_misses\030/ \001(\004\022\022\n\nnode_loads\0300 \001(\004\022\030\n\020nod"
    "e_load_misses\0301 \001(\004\022\023\n\013node_stores\0302 \001(\004"
    "\022\031\n\021node_store_misses\0303 \001(\004\022\027\n\017node_pref"
    "etches\0304 \001(\004\022\034\n\024node_prefetch_misses\0305 \001"
    "(\004\"O\n\007Request\022 \n\010slave_id\030\001 \001(\0132\016.mesos."
    "SlaveID\022\"\n\tresources\030\002 \003(\0132\017.mesos.Resou"
    "rce\"\215\t\n\005Offer\022\032\n\002id\030\001 \002(\0132\016.mesos.OfferI"
    "D\022(\n\014framework_id\030\002 \002(\0132\022.mesos.Framewor"
    "kID\022 \n\010slave_id\030\003 \002(\0132\016.mesos.SlaveID\022\020\n"
    "\010hostname\030\004 \002(\t\022\027\n\003url\030\010 \001(\0132\n.mesos.URL"
    "\022\"\n\tresources\030\005 \003(\0132\017.mesos.Resource\022$\n\n"
    "attributes\030\007 \003(\0132\020.mesos.Attribute\022\'\n\014ex"
    "ecutor_ids\030\006 \003(\0132\021.mesos.ExecutorID\022-\n\016u"
    "navailability\030\t \001(\0132\025.mesos.Unavailabili"
    "ty\0227\n\017allocation_info\030\n \001(\0132\036.mesos.Reso"
    "urce.AllocationInfo\032\225\006\n\tOperation\022)\n\004typ"
    "e\030\001 \001(\0162\033.mesos.Offer.Operation.Type\022-\n\006"
    "launch\030\002 \001(\0132\035.mesos.Offer.Operation.Lau"
    "nch\0228\n\014launch_group\030\007 \001(\0132\".mesos.Offer."
    "Operation.LaunchGroup\022/\n\007reserve\030\003 \001(\0132\036"
    ".mesos.Offer.Operation.Reserve\0223\n\tunrese"
    "rve\030\004 \001(\0132 .mesos.Offer.Operation.Unrese"
    "rve\022-\n\006create\030\005 \001(\0132\035.mesos.Offer.Operat"
    "ion.Create\022/\n\007destroy\030\006 \001(\0132\036.mesos.Offe"
    "r.Operation.Destroy\032-\n\006Launch\022#\n\ntask_in"
    "fos\030\001 \003(\0132\017.mesos.TaskInfo\032^\n\013LaunchGrou"
    "p\022%\n\010executor\030\001 \002(\0132\023.mesos.ExecutorInfo"
    "\022(\n\ntask_group\030\002 \002(\0132\024.mesos.TaskGroupIn"
    "fo\032-\n\007Reserve\022\"\n\tresources\030\001 \003(\0132\017.mesos"
    ".Resource\032/\n\tUnreserve\022\"\n\tresources\030\001 \003("
    "\0132\017.mesos.Resource\032*\n\006Create\022 \n\007volumes\030"
    "\001 \003(\0132\017.mesos.Resource\032+\n\007Destroy\022 \n\007vol"
    "umes\030\001 \003(\0132\017.mesos.Resource\"f\n\004Type\022\013\n\007U"
    "NKNOWN\020\000\022\n\n\006LAUNCH\020\001\022\020\n\014LAUNCH_GROUP\020\006\022\013"
    "\n\007RESERVE\020\002\022\r\n\tUNRESERVE\020\003\022\n\n\006CREATE\020\004\022\013"
    "\n\007DESTROY\020\005\"\342\001\n\014InverseOffer\022\032\n\002id\030\001 \002(\013"
    "2\016.mesos.OfferID\022\027\n\003url\030\002 \001(\0132\n.mesos.UR"
    "L\022(\n\014framework_id\030\003 \002(\0132\022.mesos.Framewor"
    "kID\022 \n\010slave_id\030\004 \001(\0132\016.mesos.SlaveID\022-\n"
    "\016unavailability\030\005 \002(\0132\025.mesos.Unavailabi"
    "lity\022\"\n\tresources\030\006 \003(\0132\017.mesos.Resource"
    "\"\274\003\n\010TaskInfo\022\014\n\004name\030\001 \002(\t\022\036\n\007task_id\030\002"
    " \002(\0132\r.mesos.TaskID\022 \n\010slave_id\030\003 \002(\0132\016."
    "mesos.SlaveID\022\"\n\tresources\030\004 \003(\0132\017.mesos"
    ".Resource\022%\n\010executor\030\005 \001(\0132\023.mesos.Exec"
    "utorInfo\022#\n\007command\030\007 \001(\0132\022.mesos.Comman"
    "dInfo\022\'\n\tcontainer\030\t \001(\0132\024.mesos.Contain"
    "erInfo\022(\n\014health_check\030\010 \001(\0132\022.mesos.Hea"
    "lthCheck\022\037\n\005check\030\r \001(\0132\020.mesos.CheckInf"
    "o\022&\n\013kill_policy\030\014 \001(\0132\021.mesos.KillPolic"
    "y\022\014\n\004data\030\006 \001(\014\022\035\n\006labels\030\n \001(\0132\r.mesos."
    "Labels\022\'\n\tdiscovery\030\013 \001(\0132\024.mesos.Discov"
    "eryInfo\"/\n\rTaskGroupInfo\022\036\n\005tasks\030\001 \003(\0132"
    "\017.mesos.TaskInfo\"\334\003\n\004Task\022\014\n\004name\030\001 \002(\t\022"
    "\036\n\007task_id\030\002 \002(\0132\r.mesos.TaskID\022(\n\014frame"
    "work_id\030\003 \002(\0132\022.mesos.FrameworkID\022&\n\013exe"
    "cutor_id\030\004 \001(\0132\021.mesos.ExecutorID\022 \n\010sla"
    "ve_id\030\005 \002(\0132\016.mesos.SlaveID\022\037\n\005state\030\006 \002"
    "(\0162\020.mesos.TaskState\022\"\n\tresources\030\007 \003(\0132"
    "\017.mesos.Resource\022#\n\010statuses\030\010 \003(\0132\021.mes"
    "os.TaskStatus\022-\n\023status_update_state\030\t \001"
    "(\0162\020.mesos.TaskState\022\032\n\022status_update_uu"
    "id\030\n \001(\014\022\035\n\006labels\030\013 \001(\0132\r.mesos.Labels\022"
    "\'\n\tdiscovery\030\014 \001(\0132\024.mesos.DiscoveryInfo"
    "\022\'\n\tcontainer\030\r \001(\0132\024.mesos.ContainerInf"
    "o\022\014\n\004user\030\016 \001(\t\"\315\001\n\017CheckStatusInfo\022#\n\004t"
    "ype\030\001 \001(\0162\025.mesos.CheckInfo.Type\022/\n\007comm"
    "and\030\002 \001(\0132\036.mesos.CheckStatusInfo.Comman"
    "d\022)\n\004http\030\003 \001(\0132\033.mesos.CheckStatusInfo."
    "Http\032\034\n\007Command\022\021\n\texit_code\030\001 \001(\005\032\033\n\004Ht"
    "tp\022\023\n\013status_code\030\001 \001(\r\"\331\013\n\nTaskStatus\022\036"
    "\n\007task_id\030\001 \002(\0132\r.mesos.TaskID\022\037\n\005state\030"
    "\002 \002(\0162\020.mesos.TaskState\022\017\n\007message\030\004 \001(\t"
    "\022(\n\006source\030\t \001(\0162\030.mesos.TaskStatus.Sour"
    "ce\022(\n\006reason\030\n \001(\0162\030.mesos.TaskStatus.Re"
    "ason\022\014\n\004data\030\003 \001(\014\022 \n\010slave_id\030\005 \001(\0132\016.m"
    "esos.SlaveID\022&\n\013executor_id\030\007 \001(\0132\021.meso"
    "s.ExecutorID\022\021\n\ttimestamp\030\006 \001(\001\022\014\n\004uuid\030"
    "\013 \001(\014\022\017\n\007healthy\030\010 \001(\010\022,\n\014check_status\030\017"
    " \001(\0132\026.mesos.CheckStatusInfo\022\035\n\006labels\030\014"
    " \001(\0132\r.mesos.Labels\0220\n\020container_status\030"
    "\r \001(\0132\026.mesos.ContainerStatus\022)\n\020unreach"
    "able_time\030\016 \001(\0132\017.mesos.TimeInfo\"B\n\006Sour"
    "ce\022\021\n\rSOURCE_MASTER\020\000\022\020\n\014SOURCE_SLAVE\020\001\022"
    "\023\n\017SOURCE_EXECUTOR\020\002\"\254\007\n\006Reason\022\"\n\036REASO"
    "N_COMMAND_EXECUTOR_FAILED\020\000\022\"\n\036REASON_CO"
    "NTAINER_LAUNCH_FAILED\020\025\022\037\n\033REASON_CONTAI"
    "NER_LIMITATION\020\023\022$\n REASON_CONTAINER_LIM"
    "ITATION_DISK\020\024\022&\n\"REASON_CONTAINER_LIMIT"
    "ATION_MEMORY\020\010\022\036\n\032REASON_CONTAINER_PREEM"
    "PTED\020\021\022\"\n\036REASON_CONTAINER_UPDATE_FAILED"
    "\020\026\022(\n$REASON_EXECUTOR_REGISTRATION_TIMEO"
    "UT\020\027\022*\n&REASON_EXECUTOR_REREGISTRATION_T"
    "IMEOUT\020\030\022\036\n\032REASON_EXECUTOR_TERMINATED\020\001"
    "\022 \n\034REASON_EXECUTOR_UNREGISTERED\020\002\022\034\n\030RE"
    "ASON_FRAMEWORK_REMOVED\020\003\022\023\n\017REASON_GC_ER"
    "ROR\020\004\022\036\n\032REASON_INVALID_FRAMEWORKID\020\005\022\031\n"
    "\025REASON_INVALID_OFFERS\020\006\022 \n\034REASON_IO_SW"
    "ITCHBOARD_EXITED\020\033\022\036\n\032REASON_MASTER_DISC"
    "ONNECTED\020\007\022\031\n\025REASON_RECONCILIATION\020\t\022\034\n"
    "\030REASON_RESOURCES_UNKNOWN\020\022\022\035\n\031REASON_SL"
    "AVE_DISCONNECTED\020\n\022\030\n\024REASON_SLAVE_REMOV"
    "ED\020\013\022\032\n\026REASON_SLAVE_RESTARTED\020\014\022\030\n\024REAS"
    "ON_SLAVE_UNKNOWN\020\r\022$\n REASON_TASK_CHECK_"
    "STATUS_UPDATED\020\034\022\035\n\031REASON_TASK_GROUP_IN"
    "VALID\020\031\022\"\n\036REASON_TASK_GROUP_UNAUTHORIZE"
    "D\020\032\022\027\n\023REASON_TASK_INVALID\020\016\022\034\n\030REASON_T"
    "ASK_UNAUTHORIZED\020\017\022\027\n\023REASON_TASK_UNKNOW"
    "N\020\020\"$\n\007Filters\022\031\n\016refuse_seconds\030\001 \001(\001:\001"
    "5\"\351\001\n\013Environment\022.\n\tvariables\030\001 \003(\0132\033.m"
    "esos.Environment.Variable\032\251\001\n\010Variable\022\014"
    "\n\004name\030\001 \002(\t\0225\n\004type\030\003 \001(\0162 .mesos.Envir"
    "onment.Variable.Type:\005VALUE\022\r\n\005value\030\002 \001"
    "(\t\022\035\n\006secret\030\004 \001(\0132\r.mesos.Secret\"*\n\004Typ"
    "e\022\013\n\007UNKNOWN\020\000\022\t\n\005VALUE\020\001\022\n\n\006SECRET\020\002\"\'\n"
    "\tParameter\022\013\n\003key\030\001 \002(\t\022\r\n\005value\030\002 \002(\t\"1"
    "\n\nParameters\022#\n\tparameter\030\001 \003(\0132\020.mesos."
    "Parameter\"/\n\nCredential\022\021\n\tprincipal\030\001 \002"
    "(\t\022\016\n\006secret\030\002 \001(\t\"5\n\013Credentials\022&\n\013cre"
    "dentials\030\001 \003(\0132\021.mesos.Credential\"\350\001\n\006Se"
    "cret\022 \n\004type\030\001 \001(\0162\022.mesos.Secret.Type\022*"
    "\n\treference\030\002 \001(\0132\027.mesos.Secret.Referen"
    "ce\022\"\n\005value\030\003 \001(\0132\023.mesos.Secret.Value\032&"
    "\n\tReference\022\014\n\004name\030\001 \002(\t\022\013\n\003key\030\002 \001(\t\032\025"
    "\n\005Value\022\014\n\004data\030\001 \002(\014\"-\n\004Type\022\013\n\007UNKNOWN"
    "\020\000\022\r\n\tREFERENCE\020\001\022\t\n\005VALUE\020\002\"=\n\tRateLimi"
    "t\022\013\n\003qps\030\001 \001(\001\022\021\n\tprincipal\030\002 \002(\t\022\020\n\010cap"
    "acity\030\003 \001(\004\"q\n\nRateLimits\022 \n\006limits\030\001 \003("
    "\0132\020.mesos.RateLimit\022\035\n\025aggregate_default"
    "_qps\030\002 \001(\001\022\"\n\032aggregate_default_capacity"
    "\030\003 \001(\004\"\242\002\n\005Image\022\037\n\004type\030\001 \002(\0162\021.mesos.I"
    "mage.Type\022\037\n\004appc\030\002 \001(\0132\021.mesos.Image.Ap"
    "pc\022#\n\006docker\030\003 \001(\0132\023.mesos.Image.Docker\022"
    "\024\n\006cached\030\004 \001(\010:\004true\032\?\n\004Appc\022\014\n\004name\030\001 "
    "\002(\t\022\n\n\002id\030\002 \001(\t\022\035\n\006labels\030\003 \001(\0132\r.mesos."
    "Labels\032=\n\006Docker\022\014\n\004name\030\001 \002(\t\022%\n\ncreden"
    "tial\030\002 \001(\0132\021.mesos.Credential\"\034\n\004Type\022\010\n"
    "\004APPC\020\001\022\n\n\006DOCKER\020\002\"\346\004\n\006Volume\022 \n\004mode\030\003"
    " \002(\0162\022.mesos.Volume.Mode\022\026\n\016container_pa"
    "th\030\001 \002(\t\022\021\n\thost_path\030\002 \001(\t\022\033\n\005image\030\004 \001"
    "(\0132\014.mesos.Image\022$\n\006source\030\005 \001(\0132\024.mesos"
    ".Volume.Source\032\263\003\n\006Source\022\'\n\004type\030\001 \001(\0162"
    "\031.mesos.Volume.Source.Type\0228\n\rdocker_vol"
    "ume\030\002 \001(\0132!.mesos.Volume.Source.DockerVo"
    "lume\0226\n\014sandbox_path\030\003 \001(\0132 .mesos.Volum"
    "e.Source.SandboxPath\032W\n\014DockerVolume\022\016\n\006"
    "driver\030\001 \001(\t\022\014\n\004name\030\002 \002(\t\022)\n\016driver_opt"
    "ions\030\003 \001(\0132\021.mesos.Parameters\032{\n\013Sandbox"
    "Path\0223\n\004type\030\001 \001(\0162%.mesos.Volume.Source"
    ".SandboxPath.Type\022\014\n\004path\030\002 \002(\t\")\n\004Type\022"
    "\013\n\007UNKNOWN\020\000\022\010\n\004SELF\020\001\022\n\n\006PARENT\020\002\"8\n\004Ty"
    "pe\022\013\n\007UNKNOWN\020\000\022\021\n\rDOCKER_VOLUME\020\001\022\020\n\014SA"
    "NDBOX_PATH\020\002\"\026\n\004Mode\022\006\n\002RW\020\001\022\006\n\002RO\020\002\"\361\002\n"
    "\013NetworkInfo\0222\n\014ip_addresses\030\005 \003(\0132\034.mes"
    "os.NetworkInfo.IPAddress\022\014\n\004name\030\006 \001(\t\022\016"
    "\n\006groups\030\003 \003(\t\022\035\n\006labels\030\004 \001(\0132\r.mesos.L"
    "abels\0225\n\rport_mappings\030\007 \003(\0132\036.mesos.Net"
    "workInfo.PortMapping\032N\n\tIPAddress\022-\n\010pro"
    "tocol\030\001 \001(\0162\033.mesos.NetworkInfo.Protocol"
    "\022\022\n\nip_address\030\002 \001(\t\032J\n\013PortMapping\022\021\n\th"
    "ost_port\030\001 \002(\r\022\026\n\016container_port\030\002 \002(\r\022\020"
    "\n\010protocol\030\003 \001(\t\"\036\n\010Protocol\022\010\n\004IPv4\020\001\022\010"
    "\n\004IPv6\020\002\"\316\005\n\016CapabilityInfo\0226\n\014capabilit"
    "ies\030\001 \003(\0162 .mesos.CapabilityInfo.Capabil"
    "ity\"\203\005\n\nCapability\022\013\n\007UNKNOWN\020\000\022\n\n\005CHOWN"
    "\020\350\007\022\021\n\014DAC_OVERRIDE\020\351\007\022\024\n\017DAC_READ_SEARC"
    "H\020\352\007\022\013\n\006FOWNER\020\353\007\022\013\n\006FSETID\020\354\007\022\t\n\004KILL\020\355"
    "\007\022\013\n\006SETGID\020\356\007\022\013\n\006SETUID\020\357\007\022\014\n\007SETPCAP\020\360"
    "\007\022\024\n\017LINUX_IMMUTABLE\020\361\007\022\025\n\020NET_BIND_SERV"
    "ICE\020\362\007\022\022\n\rNET_BROADCAST\020\363\007\022\016\n\tNET_ADMIN\020"
    "\364\007\022\014\n\007NET_RAW\020\365\007\022\r\n\010IPC_LOCK\020\366\007\022\016\n\tIPC_O"
    "WNER\020\367\007\022\017\n\nSYS_MODULE\020\370\007\022\016\n\tSYS_RAWIO\020\371\007"
    "\022\017\n\nSYS_CHROOT\020\372\007\022\017\n\nSYS_PTRACE\020\373\007\022\016\n\tSY"
    "S_PACCT\020\374\007\022\016\n\tSYS_ADMIN\020\375\007\022\r\n\010SYS_BOOT\020\376"
    "\007\022\r\n\010SYS_NICE\020\377\007\022\021\n\014SYS_RESOURCE\020\200\010\022\r\n\010S"
    "YS_TIME\020\201\010\022\023\n\016SYS_TTY_CONFIG\020\202\010\022\n\n\005MKNOD"
    "\020\203\010\022\n\n\005LEASE\020\204\010\022\020\n\013AUDIT_WRITE\020\205\010\022\022\n\rAUD"
    "IT_CONTROL\020\206\010\022\014\n\007SETFCAP\020\207\010\022\021\n\014MAC_OVERR"
    "IDE\020\210\010\022\016\n\tMAC_ADMIN\020\211\010\022\013\n\006SYSLOG\020\212\010\022\017\n\nW"
    "AKE_ALARM\020\213\010\022\022\n\rBLOCK_SUSPEND\020\214\010\022\017\n\nAUDI"
    "T_READ\020\215\010\";\n\tLinuxInfo\022.\n\017capability_inf"
    "o\030\001 \001(\0132\025.mesos.CapabilityInfo\"\244\003\n\nRLimi"
    "tInfo\022)\n\007rlimits\030\001 \003(\0132\030.mesos.RLimitInf"
    "o.RLimit\032\352\002\n\006RLimit\022+\n\004type\030\001 \001(\0162\035.meso"
    "s.RLimitInfo.RLimit.Type\022\014\n\004hard\030\002 \001(\004\022\014"
    "\n\004soft\030\003 \001(\004\"\226\002\n\004Type\022\013\n\007UNKNOWN\020\000\022\013\n\007RL"
    "MT_AS\020\001\022\r\n\tRLMT_CORE\020\002\022\014\n\010RLMT_CPU\020\003\022\r\n\t"
    "RLMT_DATA\020\004\022\016\n\nRLMT_FSIZE\020\005\022\016\n\nRLMT_LOCK"
    "S\020\006\022\020\n\014RLMT_MEMLOCK\020\007\022\021\n\rRLMT_MSGQUEUE\020\010"
    "\022\r\n\tRLMT_NICE\020\t\022\017\n\013RLMT_NOFILE\020\n\022\016\n\nRLMT"
    "_NPROC\020\013\022\014\n\010RLMT_RSS\020\014\022\017\n\013RLMT_RTPRIO\020\r\022"
    "\017\n\013RLMT_RTTIME\020\016\022\023\n\017RLMT_SIGPENDING\020\017\022\016\n"
    "\nRLMT_STACK\020\020\"f\n\007TTYInfo\022.\n\013window_size\030"
    "\001 \001(\0132\031.mesos.TTYInfo.WindowSize\032+\n\nWind"
    "owSize\022\014\n\004rows\030\001 \002(\r\022\017\n\007columns\030\002 \002(\r\"\307\006"
    "\n\rContainerInfo\022\'\n\004type\030\001 \002(\0162\031.mesos.Co"
    "ntainerInfo.Type\022\036\n\007volumes\030\002 \003(\0132\r.meso"
    "s.Volume\022\020\n\010hostname\030\004 \001(\t\022/\n\006docker\030\003 \001"
    "(\0132\037.mesos.ContainerInfo.DockerInfo\022-\n\005m"
    "esos\030\005 \001(\0132\036.mesos.ContainerInfo.MesosIn"
    "fo\022)\n\rnetwork_infos\030\007 \003(\0132\022.mesos.Networ"
    "kInfo\022$\n\nlinux_info\030\010 \001(\0132\020.mesos.LinuxI"
    "nfo\022&\n\013rlimit_info\030\t \001(\0132\021.mesos.RLimitI"
    "nfo\022 \n\010tty_info\030\n \001(\0132\016.mesos.TTYInfo\032\226\003"
    "\n\nDockerInfo\022\r\n\005image\030\001 \002(\t\022>\n\007network\030\002"
    " \001(\0162\'.mesos.ContainerInfo.DockerInfo.Ne"
    "twork:\004HOST\022B\n\rport_mappings\030\003 \003(\0132+.mes"
    "os.ContainerInfo.DockerInfo.PortMapping\022"
    "\031\n\nprivileged\030\004 \001(\010:\005false\022$\n\nparameters"
    "\030\005 \003(\0132\020.mesos.Parameter\022\030\n\020force_pull_i"
    "mage\030\006 \001(\010\022\031\n\rvolume_driver\030\007 \001(\tB\002\030\001\032J\n"
    "\013PortMapping\022\021\n\thost_port\030\001 \002(\r\022\026\n\016conta"
    "iner_port\030\002 \002(\r\022\020\n\010protocol\030\003 \001(\t\"3\n\007Net"
    "work\022\010\n\004HOST\020\001\022\n\n\006BRIDGE\020\002\022\010\n\004NONE\020\003\022\010\n\004"
    "USER\020\004\032(\n\tMesosInfo\022\033\n\005image\030\001 \001(\0132\014.mes"
    "os.Image\"\035\n\004Type\022\n\n\006DOCKER\020\001\022\t\n\005MESOS\020\002\""
    "\244\001\n\017ContainerStatus\022(\n\014container_id\030\004 \001("
    "\0132\022.mesos.ContainerID\022)\n\rnetwork_infos\030\001"
    " \003(\0132\022.mesos.NetworkInfo\022&\n\013cgroup_info\030"
    "\002 \001(\0132\021.mesos.CgroupInfo\022\024\n\014executor_pid"
    "\030\003 \001(\r\"R\n\nCgroupInfo\022)\n\007net_cls\030\001 \001(\0132\030."
    "mesos.CgroupInfo.NetCls\032\031\n\006NetCls\022\017\n\007cla"
    "ssid\030\001 \001(\r\"&\n\006Labels\022\034\n\006labels\030\001 \003(\0132\014.m"
    "esos.Label\"#\n\005Label\022\013\n\003key\030\001 \002(\t\022\r\n\005valu"
    "e\030\002 \001(\t\"\212\001\n\004Port\022\016\n\006number\030\001 \002(\r\022\014\n\004name"
    "\030\002 \001(\t\022\020\n\010protocol\030\003 \001(\t\0223\n\nvisibility\030\004"
    " \001(\0162\037.mesos.DiscoveryInfo.Visibility\022\035\n"
    "\006labels\030\005 \001(\0132\r.mesos.Labels\"#\n\005Ports\022\032\n"
    "\005ports\030\001 \003(\0132\013.mesos.Port\"\376\001\n\rDiscoveryI"
    "nfo\0223\n\nvisibility\030\001 \002(\0162\037.mesos.Discover"
    "yInfo.Visibility\022\014\n\004name\030\002 \001(\t\022\023\n\013enviro"
    "nment\030\003 \001(\t\022\020\n\010location\030\004 \001(\t\022\017\n\007version"
    "\030\005 \001(\t\022\033\n\005ports\030\006 \001(\0132\014.mesos.Ports\022\035\n\006l"
    "abels\030\007 \001(\0132\r.mesos.Labels\"6\n\nVisibility"
    "\022\r\n\tFRAMEWORK\020\000\022\013\n\007CLUSTER\020\001\022\014\n\010EXTERNAL"
    "\020\002\"*\n\nWeightInfo\022\016\n\006weight\030\001 \002(\001\022\014\n\004role"
    "\030\002 \001(\t\"\220\001\n\013VersionInfo\022\017\n\007version\030\001 \002(\t\022"
    "\022\n\nbuild_date\030\002 \001(\t\022\022\n\nbuild_time\030\003 \001(\001\022"
    "\022\n\nbuild_user\030\004 \001(\t\022\017\n\007git_sha\030\005 \001(\t\022\022\n\n"
    "git_branch\030\006 \001(\t\022\017\n\007git_tag\030\007 \001(\t\"#\n\004Fla"
    "g\022\014\n\004name\030\001 \002(\t\022\r\n\005value\030\002 \001(\t\"p\n\004Role\022\014"
    "\n\004name\030\001 \002(\t\022\016\n\006weight\030\002 \002(\001\022&\n\nframewor"
    "ks\030\003 \003(\0132\022.mesos.FrameworkID\022\"\n\tresource"
    "s\030\004 \003(\0132\017.mesos.Resource\"%\n\006Metric\022\014\n\004na"
    "me\030\001 \002(\t\022\r\n\005value\030\002 \001(\001\"}\n\010FileInfo\022\014\n\004p"
    "ath\030\001 \002(\t\022\r\n\005nlink\030\002 \001(\005\022\014\n\004size\030\003 \001(\004\022\036"
    "\n\005mtime\030\004 \001(\0132\017.mesos.TimeInfo\022\014\n\004mode\030\005"
    " \001(\r\022\013\n\003uid\030\006 \001(\t\022\013\n\003gid\030\007 \001(\t*\\\n\006Status"
    "\022\026\n\022DRIVER_NOT_STARTED\020\001\022\022\n\016DRIVER_RUNNI"
    "NG\020\002\022\022\n\016DRIVER_ABORTED\020\003\022\022\n\016DRIVER_STOPP"
    "ED\020\004*\214\002\n\tTaskState\022\020\n\014TASK_STAGING\020\006\022\021\n\r"
    "TASK_STARTING\020\000\022\020\n\014TASK_RUNNING\020\001\022\020\n\014TAS"
    "K_KILLING\020\010\022\021\n\rTASK_FINISHED\020\002\022\017\n\013TASK_F"
    "AILED\020\003\022\017\n\013TASK_KILLED\020\004\022\016\n\nTASK_ERROR\020\007"
    "\022\r\n\tTASK_LOST\020\005\022\020\n\014TASK_DROPPED\020\t\022\024\n\020TAS"
    "K_UNREACHABLE\020\n\022\r\n\tTASK_GONE\020\013\022\031\n\025TASK_G"
    "ONE_BY_OPERATOR\020\014\022\020\n\014TASK_UNKNOWN\020\rB\032\n\020o"
    "rg.apache.mesosB\006Protos", 20063);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "mesos.proto", &protobuf_RegisterTypes);
  FrameworkID::default_instance_ = new FrameworkID();
  OfferID::default_instance_ = new OfferID();
  SlaveID::default_instance_ = new SlaveID();
  TaskID::default_instance_ = new TaskID();
  ExecutorID::default_instance_ = new ExecutorID();
  ContainerID::default_instance_ = new ContainerID();
  TimeInfo::default_instance_ = new TimeInfo();
  DurationInfo::default_instance_ = new DurationInfo();
  Address::default_instance_ = new Address();
  URL::default_instance_ = new URL();
  Unavailability::default_instance_ = new Unavailability();
  MachineID::default_instance_ = new MachineID();
  MachineInfo::default_instance_ = new MachineInfo();
  FrameworkInfo::_default_role_ =
      new ::std::string("*", 1);
  FrameworkInfo::default_instance_ = new FrameworkInfo();
  FrameworkInfo_Capability::default_instance_ = new FrameworkInfo_Capability();
  CheckInfo::default_instance_ = new CheckInfo();
  CheckInfo_Command::default_instance_ = new CheckInfo_Command();
  CheckInfo_Http::default_instance_ = new CheckInfo_Http();
  HealthCheck::default_instance_ = new HealthCheck();
  HealthCheck_HTTPCheckInfo::default_instance_ = new HealthCheck_HTTPCheckInfo();
  HealthCheck_TCPCheckInfo::default_instance_ = new HealthCheck_TCPCheckInfo();
  KillPolicy::default_instance_ = new KillPolicy();
  CommandInfo::default_instance_ = new CommandInfo();
  CommandInfo_URI::default_instance_ = new CommandInfo_URI();
  ExecutorInfo::default_instance_ = new ExecutorInfo();
  MasterInfo::default_instance_ = new MasterInfo();
  SlaveInfo::default_instance_ = new SlaveInfo();
  SlaveInfo_Capability::default_instance_ = new SlaveInfo_Capability();
  Value::default_instance_ = new Value();
  Value_Scalar::default_instance_ = new Value_Scalar();
  Value_Range::default_instance_ = new Value_Range();
  Value_Ranges::default_instance_ = new Value_Ranges();
  Value_Set::default_instance_ = new Value_Set();
  Value_Text::default_instance_ = new Value_Text();
  Attribute::default_instance_ = new Attribute();
  Resource::_default_role_ =
      new ::std::string("*", 1);
  Resource::default_instance_ = new Resource();
  Resource_AllocationInfo::default_instance_ = new Resource_AllocationInfo();
  Resource_ReservationInfo::default_instance_ = new Resource_ReservationInfo();
  Resource_DiskInfo::default_instance_ = new Resource_DiskInfo();
  Resource_DiskInfo_Persistence::default_instance_ = new Resource_DiskInfo_Persistence();
  Resource_DiskInfo_Source::default_instance_ = new Resource_DiskInfo_Source();
  Resource_DiskInfo_Source_Path::default_instance_ = new Resource_DiskInfo_Source_Path();
  Resource_DiskInfo_Source_Mount::default_instance_ = new Resource_DiskInfo_Source_Mount();
  Resource_RevocableInfo::default_instance_ = new Resource_RevocableInfo();
  Resource_SharedInfo::default_instance_ = new Resource_SharedInfo();
  TrafficControlStatistics::default_instance_ = new TrafficControlStatistics();
  IpStatistics::default_instance_ = new IpStatistics();
  IcmpStatistics::default_instance_ = new IcmpStatistics();
  TcpStatistics::default_instance_ = new TcpStatistics();
  UdpStatistics::default_instance_ = new UdpStatistics();
  SNMPStatistics::default_instance_ = new SNMPStatistics();
  ResourceStatistics::default_instance_ = new ResourceStatistics();
  ResourceUsage::default_instance_ = new ResourceUsage();
  ResourceUsage_Executor::default_instance_ = new ResourceUsage_Executor();
  ResourceUsage_Executor_Task::default_instance_ = new ResourceUsage_Executor_Task();
  PerfStatistics::default_instance_ = new PerfStatistics();
  Request::default_instance_ = new Request();
  Offer::default_instance_ = new Offer();
  Offer_Operation::default_instance_ = new Offer_Operation();
  Offer_Operation_Launch::default_instance_ = new Offer_Operation_Launch();
  Offer_Operation_LaunchGroup::default_instance_ = new Offer_Operation_LaunchGroup();
  Offer_Operation_Reserve::default_instance_ = new Offer_Operation_Reserve();
  Offer_Operation_Unreserve::default_instance_ = new Offer_Operation_Unreserve();
  Offer_Operation_Create::default_instance_ = new Offer_Operation_Create();
  Offer_Operation_Destroy::default_instance_ = new Offer_Operation_Destroy();
  InverseOffer::default_instance_ = new InverseOffer();
  TaskInfo::default_instance_ = new TaskInfo();
  TaskGroupInfo::default_instance_ = new TaskGroupInfo();
  Task::default_instance_ = new Task();
  CheckStatusInfo::default_instance_ = new CheckStatusInfo();
  CheckStatusInfo_Command::default_instance_ = new CheckStatusInfo_Command();
  CheckStatusInfo_Http::default_instance_ = new CheckStatusInfo_Http();
  TaskStatus::default_instance_ = new TaskStatus();
  Filters::default_instance_ = new Filters();
  Environment::default_instance_ = new Environment();
  Environment_Variable::default_instance_ = new Environment_Variable();
  Parameter::default_instance_ = new Parameter();
  Parameters::default_instance_ = new Parameters();
  Credential::default_instance_ = new Credential();
  Credentials::default_instance_ = new Credentials();
  Secret::default_instance_ = new Secret();
  Secret_Reference::default_instance_ = new Secret_Reference();
  Secret_Value::default_instance_ = new Secret_Value();
  RateLimit::default_instance_ = new RateLimit();
  RateLimits::default_instance_ = new RateLimits();
  Image::default_instance_ = new Image();
  Image_Appc::default_instance_ = new Image_Appc();
  Image_Docker::default_instance_ = new Image_Docker();
  Volume::default_instance_ = new Volume();
  Volume_Source::default_instance_ = new Volume_Source();
  Volume_Source_DockerVolume::default_instance_ = new Volume_Source_DockerVolume();
  Volume_Source_SandboxPath::default_instance_ = new Volume_Source_SandboxPath();
  NetworkInfo::default_instance_ = new NetworkInfo();
  NetworkInfo_IPAddress::default_instance_ = new NetworkInfo_IPAddress();
  NetworkInfo_PortMapping::default_instance_ = new NetworkInfo_PortMapping();
  CapabilityInfo::default_instance_ = new CapabilityInfo();
  LinuxInfo::default_instance_ = new LinuxInfo();
  RLimitInfo::default_instance_ = new RLimitInfo();
  RLimitInfo_RLimit::default_instance_ = new RLimitInfo_RLimit();
  TTYInfo::default_instance_ = new TTYInfo();
  TTYInfo_WindowSize::default_instance_ = new TTYInfo_WindowSize();
  ContainerInfo::default_instance_ = new ContainerInfo();
  ContainerInfo_DockerInfo::default_instance_ = new ContainerInfo_DockerInfo();
  ContainerInfo_DockerInfo_PortMapping::default_instance_ = new ContainerInfo_DockerInfo_PortMapping();
  ContainerInfo_MesosInfo::default_instance_ = new ContainerInfo_MesosInfo();
  ContainerStatus::default_instance_ = new ContainerStatus();
  CgroupInfo::default_instance_ = new CgroupInfo();
  CgroupInfo_NetCls::default_instance_ = new CgroupInfo_NetCls();
  Labels::default_instance_ = new Labels();
  Label::default_instance_ = new Label();
  Port::default_instance_ = new Port();
  Ports::default_instance_ = new Ports();
  DiscoveryInfo::default_instance_ = new DiscoveryInfo();
  WeightInfo::default_instance_ = new WeightInfo();
  VersionInfo::default_instance_ = new VersionInfo();
  Flag::default_instance_ = new Flag();
  Role::default_instance_ = new Role();
  Metric::default_instance_ = new Metric();
  FileInfo::default_instance_ = new FileInfo();
  FrameworkID::default_instance_->InitAsDefaultInstance();
  OfferID::default_instance_->InitAsDefaultInstance();
  SlaveID::default_instance_->InitAsDefaultInstance();
  TaskID::default_instance_->InitAsDefaultInstance();
  ExecutorID::default_instance_->InitAsDefaultInstance();
  ContainerID::default_instance_->InitAsDefaultInstance();
  TimeInfo::default_instance_->InitAsDefaultInstance();
  DurationInfo::default_instance_->InitAsDefaultInstance();
  Address::default_instance_->InitAsDefaultInstance();
  URL::default_instance_->InitAsDefaultInstance();
  Unavailability::default_instance_->InitAsDefaultInstance();
  MachineID::default_instance_->InitAsDefaultInstance();
  MachineInfo::default_instance_->InitAsDefaultInstance();
  FrameworkInfo::default_instance_->InitAsDefaultInstance();
  FrameworkInfo_Capability::default_instance_->InitAsDefaultInstance();
  CheckInfo::default_instance_->InitAsDefaultInstance();
  CheckInfo_Command::default_instance_->InitAsDefaultInstance();
  CheckInfo_Http::default_instance_->InitAsDefaultInstance();
  HealthCheck::default_instance_->InitAsDefaultInstance();
  HealthCheck_HTTPCheckInfo::default_instance_->InitAsDefaultInstance();
  HealthCheck_TCPCheckInfo::default_instance_->InitAsDefaultInstance();
  KillPolicy::default_instance_->InitAsDefaultInstance();
  CommandInfo::default_instance_->InitAsDefaultInstance();
  CommandInfo_URI::default_instance_->InitAsDefaultInstance();
  ExecutorInfo::default_instance_->InitAsDefaultInstance();
  MasterInfo::default_instance_->InitAsDefaultInstance();
  SlaveInfo::default_instance_->InitAsDefaultInstance();
  SlaveInfo_Capability::default_instance_->InitAsDefaultInstance();
  Value::default_instance_->InitAsDefaultInstance();
  Value_Scalar::default_instance_->InitAsDefaultInstance();
  Value_Range::default_instance_->InitAsDefaultInstance();
  Value_Ranges::default_instance_->InitAsDefaultInstance();
  Value_Set::default_instance_->InitAsDefaultInstance();
  Value_Text::default_instance_->InitAsDefaultInstance();
  Attribute::default_instance_->InitAsDefaultInstance();
  Resource::default_instance_->InitAsDefaultInstance();
  Resource_AllocationInfo::default_instance_->InitAsDefaultInstance();
  Resource_ReservationInfo::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Persistence::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Source::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Source_Path::default_instance_->InitAsDefaultInstance();
  Resource_DiskInfo_Source_Mount::default_instance_->InitAsDefaultInstance();
  Resource_RevocableInfo::default_instance_->InitAsDefaultInstance();
  Resource_SharedInfo::default_instance_->InitAsDefaultInstance();
  TrafficControlStatistics::default_instance_->InitAsDefaultInstance();
  IpStatistics::default_instance_->InitAsDefaultInstance();
  IcmpStatistics::default_instance_->InitAsDefaultInstance();
  TcpStatistics::default_instance_->InitAsDefaultInstance();
  UdpStatistics::default_instance_->InitAsDefaultInstance();
  SNMPStatistics::default_instance_->InitAsDefaultInstance();
  ResourceStatistics::default_instance_->InitAsDefaultInstance();
  ResourceUsage::default_instance_->InitAsDefaultInstance();
  ResourceUsage_Executor::default_instance_->InitAsDefaultInstance();
  ResourceUsage_Executor_Task::default_instance_->InitAsDefaultInstance();
  PerfStatistics::default_instance_->InitAsDefaultInstance();
  Request::default_instance_->InitAsDefaultInstance();
  Offer::default_instance_->InitAsDefaultInstance();
  Offer_Operation::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Launch::default_instance_->InitAsDefaultInstance();
  Offer_Operation_LaunchGroup::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Reserve::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Unreserve::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Create::default_instance_->InitAsDefaultInstance();
  Offer_Operation_Destroy::default_instance_->InitAsDefaultInstance();
  InverseOffer::default_instance_->InitAsDefaultInstance();
  TaskInfo::default_instance_->InitAsDefaultInstance();
  TaskGroupInfo::default_instance_->InitAsDefaultInstance();
  Task::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo_Command::default_instance_->InitAsDefaultInstance();
  CheckStatusInfo_Http::default_instance_->InitAsDefaultInstance();
  TaskStatus::default_instance_->InitAsDefaultInstance();
  Filters::default_instance_->InitAsDefaultInstance();
  Environment::default_instance_->InitAsDefaultInstance();
  Environment_Variable::default_instance_->InitAsDefaultInstance();
  Parameter::default_instance_->InitAsDefaultInstance();
  Parameters::default_instance_->InitAsDefaultInstance();
  Credential::default_instance_->InitAsDefaultInstance();
  Credentials::default_instance_->InitAsDefaultInstance();
  Secret::default_instance_->InitAsDefaultInstance();
  Secret_Reference::default_instance_->InitAsDefaultInstance();
  Secret_Value::default_instance_->InitAsDefaultInstance();
  RateLimit::default_instance_->InitAsDefaultInstance();
  RateLimits::default_instance_->InitAsDefaultInstance();
  Image::default_instance_->InitAsDefaultInstance();
  Image_Appc::default_instance_->InitAsDefaultInstance();
  Image_Docker::default_instance_->InitAsDefaultInstance();
  Volume::default_instance_->InitAsDefaultInstance();
  Volume_Source::default_instance_->InitAsDefaultInstance();
  Volume_Source_DockerVolume::default_instance_->InitAsDefaultInstance();
  Volume_Source_SandboxPath::default_instance_->InitAsDefaultInstance();
  NetworkInfo::default_instance_->InitAsDefaultInstance();
  NetworkInfo_IPAddress::default_instance_->InitAsDefaultInstance();
  NetworkInfo_PortMapping::default_instance_->InitAsDefaultInstance();
  CapabilityInfo::default_instance_->InitAsDefaultInstance();
  LinuxInfo::default_instance_->InitAsDefaultInstance();
  RLimitInfo::default_instance_->InitAsDefaultInstance();
  RLimitInfo_RLimit::default_instance_->InitAsDefaultInstance();
  TTYInfo::default_instance_->InitAsDefaultInstance();
  TTYInfo_WindowSize::default_instance_->InitAsDefaultInstance();
  ContainerInfo::default_instance_->InitAsDefaultInstance();
  ContainerInfo_DockerInfo::default_instance_->InitAsDefaultInstance();
  ContainerInfo_DockerInfo_PortMapping::default_instance_->InitAsDefaultInstance();
  ContainerInfo_MesosInfo::default_instance_->InitAsDefaultInstance();
  ContainerStatus::default_instance_->InitAsDefaultInstance();
  CgroupInfo::default_instance_->InitAsDefaultInstance();
  CgroupInfo_NetCls::default_instance_->InitAsDefaultInstance();
  Labels::default_instance_->InitAsDefaultInstance();
  Label::default_instance_->InitAsDefaultInstance();
  Port::default_instance_->InitAsDefaultInstance();
  Ports::default_instance_->InitAsDefaultInstance();
  DiscoveryInfo::default_instance_->InitAsDefaultInstance();
  WeightInfo::default_instance_->InitAsDefaultInstance();
  VersionInfo::default_instance_->InitAsDefaultInstance();
  Flag::default_instance_->InitAsDefaultInstance();
  Role::default_instance_->InitAsDefaultInstance();
  Metric::default_instance_->InitAsDefaultInstance();
  FileInfo::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_mesos_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_mesos_2eproto {
  StaticDescriptorInitializer_mesos_2eproto() {
    protobuf_AddDesc_mesos_2eproto();
  }
} static_descriptor_initializer_mesos_2eproto_;
const ::google::protobuf::EnumDescriptor* Status_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Status_descriptor_;
}
bool Status_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* TaskState_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskState_descriptor_;
}
bool TaskState_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FrameworkID::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FrameworkID::FrameworkID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FrameworkID)
}

void FrameworkID::InitAsDefaultInstance() {
}

FrameworkID::FrameworkID(const FrameworkID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FrameworkID)
}

void FrameworkID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkID::~FrameworkID() {
  // @@protoc_insertion_point(destructor:mesos.FrameworkID)
  SharedDtor();
}

void FrameworkID::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void FrameworkID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkID_descriptor_;
}

const FrameworkID& FrameworkID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FrameworkID* FrameworkID::default_instance_ = NULL;

FrameworkID* FrameworkID::New(::google::protobuf::Arena* arena) const {
  FrameworkID* n = new FrameworkID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FrameworkID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.FrameworkID)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FrameworkID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FrameworkID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkID.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FrameworkID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FrameworkID)
  return false;
#undef DO_
}

void FrameworkID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FrameworkID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkID.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FrameworkID)
}

::google::protobuf::uint8* FrameworkID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FrameworkID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkID.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FrameworkID)
  return target;
}

int FrameworkID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.FrameworkID)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.FrameworkID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FrameworkID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FrameworkID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.FrameworkID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.FrameworkID)
    MergeFrom(*source);
  }
}

void FrameworkID::MergeFrom(const FrameworkID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.FrameworkID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FrameworkID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.FrameworkID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkID::CopyFrom(const FrameworkID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.FrameworkID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FrameworkID::Swap(FrameworkID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FrameworkID::InternalSwap(FrameworkID* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FrameworkID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkID_descriptor_;
  metadata.reflection = FrameworkID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FrameworkID

// required string value = 1;
bool FrameworkID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FrameworkID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void FrameworkID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void FrameworkID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& FrameworkID::value() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkID.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkID::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkID.value)
}
 void FrameworkID::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkID.value)
}
 void FrameworkID::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkID.value)
}
 ::std::string* FrameworkID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameworkID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkID.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkID.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OfferID::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OfferID::OfferID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.OfferID)
}

void OfferID::InitAsDefaultInstance() {
}

OfferID::OfferID(const OfferID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.OfferID)
}

void OfferID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OfferID::~OfferID() {
  // @@protoc_insertion_point(destructor:mesos.OfferID)
  SharedDtor();
}

void OfferID::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void OfferID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OfferID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OfferID_descriptor_;
}

const OfferID& OfferID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

OfferID* OfferID::default_instance_ = NULL;

OfferID* OfferID::New(::google::protobuf::Arena* arena) const {
  OfferID* n = new OfferID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OfferID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.OfferID)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool OfferID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.OfferID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.OfferID.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.OfferID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.OfferID)
  return false;
#undef DO_
}

void OfferID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.OfferID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.OfferID.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.OfferID)
}

::google::protobuf::uint8* OfferID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.OfferID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.OfferID.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.OfferID)
  return target;
}

int OfferID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.OfferID)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OfferID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.OfferID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const OfferID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OfferID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.OfferID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.OfferID)
    MergeFrom(*source);
  }
}

void OfferID::MergeFrom(const OfferID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.OfferID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void OfferID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.OfferID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OfferID::CopyFrom(const OfferID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.OfferID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OfferID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void OfferID::Swap(OfferID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OfferID::InternalSwap(OfferID* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OfferID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OfferID_descriptor_;
  metadata.reflection = OfferID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OfferID

// required string value = 1;
bool OfferID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void OfferID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void OfferID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void OfferID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& OfferID::value() const {
  // @@protoc_insertion_point(field_get:mesos.OfferID.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OfferID::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.OfferID.value)
}
 void OfferID::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.OfferID.value)
}
 void OfferID::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.OfferID.value)
}
 ::std::string* OfferID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.OfferID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* OfferID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.OfferID.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OfferID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.OfferID.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SlaveID::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SlaveID::SlaveID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SlaveID)
}

void SlaveID::InitAsDefaultInstance() {
}

SlaveID::SlaveID(const SlaveID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SlaveID)
}

void SlaveID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveID::~SlaveID() {
  // @@protoc_insertion_point(destructor:mesos.SlaveID)
  SharedDtor();
}

void SlaveID::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void SlaveID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveID_descriptor_;
}

const SlaveID& SlaveID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SlaveID* SlaveID::default_instance_ = NULL;

SlaveID* SlaveID::New(::google::protobuf::Arena* arena) const {
  SlaveID* n = new SlaveID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SlaveID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.SlaveID)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SlaveID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SlaveID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.SlaveID.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SlaveID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SlaveID)
  return false;
#undef DO_
}

void SlaveID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SlaveID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.SlaveID.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SlaveID)
}

::google::protobuf::uint8* SlaveID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SlaveID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.SlaveID.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SlaveID)
  return target;
}

int SlaveID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.SlaveID)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.SlaveID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SlaveID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SlaveID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.SlaveID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.SlaveID)
    MergeFrom(*source);
  }
}

void SlaveID::MergeFrom(const SlaveID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.SlaveID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SlaveID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.SlaveID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveID::CopyFrom(const SlaveID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.SlaveID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SlaveID::Swap(SlaveID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SlaveID::InternalSwap(SlaveID* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SlaveID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveID_descriptor_;
  metadata.reflection = SlaveID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SlaveID

// required string value = 1;
bool SlaveID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SlaveID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void SlaveID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void SlaveID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& SlaveID::value() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveID.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SlaveID::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.SlaveID.value)
}
 void SlaveID::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.SlaveID.value)
}
 void SlaveID::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.SlaveID.value)
}
 ::std::string* SlaveID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.SlaveID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SlaveID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.SlaveID.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SlaveID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveID.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TaskID::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TaskID::TaskID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskID)
}

void TaskID::InitAsDefaultInstance() {
}

TaskID::TaskID(const TaskID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskID)
}

void TaskID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskID::~TaskID() {
  // @@protoc_insertion_point(destructor:mesos.TaskID)
  SharedDtor();
}

void TaskID::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void TaskID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskID_descriptor_;
}

const TaskID& TaskID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskID* TaskID::default_instance_ = NULL;

TaskID* TaskID::New(::google::protobuf::Arena* arena) const {
  TaskID* n = new TaskID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TaskID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TaskID)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TaskID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.TaskID.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskID)
  return false;
#undef DO_
}

void TaskID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TaskID.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskID)
}

::google::protobuf::uint8* TaskID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TaskID.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskID)
  return target;
}

int TaskID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TaskID)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TaskID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TaskID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TaskID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TaskID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TaskID)
    MergeFrom(*source);
  }
}

void TaskID::MergeFrom(const TaskID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TaskID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TaskID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TaskID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskID::CopyFrom(const TaskID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TaskID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TaskID::Swap(TaskID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TaskID::InternalSwap(TaskID* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TaskID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskID_descriptor_;
  metadata.reflection = TaskID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TaskID

// required string value = 1;
bool TaskID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TaskID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void TaskID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void TaskID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& TaskID::value() const {
  // @@protoc_insertion_point(field_get:mesos.TaskID.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskID::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TaskID.value)
}
 void TaskID::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TaskID.value)
}
 void TaskID::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskID.value)
}
 ::std::string* TaskID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.TaskID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TaskID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.TaskID.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskID.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExecutorID::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExecutorID::ExecutorID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ExecutorID)
}

void ExecutorID::InitAsDefaultInstance() {
}

ExecutorID::ExecutorID(const ExecutorID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ExecutorID)
}

void ExecutorID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorID::~ExecutorID() {
  // @@protoc_insertion_point(destructor:mesos.ExecutorID)
  SharedDtor();
}

void ExecutorID::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ExecutorID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorID_descriptor_;
}

const ExecutorID& ExecutorID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ExecutorID* ExecutorID::default_instance_ = NULL;

ExecutorID* ExecutorID::New(::google::protobuf::Arena* arena) const {
  ExecutorID* n = new ExecutorID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExecutorID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ExecutorID)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ExecutorID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ExecutorID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ExecutorID.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ExecutorID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ExecutorID)
  return false;
#undef DO_
}

void ExecutorID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ExecutorID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ExecutorID.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ExecutorID)
}

::google::protobuf::uint8* ExecutorID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ExecutorID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ExecutorID.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ExecutorID)
  return target;
}

int ExecutorID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ExecutorID)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ExecutorID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ExecutorID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ExecutorID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ExecutorID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ExecutorID)
    MergeFrom(*source);
  }
}

void ExecutorID::MergeFrom(const ExecutorID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ExecutorID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ExecutorID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ExecutorID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorID::CopyFrom(const ExecutorID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ExecutorID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void ExecutorID::Swap(ExecutorID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExecutorID::InternalSwap(ExecutorID* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ExecutorID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorID_descriptor_;
  metadata.reflection = ExecutorID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExecutorID

// required string value = 1;
bool ExecutorID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ExecutorID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void ExecutorID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void ExecutorID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& ExecutorID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorID.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorID::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorID.value)
}
 void ExecutorID::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorID.value)
}
 void ExecutorID::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorID.value)
}
 ::std::string* ExecutorID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExecutorID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorID.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorID.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContainerID::kValueFieldNumber;
const int ContainerID::kParentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContainerID::ContainerID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerID)
}

void ContainerID::InitAsDefaultInstance() {
  parent_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
}

ContainerID::ContainerID(const ContainerID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerID)
}

void ContainerID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  parent_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerID::~ContainerID() {
  // @@protoc_insertion_point(destructor:mesos.ContainerID)
  SharedDtor();
}

void ContainerID::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete parent_;
  }
}

void ContainerID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerID_descriptor_;
}

const ContainerID& ContainerID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerID* ContainerID::default_instance_ = NULL;

ContainerID* ContainerID::New(::google::protobuf::Arena* arena) const {
  ContainerID* n = new ContainerID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ContainerID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ContainerID)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_parent()) {
      if (parent_ != NULL) parent_->::mesos::ContainerID::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ContainerID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ContainerID.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_parent;
        break;
      }

      // optional .mesos.ContainerID parent = 2;
      case 2: {
        if (tag == 18) {
         parse_parent:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_parent()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerID)
  return false;
#undef DO_
}

void ContainerID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerID.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  // optional .mesos.ContainerID parent = 2;
  if (has_parent()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->parent_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerID)
}

::google::protobuf::uint8* ContainerID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerID)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerID.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  // optional .mesos.ContainerID parent = 2;
  if (has_parent()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->parent_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerID)
  return target;
}

int ContainerID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ContainerID)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  // optional .mesos.ContainerID parent = 2;
  if (has_parent()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->parent_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ContainerID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ContainerID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ContainerID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ContainerID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ContainerID)
    MergeFrom(*source);
  }
}

void ContainerID::MergeFrom(const ContainerID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ContainerID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_parent()) {
      mutable_parent()->::mesos::ContainerID::MergeFrom(from.parent());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ContainerID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ContainerID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerID::CopyFrom(const ContainerID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ContainerID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerID::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_parent()) {
    if (!this->parent_->IsInitialized()) return false;
  }
  return true;
}

void ContainerID::Swap(ContainerID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContainerID::InternalSwap(ContainerID* other) {
  value_.Swap(&other->value_);
  std::swap(parent_, other->parent_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ContainerID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerID_descriptor_;
  metadata.reflection = ContainerID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ContainerID

// required string value = 1;
bool ContainerID::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ContainerID::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void ContainerID::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void ContainerID::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& ContainerID::value() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerID.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerID::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ContainerID.value)
}
 void ContainerID::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ContainerID.value)
}
 void ContainerID::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerID.value)
}
 ::std::string* ContainerID::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerID.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ContainerID::release_value() {
  // @@protoc_insertion_point(field_release:mesos.ContainerID.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerID::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerID.value)
}

// optional .mesos.ContainerID parent = 2;
bool ContainerID::has_parent() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ContainerID::set_has_parent() {
  _has_bits_[0] |= 0x00000002u;
}
void ContainerID::clear_has_parent() {
  _has_bits_[0] &= ~0x00000002u;
}
void ContainerID::clear_parent() {
  if (parent_ != NULL) parent_->::mesos::ContainerID::Clear();
  clear_has_parent();
}
const ::mesos::ContainerID& ContainerID::parent() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerID.parent)
  return parent_ != NULL ? *parent_ : *default_instance_->parent_;
}
::mesos::ContainerID* ContainerID::mutable_parent() {
  set_has_parent();
  if (parent_ == NULL) {
    parent_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerID.parent)
  return parent_;
}
::mesos::ContainerID* ContainerID::release_parent() {
  // @@protoc_insertion_point(field_release:mesos.ContainerID.parent)
  clear_has_parent();
  ::mesos::ContainerID* temp = parent_;
  parent_ = NULL;
  return temp;
}
void ContainerID::set_allocated_parent(::mesos::ContainerID* parent) {
  delete parent_;
  parent_ = parent;
  if (parent) {
    set_has_parent();
  } else {
    clear_has_parent();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerID.parent)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TimeInfo::kNanosecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TimeInfo::TimeInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TimeInfo)
}

void TimeInfo::InitAsDefaultInstance() {
}

TimeInfo::TimeInfo(const TimeInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TimeInfo)
}

void TimeInfo::SharedCtor() {
  _cached_size_ = 0;
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TimeInfo::~TimeInfo() {
  // @@protoc_insertion_point(destructor:mesos.TimeInfo)
  SharedDtor();
}

void TimeInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TimeInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TimeInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TimeInfo_descriptor_;
}

const TimeInfo& TimeInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TimeInfo* TimeInfo::default_instance_ = NULL;

TimeInfo* TimeInfo::New(::google::protobuf::Arena* arena) const {
  TimeInfo* n = new TimeInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TimeInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TimeInfo)
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TimeInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TimeInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 nanoseconds = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &nanoseconds_)));
          set_has_nanoseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TimeInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TimeInfo)
  return false;
#undef DO_
}

void TimeInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TimeInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->nanoseconds(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TimeInfo)
}

::google::protobuf::uint8* TimeInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TimeInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->nanoseconds(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TimeInfo)
  return target;
}

int TimeInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TimeInfo)
  int total_size = 0;

  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->nanoseconds());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TimeInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TimeInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TimeInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TimeInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TimeInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TimeInfo)
    MergeFrom(*source);
  }
}

void TimeInfo::MergeFrom(const TimeInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TimeInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nanoseconds()) {
      set_nanoseconds(from.nanoseconds());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TimeInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TimeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TimeInfo::CopyFrom(const TimeInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TimeInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TimeInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TimeInfo::Swap(TimeInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TimeInfo::InternalSwap(TimeInfo* other) {
  std::swap(nanoseconds_, other->nanoseconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TimeInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TimeInfo_descriptor_;
  metadata.reflection = TimeInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TimeInfo

// required int64 nanoseconds = 1;
bool TimeInfo::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TimeInfo::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000001u;
}
void TimeInfo::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void TimeInfo::clear_nanoseconds() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_nanoseconds();
}
 ::google::protobuf::int64 TimeInfo::nanoseconds() const {
  // @@protoc_insertion_point(field_get:mesos.TimeInfo.nanoseconds)
  return nanoseconds_;
}
 void TimeInfo::set_nanoseconds(::google::protobuf::int64 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.TimeInfo.nanoseconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DurationInfo::kNanosecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DurationInfo::DurationInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DurationInfo)
}

void DurationInfo::InitAsDefaultInstance() {
}

DurationInfo::DurationInfo(const DurationInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DurationInfo)
}

void DurationInfo::SharedCtor() {
  _cached_size_ = 0;
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DurationInfo::~DurationInfo() {
  // @@protoc_insertion_point(destructor:mesos.DurationInfo)
  SharedDtor();
}

void DurationInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DurationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DurationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DurationInfo_descriptor_;
}

const DurationInfo& DurationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DurationInfo* DurationInfo::default_instance_ = NULL;

DurationInfo* DurationInfo::New(::google::protobuf::Arena* arena) const {
  DurationInfo* n = new DurationInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DurationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.DurationInfo)
  nanoseconds_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DurationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DurationInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 nanoseconds = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &nanoseconds_)));
          set_has_nanoseconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DurationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DurationInfo)
  return false;
#undef DO_
}

void DurationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DurationInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->nanoseconds(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DurationInfo)
}

::google::protobuf::uint8* DurationInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DurationInfo)
  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->nanoseconds(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DurationInfo)
  return target;
}

int DurationInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.DurationInfo)
  int total_size = 0;

  // required int64 nanoseconds = 1;
  if (has_nanoseconds()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->nanoseconds());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DurationInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.DurationInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DurationInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DurationInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.DurationInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.DurationInfo)
    MergeFrom(*source);
  }
}

void DurationInfo::MergeFrom(const DurationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.DurationInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_nanoseconds()) {
      set_nanoseconds(from.nanoseconds());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DurationInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.DurationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DurationInfo::CopyFrom(const DurationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.DurationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DurationInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void DurationInfo::Swap(DurationInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DurationInfo::InternalSwap(DurationInfo* other) {
  std::swap(nanoseconds_, other->nanoseconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DurationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DurationInfo_descriptor_;
  metadata.reflection = DurationInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DurationInfo

// required int64 nanoseconds = 1;
bool DurationInfo::has_nanoseconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DurationInfo::set_has_nanoseconds() {
  _has_bits_[0] |= 0x00000001u;
}
void DurationInfo::clear_has_nanoseconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void DurationInfo::clear_nanoseconds() {
  nanoseconds_ = GOOGLE_LONGLONG(0);
  clear_has_nanoseconds();
}
 ::google::protobuf::int64 DurationInfo::nanoseconds() const {
  // @@protoc_insertion_point(field_get:mesos.DurationInfo.nanoseconds)
  return nanoseconds_;
}
 void DurationInfo::set_nanoseconds(::google::protobuf::int64 value) {
  set_has_nanoseconds();
  nanoseconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.DurationInfo.nanoseconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Address::kHostnameFieldNumber;
const int Address::kIpFieldNumber;
const int Address::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Address::Address()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Address)
}

void Address::InitAsDefaultInstance() {
}

Address::Address(const Address& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Address)
}

void Address::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Address::~Address() {
  // @@protoc_insertion_point(destructor:mesos.Address)
  SharedDtor();
}

void Address::SharedDtor() {
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Address::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Address::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Address_descriptor_;
}

const Address& Address::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Address* Address::default_instance_ = NULL;

Address* Address::New(::google::protobuf::Arena* arena) const {
  Address* n = new Address;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Address::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Address)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ip()) {
      ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    port_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Address::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Address)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string hostname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Address.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (tag == 18) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Address.ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required int32 port = 3;
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Address)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Address)
  return false;
#undef DO_
}

void Address::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Address)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Address.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Address.ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip(), output);
  }

  // required int32 port = 3;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->port(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Address)
}

::google::protobuf::uint8* Address::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Address)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Address.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hostname(), target);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Address.ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip(), target);
  }

  // required int32 port = 3;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->port(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Address)
  return target;
}

int Address::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Address)
  int total_size = 0;

  // required int32 port = 3;
  if (has_port()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->port());
  }
  if (_has_bits_[0 / 32] & 3u) {
    // optional string hostname = 1;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Address::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Address)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Address* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Address>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Address)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Address)
    MergeFrom(*source);
  }
}

void Address::MergeFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Address)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_ip()) {
      set_has_ip();
      ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
    }
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Address::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Address::CopyFrom(const Address& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Address)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Address::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000004) != 0x00000004) return false;

  return true;
}

void Address::Swap(Address* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Address::InternalSwap(Address* other) {
  hostname_.Swap(&other->hostname_);
  ip_.Swap(&other->ip_);
  std::swap(port_, other->port_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Address::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Address_descriptor_;
  metadata.reflection = Address_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Address

// optional string hostname = 1;
bool Address::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Address::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
void Address::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
void Address::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& Address::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.Address.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Address::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Address.hostname)
}
 void Address::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Address.hostname)
}
 void Address::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Address.hostname)
}
 ::std::string* Address::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.Address.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Address::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.Address.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Address::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.Address.hostname)
}

// optional string ip = 2;
bool Address::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Address::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
void Address::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
void Address::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
 const ::std::string& Address::ip() const {
  // @@protoc_insertion_point(field_get:mesos.Address.ip)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Address::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Address.ip)
}
 void Address::set_ip(const char* value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Address.ip)
}
 void Address::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Address.ip)
}
 ::std::string* Address::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mesos.Address.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Address::release_ip() {
  // @@protoc_insertion_point(field_release:mesos.Address.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Address::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mesos.Address.ip)
}

// required int32 port = 3;
bool Address::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Address::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
void Address::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
void Address::clear_port() {
  port_ = 0;
  clear_has_port();
}
 ::google::protobuf::int32 Address::port() const {
  // @@protoc_insertion_point(field_get:mesos.Address.port)
  return port_;
}
 void Address::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.Address.port)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int URL::kSchemeFieldNumber;
const int URL::kAddressFieldNumber;
const int URL::kPathFieldNumber;
const int URL::kQueryFieldNumber;
const int URL::kFragmentFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

URL::URL()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.URL)
}

void URL::InitAsDefaultInstance() {
  address_ = const_cast< ::mesos::Address*>(&::mesos::Address::default_instance());
}

URL::URL(const URL& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.URL)
}

void URL::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  scheme_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_ = NULL;
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fragment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

URL::~URL() {
  // @@protoc_insertion_point(destructor:mesos.URL)
  SharedDtor();
}

void URL::SharedDtor() {
  scheme_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  fragment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete address_;
  }
}

void URL::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* URL::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return URL_descriptor_;
}

const URL& URL::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

URL* URL::default_instance_ = NULL;

URL* URL::New(::google::protobuf::Arena* arena) const {
  URL* n = new URL;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void URL::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.URL)
  if (_has_bits_[0 / 32] & 23u) {
    if (has_scheme()) {
      scheme_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_address()) {
      if (address_ != NULL) address_->::mesos::Address::Clear();
    }
    if (has_path()) {
      path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_fragment()) {
      fragment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  query_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool URL::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.URL)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string scheme = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_scheme()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->scheme().data(), this->scheme().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.URL.scheme");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_address;
        break;
      }

      // required .mesos.Address address = 2;
      case 2: {
        if (tag == 18) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_path;
        break;
      }

      // optional string path = 3;
      case 3: {
        if (tag == 26) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.URL.path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_query;
        break;
      }

      // repeated .mesos.Parameter query = 4;
      case 4: {
        if (tag == 34) {
         parse_query:
          DO_(input->IncrementRecursionDepth());
         parse_loop_query:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_query()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_query;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(42)) goto parse_fragment;
        break;
      }

      // optional string fragment = 5;
      case 5: {
        if (tag == 42) {
         parse_fragment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_fragment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->fragment().data(), this->fragment().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.URL.fragment");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.URL)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.URL)
  return false;
#undef DO_
}

void URL::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.URL)
  // required string scheme = 1;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.URL.scheme");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->scheme(), output);
  }

  // required .mesos.Address address = 2;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->address_, output);
  }

  // optional string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.URL.path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->path(), output);
  }

  // repeated .mesos.Parameter query = 4;
  for (unsigned int i = 0, n = this->query_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->query(i), output);
  }

  // optional string fragment = 5;
  if (has_fragment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fragment().data(), this->fragment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.URL.fragment");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->fragment(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.URL)
}

::google::protobuf::uint8* URL::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.URL)
  // required string scheme = 1;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.URL.scheme");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->scheme(), target);
  }

  // required .mesos.Address address = 2;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->address_, false, target);
  }

  // optional string path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.URL.path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->path(), target);
  }

  // repeated .mesos.Parameter query = 4;
  for (unsigned int i = 0, n = this->query_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->query(i), false, target);
  }

  // optional string fragment = 5;
  if (has_fragment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->fragment().data(), this->fragment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.URL.fragment");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->fragment(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.URL)
  return target;
}

int URL::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.URL)
  int total_size = 0;

  if (has_scheme()) {
    // required string scheme = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->scheme());
  }

  if (has_address()) {
    // required .mesos.Address address = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->address_);
  }

  return total_size;
}
int URL::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.URL)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string scheme = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->scheme());

    // required .mesos.Address address = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->address_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 20u) {
    // optional string path = 3;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

    // optional string fragment = 5;
    if (has_fragment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->fragment());
    }

  }
  // repeated .mesos.Parameter query = 4;
  total_size += 1 * this->query_size();
  for (int i = 0; i < this->query_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->query(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void URL::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.URL)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const URL* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const URL>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.URL)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.URL)
    MergeFrom(*source);
  }
}

void URL::MergeFrom(const URL& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.URL)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  query_.MergeFrom(from.query_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_scheme()) {
      set_has_scheme();
      scheme_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.scheme_);
    }
    if (from.has_address()) {
      mutable_address()->::mesos::Address::MergeFrom(from.address());
    }
    if (from.has_path()) {
      set_has_path();
      path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
    }
    if (from.has_fragment()) {
      set_has_fragment();
      fragment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.fragment_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void URL::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.URL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void URL::CopyFrom(const URL& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.URL)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool URL::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->query())) return false;
  return true;
}

void URL::Swap(URL* other) {
  if (other == this) return;
  InternalSwap(other);
}
void URL::InternalSwap(URL* other) {
  scheme_.Swap(&other->scheme_);
  std::swap(address_, other->address_);
  path_.Swap(&other->path_);
  query_.UnsafeArenaSwap(&other->query_);
  fragment_.Swap(&other->fragment_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata URL::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = URL_descriptor_;
  metadata.reflection = URL_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// URL

// required string scheme = 1;
bool URL::has_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void URL::set_has_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
void URL::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
void URL::clear_scheme() {
  scheme_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scheme();
}
 const ::std::string& URL::scheme() const {
  // @@protoc_insertion_point(field_get:mesos.URL.scheme)
  return scheme_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void URL::set_scheme(const ::std::string& value) {
  set_has_scheme();
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.URL.scheme)
}
 void URL::set_scheme(const char* value) {
  set_has_scheme();
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.URL.scheme)
}
 void URL::set_scheme(const char* value, size_t size) {
  set_has_scheme();
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.scheme)
}
 ::std::string* URL::mutable_scheme() {
  set_has_scheme();
  // @@protoc_insertion_point(field_mutable:mesos.URL.scheme)
  return scheme_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* URL::release_scheme() {
  // @@protoc_insertion_point(field_release:mesos.URL.scheme)
  clear_has_scheme();
  return scheme_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void URL::set_allocated_scheme(::std::string* scheme) {
  if (scheme != NULL) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
  scheme_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheme);
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.scheme)
}

// required .mesos.Address address = 2;
bool URL::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void URL::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
void URL::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
void URL::clear_address() {
  if (address_ != NULL) address_->::mesos::Address::Clear();
  clear_has_address();
}
const ::mesos::Address& URL::address() const {
  // @@protoc_insertion_point(field_get:mesos.URL.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
::mesos::Address* URL::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::mesos::Address;
  }
  // @@protoc_insertion_point(field_mutable:mesos.URL.address)
  return address_;
}
::mesos::Address* URL::release_address() {
  // @@protoc_insertion_point(field_release:mesos.URL.address)
  clear_has_address();
  ::mesos::Address* temp = address_;
  address_ = NULL;
  return temp;
}
void URL::set_allocated_address(::mesos::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.address)
}

// optional string path = 3;
bool URL::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void URL::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
void URL::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
void URL::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
 const ::std::string& URL::path() const {
  // @@protoc_insertion_point(field_get:mesos.URL.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void URL::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.URL.path)
}
 void URL::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.URL.path)
}
 void URL::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.path)
}
 ::std::string* URL::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.URL.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* URL::release_path() {
  // @@protoc_insertion_point(field_release:mesos.URL.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void URL::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.path)
}

// repeated .mesos.Parameter query = 4;
int URL::query_size() const {
  return query_.size();
}
void URL::clear_query() {
  query_.Clear();
}
const ::mesos::Parameter& URL::query(int index) const {
  // @@protoc_insertion_point(field_get:mesos.URL.query)
  return query_.Get(index);
}
::mesos::Parameter* URL::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.URL.query)
  return query_.Mutable(index);
}
::mesos::Parameter* URL::add_query() {
  // @@protoc_insertion_point(field_add:mesos.URL.query)
  return query_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
URL::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:mesos.URL.query)
  return &query_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
URL::query() const {
  // @@protoc_insertion_point(field_list:mesos.URL.query)
  return query_;
}

// optional string fragment = 5;
bool URL::has_fragment() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void URL::set_has_fragment() {
  _has_bits_[0] |= 0x00000010u;
}
void URL::clear_has_fragment() {
  _has_bits_[0] &= ~0x00000010u;
}
void URL::clear_fragment() {
  fragment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_fragment();
}
 const ::std::string& URL::fragment() const {
  // @@protoc_insertion_point(field_get:mesos.URL.fragment)
  return fragment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void URL::set_fragment(const ::std::string& value) {
  set_has_fragment();
  fragment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.URL.fragment)
}
 void URL::set_fragment(const char* value) {
  set_has_fragment();
  fragment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.URL.fragment)
}
 void URL::set_fragment(const char* value, size_t size) {
  set_has_fragment();
  fragment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.URL.fragment)
}
 ::std::string* URL::mutable_fragment() {
  set_has_fragment();
  // @@protoc_insertion_point(field_mutable:mesos.URL.fragment)
  return fragment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* URL::release_fragment() {
  // @@protoc_insertion_point(field_release:mesos.URL.fragment)
  clear_has_fragment();
  return fragment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void URL::set_allocated_fragment(::std::string* fragment) {
  if (fragment != NULL) {
    set_has_fragment();
  } else {
    clear_has_fragment();
  }
  fragment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), fragment);
  // @@protoc_insertion_point(field_set_allocated:mesos.URL.fragment)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Unavailability::kStartFieldNumber;
const int Unavailability::kDurationFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Unavailability::Unavailability()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Unavailability)
}

void Unavailability::InitAsDefaultInstance() {
  start_ = const_cast< ::mesos::TimeInfo*>(&::mesos::TimeInfo::default_instance());
  duration_ = const_cast< ::mesos::DurationInfo*>(&::mesos::DurationInfo::default_instance());
}

Unavailability::Unavailability(const Unavailability& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Unavailability)
}

void Unavailability::SharedCtor() {
  _cached_size_ = 0;
  start_ = NULL;
  duration_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Unavailability::~Unavailability() {
  // @@protoc_insertion_point(destructor:mesos.Unavailability)
  SharedDtor();
}

void Unavailability::SharedDtor() {
  if (this != default_instance_) {
    delete start_;
    delete duration_;
  }
}

void Unavailability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Unavailability::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Unavailability_descriptor_;
}

const Unavailability& Unavailability::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Unavailability* Unavailability::default_instance_ = NULL;

Unavailability* Unavailability::New(::google::protobuf::Arena* arena) const {
  Unavailability* n = new Unavailability;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Unavailability::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Unavailability)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_start()) {
      if (start_ != NULL) start_->::mesos::TimeInfo::Clear();
    }
    if (has_duration()) {
      if (duration_ != NULL) duration_->::mesos::DurationInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Unavailability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Unavailability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TimeInfo start = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_start()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_duration;
        break;
      }

      // optional .mesos.DurationInfo duration = 2;
      case 2: {
        if (tag == 18) {
         parse_duration:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_duration()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Unavailability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Unavailability)
  return false;
#undef DO_
}

void Unavailability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Unavailability)
  // required .mesos.TimeInfo start = 1;
  if (has_start()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->start_, output);
  }

  // optional .mesos.DurationInfo duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->duration_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Unavailability)
}

::google::protobuf::uint8* Unavailability::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Unavailability)
  // required .mesos.TimeInfo start = 1;
  if (has_start()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->start_, false, target);
  }

  // optional .mesos.DurationInfo duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->duration_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Unavailability)
  return target;
}

int Unavailability::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Unavailability)
  int total_size = 0;

  // required .mesos.TimeInfo start = 1;
  if (has_start()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->start_);
  }
  // optional .mesos.DurationInfo duration = 2;
  if (has_duration()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->duration_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Unavailability::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Unavailability)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Unavailability* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Unavailability>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Unavailability)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Unavailability)
    MergeFrom(*source);
  }
}

void Unavailability::MergeFrom(const Unavailability& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Unavailability)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_start()) {
      mutable_start()->::mesos::TimeInfo::MergeFrom(from.start());
    }
    if (from.has_duration()) {
      mutable_duration()->::mesos::DurationInfo::MergeFrom(from.duration());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Unavailability::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Unavailability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Unavailability::CopyFrom(const Unavailability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Unavailability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Unavailability::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_start()) {
    if (!this->start_->IsInitialized()) return false;
  }
  if (has_duration()) {
    if (!this->duration_->IsInitialized()) return false;
  }
  return true;
}

void Unavailability::Swap(Unavailability* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Unavailability::InternalSwap(Unavailability* other) {
  std::swap(start_, other->start_);
  std::swap(duration_, other->duration_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Unavailability::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Unavailability_descriptor_;
  metadata.reflection = Unavailability_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Unavailability

// required .mesos.TimeInfo start = 1;
bool Unavailability::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Unavailability::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
void Unavailability::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
void Unavailability::clear_start() {
  if (start_ != NULL) start_->::mesos::TimeInfo::Clear();
  clear_has_start();
}
const ::mesos::TimeInfo& Unavailability::start() const {
  // @@protoc_insertion_point(field_get:mesos.Unavailability.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
::mesos::TimeInfo* Unavailability::mutable_start() {
  set_has_start();
  if (start_ == NULL) {
    start_ = new ::mesos::TimeInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Unavailability.start)
  return start_;
}
::mesos::TimeInfo* Unavailability::release_start() {
  // @@protoc_insertion_point(field_release:mesos.Unavailability.start)
  clear_has_start();
  ::mesos::TimeInfo* temp = start_;
  start_ = NULL;
  return temp;
}
void Unavailability::set_allocated_start(::mesos::TimeInfo* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Unavailability.start)
}

// optional .mesos.DurationInfo duration = 2;
bool Unavailability::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Unavailability::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
void Unavailability::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
void Unavailability::clear_duration() {
  if (duration_ != NULL) duration_->::mesos::DurationInfo::Clear();
  clear_has_duration();
}
const ::mesos::DurationInfo& Unavailability::duration() const {
  // @@protoc_insertion_point(field_get:mesos.Unavailability.duration)
  return duration_ != NULL ? *duration_ : *default_instance_->duration_;
}
::mesos::DurationInfo* Unavailability::mutable_duration() {
  set_has_duration();
  if (duration_ == NULL) {
    duration_ = new ::mesos::DurationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Unavailability.duration)
  return duration_;
}
::mesos::DurationInfo* Unavailability::release_duration() {
  // @@protoc_insertion_point(field_release:mesos.Unavailability.duration)
  clear_has_duration();
  ::mesos::DurationInfo* temp = duration_;
  duration_ = NULL;
  return temp;
}
void Unavailability::set_allocated_duration(::mesos::DurationInfo* duration) {
  delete duration_;
  duration_ = duration;
  if (duration) {
    set_has_duration();
  } else {
    clear_has_duration();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Unavailability.duration)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MachineID::kHostnameFieldNumber;
const int MachineID::kIpFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MachineID::MachineID()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.MachineID)
}

void MachineID::InitAsDefaultInstance() {
}

MachineID::MachineID(const MachineID& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.MachineID)
}

void MachineID::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MachineID::~MachineID() {
  // @@protoc_insertion_point(destructor:mesos.MachineID)
  SharedDtor();
}

void MachineID::SharedDtor() {
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void MachineID::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MachineID::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineID_descriptor_;
}

const MachineID& MachineID::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

MachineID* MachineID::default_instance_ = NULL;

MachineID* MachineID::New(::google::protobuf::Arena* arena) const {
  MachineID* n = new MachineID;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MachineID::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.MachineID)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ip()) {
      ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MachineID::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.MachineID)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string hostname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.MachineID.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip;
        break;
      }

      // optional string ip = 2;
      case 2: {
        if (tag == 18) {
         parse_ip:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip().data(), this->ip().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.MachineID.ip");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.MachineID)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.MachineID)
  return false;
#undef DO_
}

void MachineID::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.MachineID)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MachineID.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MachineID.ip");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.MachineID)
}

::google::protobuf::uint8* MachineID::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.MachineID)
  // optional string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MachineID.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hostname(), target);
  }

  // optional string ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip().data(), this->ip().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MachineID.ip");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.MachineID)
  return target;
}

int MachineID::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.MachineID)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string hostname = 1;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string ip = 2;
    if (has_ip()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MachineID::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.MachineID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MachineID* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MachineID>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.MachineID)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.MachineID)
    MergeFrom(*source);
  }
}

void MachineID::MergeFrom(const MachineID& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.MachineID)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_ip()) {
      set_has_ip();
      ip_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MachineID::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.MachineID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MachineID::CopyFrom(const MachineID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.MachineID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineID::IsInitialized() const {

  return true;
}

void MachineID::Swap(MachineID* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MachineID::InternalSwap(MachineID* other) {
  hostname_.Swap(&other->hostname_);
  ip_.Swap(&other->ip_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MachineID::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MachineID_descriptor_;
  metadata.reflection = MachineID_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MachineID

// optional string hostname = 1;
bool MachineID::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MachineID::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
void MachineID::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
void MachineID::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& MachineID::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.MachineID.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MachineID::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.MachineID.hostname)
}
 void MachineID::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.MachineID.hostname)
}
 void MachineID::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.MachineID.hostname)
}
 ::std::string* MachineID::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.MachineID.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MachineID::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.MachineID.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MachineID::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineID.hostname)
}

// optional string ip = 2;
bool MachineID::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MachineID::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
void MachineID::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
void MachineID::clear_ip() {
  ip_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip();
}
 const ::std::string& MachineID::ip() const {
  // @@protoc_insertion_point(field_get:mesos.MachineID.ip)
  return ip_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MachineID::set_ip(const ::std::string& value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.MachineID.ip)
}
 void MachineID::set_ip(const char* value) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.MachineID.ip)
}
 void MachineID::set_ip(const char* value, size_t size) {
  set_has_ip();
  ip_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.MachineID.ip)
}
 ::std::string* MachineID::mutable_ip() {
  set_has_ip();
  // @@protoc_insertion_point(field_mutable:mesos.MachineID.ip)
  return ip_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MachineID::release_ip() {
  // @@protoc_insertion_point(field_release:mesos.MachineID.ip)
  clear_has_ip();
  return ip_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MachineID::set_allocated_ip(::std::string* ip) {
  if (ip != NULL) {
    set_has_ip();
  } else {
    clear_has_ip();
  }
  ip_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip);
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineID.ip)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* MachineInfo_Mode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineInfo_Mode_descriptor_;
}
bool MachineInfo_Mode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const MachineInfo_Mode MachineInfo::UP;
const MachineInfo_Mode MachineInfo::DRAINING;
const MachineInfo_Mode MachineInfo::DOWN;
const MachineInfo_Mode MachineInfo::Mode_MIN;
const MachineInfo_Mode MachineInfo::Mode_MAX;
const int MachineInfo::Mode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MachineInfo::kIdFieldNumber;
const int MachineInfo::kModeFieldNumber;
const int MachineInfo::kUnavailabilityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MachineInfo::MachineInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.MachineInfo)
}

void MachineInfo::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::MachineID*>(&::mesos::MachineID::default_instance());
  unavailability_ = const_cast< ::mesos::Unavailability*>(&::mesos::Unavailability::default_instance());
}

MachineInfo::MachineInfo(const MachineInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.MachineInfo)
}

void MachineInfo::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  mode_ = 1;
  unavailability_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MachineInfo::~MachineInfo() {
  // @@protoc_insertion_point(destructor:mesos.MachineInfo)
  SharedDtor();
}

void MachineInfo::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete unavailability_;
  }
}

void MachineInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MachineInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MachineInfo_descriptor_;
}

const MachineInfo& MachineInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

MachineInfo* MachineInfo::default_instance_ = NULL;

MachineInfo* MachineInfo::New(::google::protobuf::Arena* arena) const {
  MachineInfo* n = new MachineInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MachineInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.MachineInfo)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::MachineID::Clear();
    }
    mode_ = 1;
    if (has_unavailability()) {
      if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MachineInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.MachineInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.MachineID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_mode;
        break;
      }

      // optional .mesos.MachineInfo.Mode mode = 2;
      case 2: {
        if (tag == 16) {
         parse_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::MachineInfo_Mode_IsValid(value)) {
            set_mode(static_cast< ::mesos::MachineInfo_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_unavailability;
        break;
      }

      // optional .mesos.Unavailability unavailability = 3;
      case 3: {
        if (tag == 26) {
         parse_unavailability:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unavailability()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.MachineInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.MachineInfo)
  return false;
#undef DO_
}

void MachineInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.MachineInfo)
  // required .mesos.MachineID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // optional .mesos.MachineInfo.Mode mode = 2;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->mode(), output);
  }

  // optional .mesos.Unavailability unavailability = 3;
  if (has_unavailability()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->unavailability_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.MachineInfo)
}

::google::protobuf::uint8* MachineInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.MachineInfo)
  // required .mesos.MachineID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // optional .mesos.MachineInfo.Mode mode = 2;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->mode(), target);
  }

  // optional .mesos.Unavailability unavailability = 3;
  if (has_unavailability()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->unavailability_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.MachineInfo)
  return target;
}

int MachineInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.MachineInfo)
  int total_size = 0;

  // required .mesos.MachineID id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .mesos.MachineInfo.Mode mode = 2;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
    }

    // optional .mesos.Unavailability unavailability = 3;
    if (has_unavailability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->unavailability_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MachineInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.MachineInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MachineInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MachineInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.MachineInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.MachineInfo)
    MergeFrom(*source);
  }
}

void MachineInfo::MergeFrom(const MachineInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.MachineInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::mesos::MachineID::MergeFrom(from.id());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_unavailability()) {
      mutable_unavailability()->::mesos::Unavailability::MergeFrom(from.unavailability());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MachineInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.MachineInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MachineInfo::CopyFrom(const MachineInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.MachineInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MachineInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_unavailability()) {
    if (!this->unavailability_->IsInitialized()) return false;
  }
  return true;
}

void MachineInfo::Swap(MachineInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MachineInfo::InternalSwap(MachineInfo* other) {
  std::swap(id_, other->id_);
  std::swap(mode_, other->mode_);
  std::swap(unavailability_, other->unavailability_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MachineInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MachineInfo_descriptor_;
  metadata.reflection = MachineInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MachineInfo

// required .mesos.MachineID id = 1;
bool MachineInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MachineInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void MachineInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void MachineInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::MachineID::Clear();
  clear_has_id();
}
const ::mesos::MachineID& MachineInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::mesos::MachineID* MachineInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::mesos::MachineID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MachineInfo.id)
  return id_;
}
::mesos::MachineID* MachineInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.MachineInfo.id)
  clear_has_id();
  ::mesos::MachineID* temp = id_;
  id_ = NULL;
  return temp;
}
void MachineInfo::set_allocated_id(::mesos::MachineID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineInfo.id)
}

// optional .mesos.MachineInfo.Mode mode = 2;
bool MachineInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MachineInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000002u;
}
void MachineInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000002u;
}
void MachineInfo::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
 ::mesos::MachineInfo_Mode MachineInfo::mode() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.mode)
  return static_cast< ::mesos::MachineInfo_Mode >(mode_);
}
 void MachineInfo::set_mode(::mesos::MachineInfo_Mode value) {
  assert(::mesos::MachineInfo_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.MachineInfo.mode)
}

// optional .mesos.Unavailability unavailability = 3;
bool MachineInfo::has_unavailability() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MachineInfo::set_has_unavailability() {
  _has_bits_[0] |= 0x00000004u;
}
void MachineInfo::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000004u;
}
void MachineInfo::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
  clear_has_unavailability();
}
const ::mesos::Unavailability& MachineInfo::unavailability() const {
  // @@protoc_insertion_point(field_get:mesos.MachineInfo.unavailability)
  return unavailability_ != NULL ? *unavailability_ : *default_instance_->unavailability_;
}
::mesos::Unavailability* MachineInfo::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) {
    unavailability_ = new ::mesos::Unavailability;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MachineInfo.unavailability)
  return unavailability_;
}
::mesos::Unavailability* MachineInfo::release_unavailability() {
  // @@protoc_insertion_point(field_release:mesos.MachineInfo.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
void MachineInfo::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  delete unavailability_;
  unavailability_ = unavailability;
  if (unavailability) {
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MachineInfo.unavailability)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* FrameworkInfo_Capability_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInfo_Capability_Type_descriptor_;
}
bool FrameworkInfo_Capability_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::UNKNOWN;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::REVOCABLE_RESOURCES;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::TASK_KILLING_STATE;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::GPU_RESOURCES;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::SHARED_RESOURCES;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::PARTITION_AWARE;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::MULTI_ROLE;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::Type_MIN;
const FrameworkInfo_Capability_Type FrameworkInfo_Capability::Type_MAX;
const int FrameworkInfo_Capability::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FrameworkInfo_Capability::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FrameworkInfo_Capability::FrameworkInfo_Capability()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FrameworkInfo.Capability)
}

void FrameworkInfo_Capability::InitAsDefaultInstance() {
}

FrameworkInfo_Capability::FrameworkInfo_Capability(const FrameworkInfo_Capability& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FrameworkInfo.Capability)
}

void FrameworkInfo_Capability::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkInfo_Capability::~FrameworkInfo_Capability() {
  // @@protoc_insertion_point(destructor:mesos.FrameworkInfo.Capability)
  SharedDtor();
}

void FrameworkInfo_Capability::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FrameworkInfo_Capability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkInfo_Capability::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInfo_Capability_descriptor_;
}

const FrameworkInfo_Capability& FrameworkInfo_Capability::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FrameworkInfo_Capability* FrameworkInfo_Capability::default_instance_ = NULL;

FrameworkInfo_Capability* FrameworkInfo_Capability::New(::google::protobuf::Arena* arena) const {
  FrameworkInfo_Capability* n = new FrameworkInfo_Capability;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FrameworkInfo_Capability::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.FrameworkInfo.Capability)
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FrameworkInfo_Capability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FrameworkInfo.Capability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.FrameworkInfo.Capability.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::FrameworkInfo_Capability_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::FrameworkInfo_Capability_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FrameworkInfo.Capability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FrameworkInfo.Capability)
  return false;
#undef DO_
}

void FrameworkInfo_Capability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FrameworkInfo.Capability)
  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FrameworkInfo.Capability)
}

::google::protobuf::uint8* FrameworkInfo_Capability::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FrameworkInfo.Capability)
  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FrameworkInfo.Capability)
  return target;
}

int FrameworkInfo_Capability::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.FrameworkInfo.Capability)
  int total_size = 0;

  // optional .mesos.FrameworkInfo.Capability.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkInfo_Capability::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.FrameworkInfo.Capability)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FrameworkInfo_Capability* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FrameworkInfo_Capability>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.FrameworkInfo.Capability)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.FrameworkInfo.Capability)
    MergeFrom(*source);
  }
}

void FrameworkInfo_Capability::MergeFrom(const FrameworkInfo_Capability& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.FrameworkInfo.Capability)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FrameworkInfo_Capability::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.FrameworkInfo.Capability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkInfo_Capability::CopyFrom(const FrameworkInfo_Capability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.FrameworkInfo.Capability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkInfo_Capability::IsInitialized() const {

  return true;
}

void FrameworkInfo_Capability::Swap(FrameworkInfo_Capability* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FrameworkInfo_Capability::InternalSwap(FrameworkInfo_Capability* other) {
  std::swap(type_, other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FrameworkInfo_Capability::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkInfo_Capability_descriptor_;
  metadata.reflection = FrameworkInfo_Capability_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

::std::string* FrameworkInfo::_default_role_ = NULL;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FrameworkInfo::kUserFieldNumber;
const int FrameworkInfo::kNameFieldNumber;
const int FrameworkInfo::kCPUSPERTASKFieldNumber;
const int FrameworkInfo::kMEMPERTASKFieldNumber;
const int FrameworkInfo::kGPUSFieldNumber;
const int FrameworkInfo::kDISKFieldNumber;
const int FrameworkInfo::kIdFieldNumber;
const int FrameworkInfo::kFailoverTimeoutFieldNumber;
const int FrameworkInfo::kCheckpointFieldNumber;
const int FrameworkInfo::kRoleFieldNumber;
const int FrameworkInfo::kRolesFieldNumber;
const int FrameworkInfo::kHostnameFieldNumber;
const int FrameworkInfo::kPrincipalFieldNumber;
const int FrameworkInfo::kWebuiUrlFieldNumber;
const int FrameworkInfo::kCapabilitiesFieldNumber;
const int FrameworkInfo::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FrameworkInfo::FrameworkInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FrameworkInfo)
}

void FrameworkInfo::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

FrameworkInfo::FrameworkInfo(const FrameworkInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FrameworkInfo)
}

void FrameworkInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  user_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cpus_per_task_ = 0;
  mem_per_task_ = 0;
  gpus_ = 0;
  disk_ = 0;
  id_ = NULL;
  failover_timeout_ = 0;
  checkpoint_ = false;
  role_.UnsafeSetDefault(_default_role_);
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  webui_url_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FrameworkInfo::~FrameworkInfo() {
  // @@protoc_insertion_point(destructor:mesos.FrameworkInfo)
  SharedDtor();
}

void FrameworkInfo::SharedDtor() {
  user_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  role_.DestroyNoArena(_default_role_);
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  principal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  webui_url_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete id_;
    delete labels_;
  }
}

void FrameworkInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FrameworkInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FrameworkInfo_descriptor_;
}

const FrameworkInfo& FrameworkInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FrameworkInfo* FrameworkInfo::default_instance_ = NULL;

FrameworkInfo* FrameworkInfo::New(::google::protobuf::Arena* arena) const {
  FrameworkInfo* n = new FrameworkInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FrameworkInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.FrameworkInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(FrameworkInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<FrameworkInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(cpus_per_task_, disk_);
    if (has_user()) {
      user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
    }
    failover_timeout_ = 0;
  }
  if (_has_bits_[8 / 32] & 47872u) {
    checkpoint_ = false;
    if (has_role()) {
      role_.ClearToDefaultNoArena(_default_role_);
    }
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_principal()) {
      principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_webui_url()) {
      webui_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  roles_.Clear();
  capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FrameworkInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FrameworkInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string user = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_CPUS_PER_TASK;
        break;
      }

      // required float CPUS_PER_TASK = 3;
      case 3: {
        if (tag == 29) {
         parse_CPUS_PER_TASK:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &cpus_per_task_)));
          set_has_cpus_per_task();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_MEM_PER_TASK;
        break;
      }

      // required float MEM_PER_TASK = 4;
      case 4: {
        if (tag == 37) {
         parse_MEM_PER_TASK:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &mem_per_task_)));
          set_has_mem_per_task();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(45)) goto parse_GPUS;
        break;
      }

      // optional float GPUS = 5;
      case 5: {
        if (tag == 45) {
         parse_GPUS:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &gpus_)));
          set_has_gpus();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_role;
        break;
      }

      // optional string role = 6 [default = "*", deprecated = true];
      case 6: {
        if (tag == 50) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_DISK;
        break;
      }

      // optional float DISK = 7;
      case 7: {
        if (tag == 61) {
         parse_DISK:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &disk_)));
          set_has_disk();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_id;
        break;
      }

      // optional .mesos.FrameworkID id = 8;
      case 8: {
        if (tag == 66) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_failover_timeout;
        break;
      }

      // optional double failover_timeout = 9 [default = 0];
      case 9: {
        if (tag == 73) {
         parse_failover_timeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &failover_timeout_)));
          set_has_failover_timeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_checkpoint;
        break;
      }

      // optional bool checkpoint = 10 [default = false];
      case 10: {
        if (tag == 80) {
         parse_checkpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkpoint_)));
          set_has_checkpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_hostname;
        break;
      }

      // optional string hostname = 11;
      case 11: {
        if (tag == 90) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_roles;
        break;
      }

      // repeated string roles = 12;
      case 12: {
        if (tag == 98) {
         parse_roles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_roles()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->roles(this->roles_size() - 1).data(),
            this->roles(this->roles_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.roles");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_roles;
        if (input->ExpectTag(106)) goto parse_principal;
        break;
      }

      // optional string principal = 13;
      case 13: {
        if (tag == 106) {
         parse_principal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_webui_url;
        break;
      }

      // optional string webui_url = 14;
      case 14: {
        if (tag == 114) {
         parse_webui_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_webui_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->webui_url().data(), this->webui_url().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FrameworkInfo.webui_url");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_capabilities;
        break;
      }

      // repeated .mesos.FrameworkInfo.Capability capabilities = 15;
      case 15: {
        if (tag == 122) {
         parse_capabilities:
          DO_(input->IncrementRecursionDepth());
         parse_loop_capabilities:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_capabilities()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_loop_capabilities;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(130)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 16;
      case 16: {
        if (tag == 130) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FrameworkInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FrameworkInfo)
  return false;
#undef DO_
}

void FrameworkInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FrameworkInfo)
  // required string user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->user(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // required float CPUS_PER_TASK = 3;
  if (has_cpus_per_task()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->cpus_per_task(), output);
  }

  // required float MEM_PER_TASK = 4;
  if (has_mem_per_task()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->mem_per_task(), output);
  }

  // optional float GPUS = 5;
  if (has_gpus()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(5, this->gpus(), output);
  }

  // optional string role = 6 [default = "*", deprecated = true];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->role(), output);
  }

  // optional float DISK = 7;
  if (has_disk()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->disk(), output);
  }

  // optional .mesos.FrameworkID id = 8;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->id_, output);
  }

  // optional double failover_timeout = 9 [default = 0];
  if (has_failover_timeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->failover_timeout(), output);
  }

  // optional bool checkpoint = 10 [default = false];
  if (has_checkpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(10, this->checkpoint(), output);
  }

  // optional string hostname = 11;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      11, this->hostname(), output);
  }

  // repeated string roles = 12;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->roles(i).data(), this->roles(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.roles");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      12, this->roles(i), output);
  }

  // optional string principal = 13;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      13, this->principal(), output);
  }

  // optional string webui_url = 14;
  if (has_webui_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->webui_url().data(), this->webui_url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.webui_url");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->webui_url(), output);
  }

  // repeated .mesos.FrameworkInfo.Capability capabilities = 15;
  for (unsigned int i = 0, n = this->capabilities_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, this->capabilities(i), output);
  }

  // optional .mesos.Labels labels = 16;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      16, *this->labels_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FrameworkInfo)
}

::google::protobuf::uint8* FrameworkInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FrameworkInfo)
  // required string user = 1;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->user(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // required float CPUS_PER_TASK = 3;
  if (has_cpus_per_task()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->cpus_per_task(), target);
  }

  // required float MEM_PER_TASK = 4;
  if (has_mem_per_task()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->mem_per_task(), target);
  }

  // optional float GPUS = 5;
  if (has_gpus()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(5, this->gpus(), target);
  }

  // optional string role = 6 [default = "*", deprecated = true];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->role(), target);
  }

  // optional float DISK = 7;
  if (has_disk()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->disk(), target);
  }

  // optional .mesos.FrameworkID id = 8;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->id_, false, target);
  }

  // optional double failover_timeout = 9 [default = 0];
  if (has_failover_timeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->failover_timeout(), target);
  }

  // optional bool checkpoint = 10 [default = false];
  if (has_checkpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(10, this->checkpoint(), target);
  }

  // optional string hostname = 11;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        11, this->hostname(), target);
  }

  // repeated string roles = 12;
  for (int i = 0; i < this->roles_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->roles(i).data(), this->roles(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.roles");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(12, this->roles(i), target);
  }

  // optional string principal = 13;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        13, this->principal(), target);
  }

  // optional string webui_url = 14;
  if (has_webui_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->webui_url().data(), this->webui_url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FrameworkInfo.webui_url");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->webui_url(), target);
  }

  // repeated .mesos.FrameworkInfo.Capability capabilities = 15;
  for (unsigned int i = 0, n = this->capabilities_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        15, this->capabilities(i), false, target);
  }

  // optional .mesos.Labels labels = 16;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        16, *this->labels_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FrameworkInfo)
  return target;
}

int FrameworkInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.FrameworkInfo)
  int total_size = 0;

  if (has_user()) {
    // required string user = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user());
  }

  if (has_name()) {
    // required string name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_cpus_per_task()) {
    // required float CPUS_PER_TASK = 3;
    total_size += 1 + 4;
  }

  if (has_mem_per_task()) {
    // required float MEM_PER_TASK = 4;
    total_size += 1 + 4;
  }

  return total_size;
}
int FrameworkInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.FrameworkInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required string user = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->user());

    // required string name = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required float CPUS_PER_TASK = 3;
    total_size += 1 + 4;

    // required float MEM_PER_TASK = 4;
    total_size += 1 + 4;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[4 / 32] & 240u) {
    // optional float GPUS = 5;
    if (has_gpus()) {
      total_size += 1 + 4;
    }

    // optional float DISK = 7;
    if (has_disk()) {
      total_size += 1 + 4;
    }

    // optional .mesos.FrameworkID id = 8;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional double failover_timeout = 9 [default = 0];
    if (has_failover_timeout()) {
      total_size += 1 + 8;
    }

  }
  if (_has_bits_[8 / 32] & 47872u) {
    // optional bool checkpoint = 10 [default = false];
    if (has_checkpoint()) {
      total_size += 1 + 1;
    }

    // optional string role = 6 [default = "*", deprecated = true];
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }

    // optional string hostname = 11;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string principal = 13;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

    // optional string webui_url = 14;
    if (has_webui_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->webui_url());
    }

    // optional .mesos.Labels labels = 16;
    if (has_labels()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  // repeated string roles = 12;
  total_size += 1 * this->roles_size();
  for (int i = 0; i < this->roles_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->roles(i));
  }

  // repeated .mesos.FrameworkInfo.Capability capabilities = 15;
  total_size += 1 * this->capabilities_size();
  for (int i = 0; i < this->capabilities_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->capabilities(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FrameworkInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.FrameworkInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FrameworkInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FrameworkInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.FrameworkInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.FrameworkInfo)
    MergeFrom(*source);
  }
}

void FrameworkInfo::MergeFrom(const FrameworkInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.FrameworkInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  roles_.MergeFrom(from.roles_);
  capabilities_.MergeFrom(from.capabilities_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_user()) {
      set_has_user();
      user_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_);
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_cpus_per_task()) {
      set_cpus_per_task(from.cpus_per_task());
    }
    if (from.has_mem_per_task()) {
      set_mem_per_task(from.mem_per_task());
    }
    if (from.has_gpus()) {
      set_gpus(from.gpus());
    }
    if (from.has_disk()) {
      set_disk(from.disk());
    }
    if (from.has_id()) {
      mutable_id()->::mesos::FrameworkID::MergeFrom(from.id());
    }
    if (from.has_failover_timeout()) {
      set_failover_timeout(from.failover_timeout());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_checkpoint()) {
      set_checkpoint(from.checkpoint());
    }
    if (from.has_role()) {
      set_has_role();
      role_.AssignWithDefault(_default_role_, from.role_);
    }
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_principal()) {
      set_has_principal();
      principal_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.principal_);
    }
    if (from.has_webui_url()) {
      set_has_webui_url();
      webui_url_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.webui_url_);
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FrameworkInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.FrameworkInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FrameworkInfo::CopyFrom(const FrameworkInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.FrameworkInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FrameworkInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void FrameworkInfo::Swap(FrameworkInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FrameworkInfo::InternalSwap(FrameworkInfo* other) {
  user_.Swap(&other->user_);
  name_.Swap(&other->name_);
  std::swap(cpus_per_task_, other->cpus_per_task_);
  std::swap(mem_per_task_, other->mem_per_task_);
  std::swap(gpus_, other->gpus_);
  std::swap(disk_, other->disk_);
  std::swap(id_, other->id_);
  std::swap(failover_timeout_, other->failover_timeout_);
  std::swap(checkpoint_, other->checkpoint_);
  role_.Swap(&other->role_);
  roles_.UnsafeArenaSwap(&other->roles_);
  hostname_.Swap(&other->hostname_);
  principal_.Swap(&other->principal_);
  webui_url_.Swap(&other->webui_url_);
  capabilities_.UnsafeArenaSwap(&other->capabilities_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FrameworkInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FrameworkInfo_descriptor_;
  metadata.reflection = FrameworkInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FrameworkInfo_Capability

// optional .mesos.FrameworkInfo.Capability.Type type = 1;
bool FrameworkInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FrameworkInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void FrameworkInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void FrameworkInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::FrameworkInfo_Capability_Type FrameworkInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.Capability.type)
  return static_cast< ::mesos::FrameworkInfo_Capability_Type >(type_);
}
 void FrameworkInfo_Capability::set_type(::mesos::FrameworkInfo_Capability_Type value) {
  assert(::mesos::FrameworkInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.Capability.type)
}

// -------------------------------------------------------------------

// FrameworkInfo

// required string user = 1;
bool FrameworkInfo::has_user() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FrameworkInfo::set_has_user() {
  _has_bits_[0] |= 0x00000001u;
}
void FrameworkInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000001u;
}
void FrameworkInfo::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
 const ::std::string& FrameworkInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.user)
}
 void FrameworkInfo::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.user)
}
 void FrameworkInfo::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.user)
}
 ::std::string* FrameworkInfo::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameworkInfo::release_user() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.user)
}

// required string name = 2;
bool FrameworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FrameworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void FrameworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void FrameworkInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& FrameworkInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.name)
}
 void FrameworkInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.name)
}
 void FrameworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.name)
}
 ::std::string* FrameworkInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameworkInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.name)
}

// required float CPUS_PER_TASK = 3;
bool FrameworkInfo::has_cpus_per_task() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FrameworkInfo::set_has_cpus_per_task() {
  _has_bits_[0] |= 0x00000004u;
}
void FrameworkInfo::clear_has_cpus_per_task() {
  _has_bits_[0] &= ~0x00000004u;
}
void FrameworkInfo::clear_cpus_per_task() {
  cpus_per_task_ = 0;
  clear_has_cpus_per_task();
}
 float FrameworkInfo::cpus_per_task() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.CPUS_PER_TASK)
  return cpus_per_task_;
}
 void FrameworkInfo::set_cpus_per_task(float value) {
  set_has_cpus_per_task();
  cpus_per_task_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.CPUS_PER_TASK)
}

// required float MEM_PER_TASK = 4;
bool FrameworkInfo::has_mem_per_task() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FrameworkInfo::set_has_mem_per_task() {
  _has_bits_[0] |= 0x00000008u;
}
void FrameworkInfo::clear_has_mem_per_task() {
  _has_bits_[0] &= ~0x00000008u;
}
void FrameworkInfo::clear_mem_per_task() {
  mem_per_task_ = 0;
  clear_has_mem_per_task();
}
 float FrameworkInfo::mem_per_task() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.MEM_PER_TASK)
  return mem_per_task_;
}
 void FrameworkInfo::set_mem_per_task(float value) {
  set_has_mem_per_task();
  mem_per_task_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.MEM_PER_TASK)
}

// optional float GPUS = 5;
bool FrameworkInfo::has_gpus() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FrameworkInfo::set_has_gpus() {
  _has_bits_[0] |= 0x00000010u;
}
void FrameworkInfo::clear_has_gpus() {
  _has_bits_[0] &= ~0x00000010u;
}
void FrameworkInfo::clear_gpus() {
  gpus_ = 0;
  clear_has_gpus();
}
 float FrameworkInfo::gpus() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.GPUS)
  return gpus_;
}
 void FrameworkInfo::set_gpus(float value) {
  set_has_gpus();
  gpus_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.GPUS)
}

// optional float DISK = 7;
bool FrameworkInfo::has_disk() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FrameworkInfo::set_has_disk() {
  _has_bits_[0] |= 0x00000020u;
}
void FrameworkInfo::clear_has_disk() {
  _has_bits_[0] &= ~0x00000020u;
}
void FrameworkInfo::clear_disk() {
  disk_ = 0;
  clear_has_disk();
}
 float FrameworkInfo::disk() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.DISK)
  return disk_;
}
 void FrameworkInfo::set_disk(float value) {
  set_has_disk();
  disk_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.DISK)
}

// optional .mesos.FrameworkID id = 8;
bool FrameworkInfo::has_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void FrameworkInfo::set_has_id() {
  _has_bits_[0] |= 0x00000040u;
}
void FrameworkInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000040u;
}
void FrameworkInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::FrameworkID::Clear();
  clear_has_id();
}
const ::mesos::FrameworkID& FrameworkInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::mesos::FrameworkID* FrameworkInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.id)
  return id_;
}
::mesos::FrameworkID* FrameworkInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.id)
  clear_has_id();
  ::mesos::FrameworkID* temp = id_;
  id_ = NULL;
  return temp;
}
void FrameworkInfo::set_allocated_id(::mesos::FrameworkID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.id)
}

// optional double failover_timeout = 9 [default = 0];
bool FrameworkInfo::has_failover_timeout() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void FrameworkInfo::set_has_failover_timeout() {
  _has_bits_[0] |= 0x00000080u;
}
void FrameworkInfo::clear_has_failover_timeout() {
  _has_bits_[0] &= ~0x00000080u;
}
void FrameworkInfo::clear_failover_timeout() {
  failover_timeout_ = 0;
  clear_has_failover_timeout();
}
 double FrameworkInfo::failover_timeout() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.failover_timeout)
  return failover_timeout_;
}
 void FrameworkInfo::set_failover_timeout(double value) {
  set_has_failover_timeout();
  failover_timeout_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.failover_timeout)
}

// optional bool checkpoint = 10 [default = false];
bool FrameworkInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void FrameworkInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000100u;
}
void FrameworkInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000100u;
}
void FrameworkInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
 bool FrameworkInfo::checkpoint() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.checkpoint)
  return checkpoint_;
}
 void FrameworkInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.checkpoint)
}

// optional string role = 6 [default = "*", deprecated = true];
bool FrameworkInfo::has_role() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void FrameworkInfo::set_has_role() {
  _has_bits_[0] |= 0x00000200u;
}
void FrameworkInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000200u;
}
void FrameworkInfo::clear_role() {
  role_.ClearToDefaultNoArena(_default_role_);
  clear_has_role();
}
 const ::std::string& FrameworkInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.role)
  return role_.GetNoArena(_default_role_);
}
 void FrameworkInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.SetNoArena(_default_role_, value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.role)
}
 void FrameworkInfo::set_role(const char* value) {
  set_has_role();
  role_.SetNoArena(_default_role_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.role)
}
 void FrameworkInfo::set_role(const char* value, size_t size) {
  set_has_role();
  role_.SetNoArena(_default_role_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.role)
}
 ::std::string* FrameworkInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.role)
  return role_.MutableNoArena(_default_role_);
}
 ::std::string* FrameworkInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.role)
  clear_has_role();
  return role_.ReleaseNoArena(_default_role_);
}
 void FrameworkInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocatedNoArena(_default_role_, role);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.role)
}

// repeated string roles = 12;
int FrameworkInfo::roles_size() const {
  return roles_.size();
}
void FrameworkInfo::clear_roles() {
  roles_.Clear();
}
 const ::std::string& FrameworkInfo::roles(int index) const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.roles)
  return roles_.Get(index);
}
 ::std::string* FrameworkInfo::mutable_roles(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.roles)
  return roles_.Mutable(index);
}
 void FrameworkInfo::set_roles(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.roles)
  roles_.Mutable(index)->assign(value);
}
 void FrameworkInfo::set_roles(int index, const char* value) {
  roles_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.roles)
}
 void FrameworkInfo::set_roles(int index, const char* value, size_t size) {
  roles_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.roles)
}
 ::std::string* FrameworkInfo::add_roles() {
  // @@protoc_insertion_point(field_add_mutable:mesos.FrameworkInfo.roles)
  return roles_.Add();
}
 void FrameworkInfo::add_roles(const ::std::string& value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.roles)
}
 void FrameworkInfo::add_roles(const char* value) {
  roles_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.FrameworkInfo.roles)
}
 void FrameworkInfo::add_roles(const char* value, size_t size) {
  roles_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.FrameworkInfo.roles)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
FrameworkInfo::roles() const {
  // @@protoc_insertion_point(field_list:mesos.FrameworkInfo.roles)
  return roles_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
FrameworkInfo::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:mesos.FrameworkInfo.roles)
  return &roles_;
}

// optional string hostname = 11;
bool FrameworkInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void FrameworkInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000800u;
}
void FrameworkInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000800u;
}
void FrameworkInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& FrameworkInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.hostname)
}
 void FrameworkInfo::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.hostname)
}
 void FrameworkInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.hostname)
}
 ::std::string* FrameworkInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameworkInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.hostname)
}

// optional string principal = 13;
bool FrameworkInfo::has_principal() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void FrameworkInfo::set_has_principal() {
  _has_bits_[0] |= 0x00001000u;
}
void FrameworkInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00001000u;
}
void FrameworkInfo::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_principal();
}
 const ::std::string& FrameworkInfo::principal() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.principal)
  return principal_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.principal)
}
 void FrameworkInfo::set_principal(const char* value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.principal)
}
 void FrameworkInfo::set_principal(const char* value, size_t size) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.principal)
}
 ::std::string* FrameworkInfo::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameworkInfo::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.principal)
  clear_has_principal();
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.principal)
}

// optional string webui_url = 14;
bool FrameworkInfo::has_webui_url() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void FrameworkInfo::set_has_webui_url() {
  _has_bits_[0] |= 0x00002000u;
}
void FrameworkInfo::clear_has_webui_url() {
  _has_bits_[0] &= ~0x00002000u;
}
void FrameworkInfo::clear_webui_url() {
  webui_url_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_webui_url();
}
 const ::std::string& FrameworkInfo::webui_url() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.webui_url)
  return webui_url_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_webui_url(const ::std::string& value) {
  set_has_webui_url();
  webui_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FrameworkInfo.webui_url)
}
 void FrameworkInfo::set_webui_url(const char* value) {
  set_has_webui_url();
  webui_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FrameworkInfo.webui_url)
}
 void FrameworkInfo::set_webui_url(const char* value, size_t size) {
  set_has_webui_url();
  webui_url_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FrameworkInfo.webui_url)
}
 ::std::string* FrameworkInfo::mutable_webui_url() {
  set_has_webui_url();
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.webui_url)
  return webui_url_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FrameworkInfo::release_webui_url() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.webui_url)
  clear_has_webui_url();
  return webui_url_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FrameworkInfo::set_allocated_webui_url(::std::string* webui_url) {
  if (webui_url != NULL) {
    set_has_webui_url();
  } else {
    clear_has_webui_url();
  }
  webui_url_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), webui_url);
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.webui_url)
}

// repeated .mesos.FrameworkInfo.Capability capabilities = 15;
int FrameworkInfo::capabilities_size() const {
  return capabilities_.size();
}
void FrameworkInfo::clear_capabilities() {
  capabilities_.Clear();
}
const ::mesos::FrameworkInfo_Capability& FrameworkInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.capabilities)
  return capabilities_.Get(index);
}
::mesos::FrameworkInfo_Capability* FrameworkInfo::mutable_capabilities(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.capabilities)
  return capabilities_.Mutable(index);
}
::mesos::FrameworkInfo_Capability* FrameworkInfo::add_capabilities() {
  // @@protoc_insertion_point(field_add:mesos.FrameworkInfo.capabilities)
  return capabilities_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >*
FrameworkInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.FrameworkInfo.capabilities)
  return &capabilities_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkInfo_Capability >&
FrameworkInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.FrameworkInfo.capabilities)
  return capabilities_;
}

// optional .mesos.Labels labels = 16;
bool FrameworkInfo::has_labels() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void FrameworkInfo::set_has_labels() {
  _has_bits_[0] |= 0x00008000u;
}
void FrameworkInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00008000u;
}
void FrameworkInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& FrameworkInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.FrameworkInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* FrameworkInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FrameworkInfo.labels)
  return labels_;
}
::mesos::Labels* FrameworkInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.FrameworkInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void FrameworkInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FrameworkInfo.labels)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* CheckInfo_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Type_descriptor_;
}
bool CheckInfo_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const CheckInfo_Type CheckInfo::UNKNOWN;
const CheckInfo_Type CheckInfo::COMMAND;
const CheckInfo_Type CheckInfo::HTTP;
const CheckInfo_Type CheckInfo::Type_MIN;
const CheckInfo_Type CheckInfo::Type_MAX;
const int CheckInfo::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckInfo_Command::kCommandFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckInfo_Command::CheckInfo_Command()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo.Command)
}

void CheckInfo_Command::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
}

CheckInfo_Command::CheckInfo_Command(const CheckInfo_Command& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo.Command)
}

void CheckInfo_Command::SharedCtor() {
  _cached_size_ = 0;
  command_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo_Command::~CheckInfo_Command() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo.Command)
  SharedDtor();
}

void CheckInfo_Command::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
  }
}

void CheckInfo_Command::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo_Command::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Command_descriptor_;
}

const CheckInfo_Command& CheckInfo_Command::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo_Command* CheckInfo_Command::default_instance_ = NULL;

CheckInfo_Command* CheckInfo_Command::New(::google::protobuf::Arena* arena) const {
  CheckInfo_Command* n = new CheckInfo_Command;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckInfo_Command::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CheckInfo.Command)
  if (has_command()) {
    if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckInfo_Command::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo.Command)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.CommandInfo command = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo.Command)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo.Command)
  return false;
#undef DO_
}

void CheckInfo_Command::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo.Command)
  // required .mesos.CommandInfo command = 1;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->command_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo.Command)
}

::google::protobuf::uint8* CheckInfo_Command::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo.Command)
  // required .mesos.CommandInfo command = 1;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->command_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo.Command)
  return target;
}

int CheckInfo_Command::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CheckInfo.Command)
  int total_size = 0;

  // required .mesos.CommandInfo command = 1;
  if (has_command()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->command_);
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo_Command::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CheckInfo.Command)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CheckInfo_Command* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckInfo_Command>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CheckInfo.Command)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CheckInfo.Command)
    MergeFrom(*source);
  }
}

void CheckInfo_Command::MergeFrom(const CheckInfo_Command& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CheckInfo.Command)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckInfo_Command::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CheckInfo.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo_Command::CopyFrom(const CheckInfo_Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CheckInfo.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo_Command::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_command()) {
    if (!this->command_->IsInitialized()) return false;
  }
  return true;
}

void CheckInfo_Command::Swap(CheckInfo_Command* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckInfo_Command::InternalSwap(CheckInfo_Command* other) {
  std::swap(command_, other->command_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckInfo_Command::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_Command_descriptor_;
  metadata.reflection = CheckInfo_Command_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckInfo_Http::kPortFieldNumber;
const int CheckInfo_Http::kPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckInfo_Http::CheckInfo_Http()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo.Http)
}

void CheckInfo_Http::InitAsDefaultInstance() {
}

CheckInfo_Http::CheckInfo_Http(const CheckInfo_Http& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo.Http)
}

void CheckInfo_Http::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  port_ = 0u;
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo_Http::~CheckInfo_Http() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo.Http)
  SharedDtor();
}

void CheckInfo_Http::SharedDtor() {
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void CheckInfo_Http::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo_Http::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_Http_descriptor_;
}

const CheckInfo_Http& CheckInfo_Http::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo_Http* CheckInfo_Http::default_instance_ = NULL;

CheckInfo_Http* CheckInfo_Http::New(::google::protobuf::Arena* arena) const {
  CheckInfo_Http* n = new CheckInfo_Http;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckInfo_Http::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CheckInfo.Http)
  if (_has_bits_[0 / 32] & 3u) {
    port_ = 0u;
    if (has_path()) {
      path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckInfo_Http::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo.Http)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // optional string path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.CheckInfo.Http.path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo.Http)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo.Http)
  return false;
#undef DO_
}

void CheckInfo_Http::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo.Http)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CheckInfo.Http.path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo.Http)
}

::google::protobuf::uint8* CheckInfo_Http::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo.Http)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CheckInfo.Http.path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo.Http)
  return target;
}

int CheckInfo_Http::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CheckInfo.Http)
  int total_size = 0;

  // required uint32 port = 1;
  if (has_port()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }
  // optional string path = 2;
  if (has_path()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->path());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo_Http::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CheckInfo.Http)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CheckInfo_Http* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckInfo_Http>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CheckInfo.Http)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CheckInfo.Http)
    MergeFrom(*source);
  }
}

void CheckInfo_Http::MergeFrom(const CheckInfo_Http& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CheckInfo.Http)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_path()) {
      set_has_path();
      path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckInfo_Http::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CheckInfo.Http)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo_Http::CopyFrom(const CheckInfo_Http& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CheckInfo.Http)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo_Http::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CheckInfo_Http::Swap(CheckInfo_Http* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckInfo_Http::InternalSwap(CheckInfo_Http* other) {
  std::swap(port_, other->port_);
  path_.Swap(&other->path_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckInfo_Http::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_Http_descriptor_;
  metadata.reflection = CheckInfo_Http_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckInfo::kTypeFieldNumber;
const int CheckInfo::kCommandFieldNumber;
const int CheckInfo::kHttpFieldNumber;
const int CheckInfo::kDelaySecondsFieldNumber;
const int CheckInfo::kIntervalSecondsFieldNumber;
const int CheckInfo::kTimeoutSecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckInfo::CheckInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckInfo)
}

void CheckInfo::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CheckInfo_Command*>(&::mesos::CheckInfo_Command::default_instance());
  http_ = const_cast< ::mesos::CheckInfo_Http*>(&::mesos::CheckInfo_Http::default_instance());
}

CheckInfo::CheckInfo(const CheckInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckInfo)
}

void CheckInfo::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  command_ = NULL;
  http_ = NULL;
  delay_seconds_ = 15;
  interval_seconds_ = 10;
  timeout_seconds_ = 20;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckInfo::~CheckInfo() {
  // @@protoc_insertion_point(destructor:mesos.CheckInfo)
  SharedDtor();
}

void CheckInfo::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
    delete http_;
  }
}

void CheckInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckInfo_descriptor_;
}

const CheckInfo& CheckInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckInfo* CheckInfo::default_instance_ = NULL;

CheckInfo* CheckInfo::New(::google::protobuf::Arena* arena) const {
  CheckInfo* n = new CheckInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CheckInfo)
  if (_has_bits_[0 / 32] & 63u) {
    type_ = 0;
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CheckInfo_Command::Clear();
    }
    if (has_http()) {
      if (http_ != NULL) http_->::mesos::CheckInfo_Http::Clear();
    }
    delay_seconds_ = 15;
    interval_seconds_ = 10;
    timeout_seconds_ = 20;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CheckInfo.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::CheckInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::CheckInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_command;
        break;
      }

      // optional .mesos.CheckInfo.Command command = 2;
      case 2: {
        if (tag == 18) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_http;
        break;
      }

      // optional .mesos.CheckInfo.Http http = 3;
      case 3: {
        if (tag == 26) {
         parse_http:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_http()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_delay_seconds;
        break;
      }

      // optional double delay_seconds = 4 [default = 15];
      case 4: {
        if (tag == 33) {
         parse_delay_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &delay_seconds_)));
          set_has_delay_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(41)) goto parse_interval_seconds;
        break;
      }

      // optional double interval_seconds = 5 [default = 10];
      case 5: {
        if (tag == 41) {
         parse_interval_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &interval_seconds_)));
          set_has_interval_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_timeout_seconds;
        break;
      }

      // optional double timeout_seconds = 6 [default = 20];
      case 6: {
        if (tag == 49) {
         parse_timeout_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timeout_seconds_)));
          set_has_timeout_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckInfo)
  return false;
#undef DO_
}

void CheckInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.CheckInfo.Command command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->command_, output);
  }

  // optional .mesos.CheckInfo.Http http = 3;
  if (has_http()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->http_, output);
  }

  // optional double delay_seconds = 4 [default = 15];
  if (has_delay_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->delay_seconds(), output);
  }

  // optional double interval_seconds = 5 [default = 10];
  if (has_interval_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(5, this->interval_seconds(), output);
  }

  // optional double timeout_seconds = 6 [default = 20];
  if (has_timeout_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->timeout_seconds(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckInfo)
}

::google::protobuf::uint8* CheckInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.CheckInfo.Command command = 2;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->command_, false, target);
  }

  // optional .mesos.CheckInfo.Http http = 3;
  if (has_http()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->http_, false, target);
  }

  // optional double delay_seconds = 4 [default = 15];
  if (has_delay_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->delay_seconds(), target);
  }

  // optional double interval_seconds = 5 [default = 10];
  if (has_interval_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(5, this->interval_seconds(), target);
  }

  // optional double timeout_seconds = 6 [default = 20];
  if (has_timeout_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->timeout_seconds(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckInfo)
  return target;
}

int CheckInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CheckInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 63u) {
    // optional .mesos.CheckInfo.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.CheckInfo.Command command = 2;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->command_);
    }

    // optional .mesos.CheckInfo.Http http = 3;
    if (has_http()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->http_);
    }

    // optional double delay_seconds = 4 [default = 15];
    if (has_delay_seconds()) {
      total_size += 1 + 8;
    }

    // optional double interval_seconds = 5 [default = 10];
    if (has_interval_seconds()) {
      total_size += 1 + 8;
    }

    // optional double timeout_seconds = 6 [default = 20];
    if (has_timeout_seconds()) {
      total_size += 1 + 8;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CheckInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CheckInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CheckInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CheckInfo)
    MergeFrom(*source);
  }
}

void CheckInfo::MergeFrom(const CheckInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CheckInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CheckInfo_Command::MergeFrom(from.command());
    }
    if (from.has_http()) {
      mutable_http()->::mesos::CheckInfo_Http::MergeFrom(from.http());
    }
    if (from.has_delay_seconds()) {
      set_delay_seconds(from.delay_seconds());
    }
    if (from.has_interval_seconds()) {
      set_interval_seconds(from.interval_seconds());
    }
    if (from.has_timeout_seconds()) {
      set_timeout_seconds(from.timeout_seconds());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CheckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckInfo::CopyFrom(const CheckInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CheckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckInfo::IsInitialized() const {

  if (has_command()) {
    if (!this->command_->IsInitialized()) return false;
  }
  if (has_http()) {
    if (!this->http_->IsInitialized()) return false;
  }
  return true;
}

void CheckInfo::Swap(CheckInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckInfo::InternalSwap(CheckInfo* other) {
  std::swap(type_, other->type_);
  std::swap(command_, other->command_);
  std::swap(http_, other->http_);
  std::swap(delay_seconds_, other->delay_seconds_);
  std::swap(interval_seconds_, other->interval_seconds_);
  std::swap(timeout_seconds_, other->timeout_seconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckInfo_descriptor_;
  metadata.reflection = CheckInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CheckInfo_Command

// required .mesos.CommandInfo command = 1;
bool CheckInfo_Command::has_command() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckInfo_Command::set_has_command() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckInfo_Command::clear_has_command() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckInfo_Command::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
const ::mesos::CommandInfo& CheckInfo_Command::command() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Command.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
::mesos::CommandInfo* CheckInfo_Command::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.Command.command)
  return command_;
}
::mesos::CommandInfo* CheckInfo_Command::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.Command.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
void CheckInfo_Command::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.Command.command)
}

// -------------------------------------------------------------------

// CheckInfo_Http

// required uint32 port = 1;
bool CheckInfo_Http::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckInfo_Http::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckInfo_Http::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckInfo_Http::clear_port() {
  port_ = 0u;
  clear_has_port();
}
 ::google::protobuf::uint32 CheckInfo_Http::port() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Http.port)
  return port_;
}
 void CheckInfo_Http::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Http.port)
}

// optional string path = 2;
bool CheckInfo_Http::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CheckInfo_Http::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
void CheckInfo_Http::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
void CheckInfo_Http::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
 const ::std::string& CheckInfo_Http::path() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.Http.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CheckInfo_Http::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.Http.path)
}
 void CheckInfo_Http::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.CheckInfo.Http.path)
}
 void CheckInfo_Http::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.CheckInfo.Http.path)
}
 ::std::string* CheckInfo_Http::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.Http.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CheckInfo_Http::release_path() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.Http.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CheckInfo_Http::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.Http.path)
}

// -------------------------------------------------------------------

// CheckInfo

// optional .mesos.CheckInfo.Type type = 1;
bool CheckInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::CheckInfo_Type CheckInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.type)
  return static_cast< ::mesos::CheckInfo_Type >(type_);
}
 void CheckInfo::set_type(::mesos::CheckInfo_Type value) {
  assert(::mesos::CheckInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.type)
}

// optional .mesos.CheckInfo.Command command = 2;
bool CheckInfo::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CheckInfo::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
void CheckInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
void CheckInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CheckInfo_Command::Clear();
  clear_has_command();
}
const ::mesos::CheckInfo_Command& CheckInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
::mesos::CheckInfo_Command* CheckInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CheckInfo_Command;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.command)
  return command_;
}
::mesos::CheckInfo_Command* CheckInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.command)
  clear_has_command();
  ::mesos::CheckInfo_Command* temp = command_;
  command_ = NULL;
  return temp;
}
void CheckInfo::set_allocated_command(::mesos::CheckInfo_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.command)
}

// optional .mesos.CheckInfo.Http http = 3;
bool CheckInfo::has_http() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CheckInfo::set_has_http() {
  _has_bits_[0] |= 0x00000004u;
}
void CheckInfo::clear_has_http() {
  _has_bits_[0] &= ~0x00000004u;
}
void CheckInfo::clear_http() {
  if (http_ != NULL) http_->::mesos::CheckInfo_Http::Clear();
  clear_has_http();
}
const ::mesos::CheckInfo_Http& CheckInfo::http() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.http)
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
::mesos::CheckInfo_Http* CheckInfo::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    http_ = new ::mesos::CheckInfo_Http;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckInfo.http)
  return http_;
}
::mesos::CheckInfo_Http* CheckInfo::release_http() {
  // @@protoc_insertion_point(field_release:mesos.CheckInfo.http)
  clear_has_http();
  ::mesos::CheckInfo_Http* temp = http_;
  http_ = NULL;
  return temp;
}
void CheckInfo::set_allocated_http(::mesos::CheckInfo_Http* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckInfo.http)
}

// optional double delay_seconds = 4 [default = 15];
bool CheckInfo::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CheckInfo::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000008u;
}
void CheckInfo::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000008u;
}
void CheckInfo::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
 double CheckInfo::delay_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.delay_seconds)
  return delay_seconds_;
}
 void CheckInfo::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.delay_seconds)
}

// optional double interval_seconds = 5 [default = 10];
bool CheckInfo::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CheckInfo::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
void CheckInfo::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
void CheckInfo::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
 double CheckInfo::interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.interval_seconds)
  return interval_seconds_;
}
 void CheckInfo::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.interval_seconds)
}

// optional double timeout_seconds = 6 [default = 20];
bool CheckInfo::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CheckInfo::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000020u;
}
void CheckInfo::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000020u;
}
void CheckInfo::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
 double CheckInfo::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.CheckInfo.timeout_seconds)
  return timeout_seconds_;
}
 void CheckInfo::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckInfo.timeout_seconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* HealthCheck_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_Type_descriptor_;
}
bool HealthCheck_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const HealthCheck_Type HealthCheck::UNKNOWN;
const HealthCheck_Type HealthCheck::COMMAND;
const HealthCheck_Type HealthCheck::HTTP;
const HealthCheck_Type HealthCheck::TCP;
const HealthCheck_Type HealthCheck::Type_MIN;
const HealthCheck_Type HealthCheck::Type_MAX;
const int HealthCheck::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HealthCheck_HTTPCheckInfo::kSchemeFieldNumber;
const int HealthCheck_HTTPCheckInfo::kPortFieldNumber;
const int HealthCheck_HTTPCheckInfo::kPathFieldNumber;
const int HealthCheck_HTTPCheckInfo::kStatusesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HealthCheck_HTTPCheckInfo::HealthCheck_HTTPCheckInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.HealthCheck.HTTPCheckInfo)
}

void HealthCheck_HTTPCheckInfo::InitAsDefaultInstance() {
}

HealthCheck_HTTPCheckInfo::HealthCheck_HTTPCheckInfo(const HealthCheck_HTTPCheckInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.HealthCheck.HTTPCheckInfo)
}

void HealthCheck_HTTPCheckInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  scheme_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 0u;
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HealthCheck_HTTPCheckInfo::~HealthCheck_HTTPCheckInfo() {
  // @@protoc_insertion_point(destructor:mesos.HealthCheck.HTTPCheckInfo)
  SharedDtor();
}

void HealthCheck_HTTPCheckInfo::SharedDtor() {
  scheme_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void HealthCheck_HTTPCheckInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HealthCheck_HTTPCheckInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_HTTPCheckInfo_descriptor_;
}

const HealthCheck_HTTPCheckInfo& HealthCheck_HTTPCheckInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

HealthCheck_HTTPCheckInfo* HealthCheck_HTTPCheckInfo::default_instance_ = NULL;

HealthCheck_HTTPCheckInfo* HealthCheck_HTTPCheckInfo::New(::google::protobuf::Arena* arena) const {
  HealthCheck_HTTPCheckInfo* n = new HealthCheck_HTTPCheckInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HealthCheck_HTTPCheckInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.HealthCheck.HTTPCheckInfo)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_scheme()) {
      scheme_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    port_ = 0u;
    if (has_path()) {
      path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HealthCheck_HTTPCheckInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.HealthCheck.HTTPCheckInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // optional string path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.HealthCheck.HTTPCheckInfo.path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scheme;
        break;
      }

      // optional string scheme = 3;
      case 3: {
        if (tag == 26) {
         parse_scheme:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_scheme()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->scheme().data(), this->scheme().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.HealthCheck.HTTPCheckInfo.scheme");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_statuses;
        break;
      }

      // repeated uint32 statuses = 4;
      case 4: {
        if (tag == 32) {
         parse_statuses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 1, 32, input, this->mutable_statuses())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, this->mutable_statuses())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_statuses;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.HealthCheck.HTTPCheckInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.HealthCheck.HTTPCheckInfo)
  return false;
#undef DO_
}

void HealthCheck_HTTPCheckInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.HealthCheck.HTTPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.HealthCheck.HTTPCheckInfo.path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path(), output);
  }

  // optional string scheme = 3;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.HealthCheck.HTTPCheckInfo.scheme");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->scheme(), output);
  }

  // repeated uint32 statuses = 4;
  for (int i = 0; i < this->statuses_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(
      4, this->statuses(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.HealthCheck.HTTPCheckInfo)
}

::google::protobuf::uint8* HealthCheck_HTTPCheckInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.HealthCheck.HTTPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  // optional string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.HealthCheck.HTTPCheckInfo.path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }

  // optional string scheme = 3;
  if (has_scheme()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->scheme().data(), this->scheme().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.HealthCheck.HTTPCheckInfo.scheme");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->scheme(), target);
  }

  // repeated uint32 statuses = 4;
  for (int i = 0; i < this->statuses_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteUInt32ToArray(4, this->statuses(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.HealthCheck.HTTPCheckInfo)
  return target;
}

int HealthCheck_HTTPCheckInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.HealthCheck.HTTPCheckInfo)
  int total_size = 0;

  // required uint32 port = 1;
  if (has_port()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }
  if (_has_bits_[0 / 32] & 5u) {
    // optional string scheme = 3;
    if (has_scheme()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->scheme());
    }

    // optional string path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->path());
    }

  }
  // repeated uint32 statuses = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->statuses_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        UInt32Size(this->statuses(i));
    }
    total_size += 1 * this->statuses_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HealthCheck_HTTPCheckInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.HealthCheck.HTTPCheckInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HealthCheck_HTTPCheckInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HealthCheck_HTTPCheckInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.HealthCheck.HTTPCheckInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.HealthCheck.HTTPCheckInfo)
    MergeFrom(*source);
  }
}

void HealthCheck_HTTPCheckInfo::MergeFrom(const HealthCheck_HTTPCheckInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.HealthCheck.HTTPCheckInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_scheme()) {
      set_has_scheme();
      scheme_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.scheme_);
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_path()) {
      set_has_path();
      path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HealthCheck_HTTPCheckInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.HealthCheck.HTTPCheckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HealthCheck_HTTPCheckInfo::CopyFrom(const HealthCheck_HTTPCheckInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.HealthCheck.HTTPCheckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthCheck_HTTPCheckInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void HealthCheck_HTTPCheckInfo::Swap(HealthCheck_HTTPCheckInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HealthCheck_HTTPCheckInfo::InternalSwap(HealthCheck_HTTPCheckInfo* other) {
  scheme_.Swap(&other->scheme_);
  std::swap(port_, other->port_);
  path_.Swap(&other->path_);
  statuses_.UnsafeArenaSwap(&other->statuses_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HealthCheck_HTTPCheckInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HealthCheck_HTTPCheckInfo_descriptor_;
  metadata.reflection = HealthCheck_HTTPCheckInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HealthCheck_TCPCheckInfo::kPortFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HealthCheck_TCPCheckInfo::HealthCheck_TCPCheckInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.HealthCheck.TCPCheckInfo)
}

void HealthCheck_TCPCheckInfo::InitAsDefaultInstance() {
}

HealthCheck_TCPCheckInfo::HealthCheck_TCPCheckInfo(const HealthCheck_TCPCheckInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.HealthCheck.TCPCheckInfo)
}

void HealthCheck_TCPCheckInfo::SharedCtor() {
  _cached_size_ = 0;
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HealthCheck_TCPCheckInfo::~HealthCheck_TCPCheckInfo() {
  // @@protoc_insertion_point(destructor:mesos.HealthCheck.TCPCheckInfo)
  SharedDtor();
}

void HealthCheck_TCPCheckInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HealthCheck_TCPCheckInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HealthCheck_TCPCheckInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_TCPCheckInfo_descriptor_;
}

const HealthCheck_TCPCheckInfo& HealthCheck_TCPCheckInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

HealthCheck_TCPCheckInfo* HealthCheck_TCPCheckInfo::default_instance_ = NULL;

HealthCheck_TCPCheckInfo* HealthCheck_TCPCheckInfo::New(::google::protobuf::Arena* arena) const {
  HealthCheck_TCPCheckInfo* n = new HealthCheck_TCPCheckInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HealthCheck_TCPCheckInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.HealthCheck.TCPCheckInfo)
  port_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HealthCheck_TCPCheckInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.HealthCheck.TCPCheckInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.HealthCheck.TCPCheckInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.HealthCheck.TCPCheckInfo)
  return false;
#undef DO_
}

void HealthCheck_TCPCheckInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.HealthCheck.TCPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->port(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.HealthCheck.TCPCheckInfo)
}

::google::protobuf::uint8* HealthCheck_TCPCheckInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.HealthCheck.TCPCheckInfo)
  // required uint32 port = 1;
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->port(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.HealthCheck.TCPCheckInfo)
  return target;
}

int HealthCheck_TCPCheckInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.HealthCheck.TCPCheckInfo)
  int total_size = 0;

  // required uint32 port = 1;
  if (has_port()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HealthCheck_TCPCheckInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.HealthCheck.TCPCheckInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HealthCheck_TCPCheckInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HealthCheck_TCPCheckInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.HealthCheck.TCPCheckInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.HealthCheck.TCPCheckInfo)
    MergeFrom(*source);
  }
}

void HealthCheck_TCPCheckInfo::MergeFrom(const HealthCheck_TCPCheckInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.HealthCheck.TCPCheckInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_port()) {
      set_port(from.port());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HealthCheck_TCPCheckInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.HealthCheck.TCPCheckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HealthCheck_TCPCheckInfo::CopyFrom(const HealthCheck_TCPCheckInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.HealthCheck.TCPCheckInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthCheck_TCPCheckInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void HealthCheck_TCPCheckInfo::Swap(HealthCheck_TCPCheckInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HealthCheck_TCPCheckInfo::InternalSwap(HealthCheck_TCPCheckInfo* other) {
  std::swap(port_, other->port_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HealthCheck_TCPCheckInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HealthCheck_TCPCheckInfo_descriptor_;
  metadata.reflection = HealthCheck_TCPCheckInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HealthCheck::kDelaySecondsFieldNumber;
const int HealthCheck::kIntervalSecondsFieldNumber;
const int HealthCheck::kTimeoutSecondsFieldNumber;
const int HealthCheck::kConsecutiveFailuresFieldNumber;
const int HealthCheck::kGracePeriodSecondsFieldNumber;
const int HealthCheck::kTypeFieldNumber;
const int HealthCheck::kCommandFieldNumber;
const int HealthCheck::kHttpFieldNumber;
const int HealthCheck::kTcpFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HealthCheck::HealthCheck()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.HealthCheck)
}

void HealthCheck::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  http_ = const_cast< ::mesos::HealthCheck_HTTPCheckInfo*>(&::mesos::HealthCheck_HTTPCheckInfo::default_instance());
  tcp_ = const_cast< ::mesos::HealthCheck_TCPCheckInfo*>(&::mesos::HealthCheck_TCPCheckInfo::default_instance());
}

HealthCheck::HealthCheck(const HealthCheck& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.HealthCheck)
}

void HealthCheck::SharedCtor() {
  _cached_size_ = 0;
  delay_seconds_ = 15;
  interval_seconds_ = 10;
  timeout_seconds_ = 20;
  consecutive_failures_ = 3u;
  grace_period_seconds_ = 10;
  type_ = 0;
  command_ = NULL;
  http_ = NULL;
  tcp_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HealthCheck::~HealthCheck() {
  // @@protoc_insertion_point(destructor:mesos.HealthCheck)
  SharedDtor();
}

void HealthCheck::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
    delete http_;
    delete tcp_;
  }
}

void HealthCheck::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HealthCheck::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HealthCheck_descriptor_;
}

const HealthCheck& HealthCheck::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

HealthCheck* HealthCheck::default_instance_ = NULL;

HealthCheck* HealthCheck::New(::google::protobuf::Arena* arena) const {
  HealthCheck* n = new HealthCheck;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HealthCheck::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.HealthCheck)
  if (_has_bits_[0 / 32] & 255u) {
    delay_seconds_ = 15;
    interval_seconds_ = 10;
    timeout_seconds_ = 20;
    consecutive_failures_ = 3u;
    grace_period_seconds_ = 10;
    type_ = 0;
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_http()) {
      if (http_ != NULL) http_->::mesos::HealthCheck_HTTPCheckInfo::Clear();
    }
  }
  if (has_tcp()) {
    if (tcp_ != NULL) tcp_->::mesos::HealthCheck_TCPCheckInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool HealthCheck::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.HealthCheck)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_http()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_delay_seconds;
        break;
      }

      // optional double delay_seconds = 2 [default = 15];
      case 2: {
        if (tag == 17) {
         parse_delay_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &delay_seconds_)));
          set_has_delay_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_interval_seconds;
        break;
      }

      // optional double interval_seconds = 3 [default = 10];
      case 3: {
        if (tag == 25) {
         parse_interval_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &interval_seconds_)));
          set_has_interval_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_timeout_seconds;
        break;
      }

      // optional double timeout_seconds = 4 [default = 20];
      case 4: {
        if (tag == 33) {
         parse_timeout_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timeout_seconds_)));
          set_has_timeout_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_consecutive_failures;
        break;
      }

      // optional uint32 consecutive_failures = 5 [default = 3];
      case 5: {
        if (tag == 40) {
         parse_consecutive_failures:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &consecutive_failures_)));
          set_has_consecutive_failures();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_grace_period_seconds;
        break;
      }

      // optional double grace_period_seconds = 6 [default = 10];
      case 6: {
        if (tag == 49) {
         parse_grace_period_seconds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &grace_period_seconds_)));
          set_has_grace_period_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 7;
      case 7: {
        if (tag == 58) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_type;
        break;
      }

      // optional .mesos.HealthCheck.Type type = 8;
      case 8: {
        if (tag == 64) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::HealthCheck_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::HealthCheck_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(8, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_tcp;
        break;
      }

      // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
      case 9: {
        if (tag == 74) {
         parse_tcp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.HealthCheck)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.HealthCheck)
  return false;
#undef DO_
}

void HealthCheck::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.HealthCheck)
  // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
  if (has_http()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->http_, output);
  }

  // optional double delay_seconds = 2 [default = 15];
  if (has_delay_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->delay_seconds(), output);
  }

  // optional double interval_seconds = 3 [default = 10];
  if (has_interval_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->interval_seconds(), output);
  }

  // optional double timeout_seconds = 4 [default = 20];
  if (has_timeout_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->timeout_seconds(), output);
  }

  // optional uint32 consecutive_failures = 5 [default = 3];
  if (has_consecutive_failures()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->consecutive_failures(), output);
  }

  // optional double grace_period_seconds = 6 [default = 10];
  if (has_grace_period_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->grace_period_seconds(), output);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->command_, output);
  }

  // optional .mesos.HealthCheck.Type type = 8;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      8, this->type(), output);
  }

  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  if (has_tcp()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->tcp_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.HealthCheck)
}

::google::protobuf::uint8* HealthCheck::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.HealthCheck)
  // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
  if (has_http()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->http_, false, target);
  }

  // optional double delay_seconds = 2 [default = 15];
  if (has_delay_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->delay_seconds(), target);
  }

  // optional double interval_seconds = 3 [default = 10];
  if (has_interval_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->interval_seconds(), target);
  }

  // optional double timeout_seconds = 4 [default = 20];
  if (has_timeout_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->timeout_seconds(), target);
  }

  // optional uint32 consecutive_failures = 5 [default = 3];
  if (has_consecutive_failures()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->consecutive_failures(), target);
  }

  // optional double grace_period_seconds = 6 [default = 10];
  if (has_grace_period_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->grace_period_seconds(), target);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->command_, false, target);
  }

  // optional .mesos.HealthCheck.Type type = 8;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      8, this->type(), target);
  }

  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  if (has_tcp()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->tcp_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.HealthCheck)
  return target;
}

int HealthCheck::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.HealthCheck)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional double delay_seconds = 2 [default = 15];
    if (has_delay_seconds()) {
      total_size += 1 + 8;
    }

    // optional double interval_seconds = 3 [default = 10];
    if (has_interval_seconds()) {
      total_size += 1 + 8;
    }

    // optional double timeout_seconds = 4 [default = 20];
    if (has_timeout_seconds()) {
      total_size += 1 + 8;
    }

    // optional uint32 consecutive_failures = 5 [default = 3];
    if (has_consecutive_failures()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->consecutive_failures());
    }

    // optional double grace_period_seconds = 6 [default = 10];
    if (has_grace_period_seconds()) {
      total_size += 1 + 8;
    }

    // optional .mesos.HealthCheck.Type type = 8;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.CommandInfo command = 7;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->command_);
    }

    // optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
    if (has_http()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->http_);
    }

  }
  // optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
  if (has_tcp()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->tcp_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HealthCheck::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.HealthCheck)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HealthCheck* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HealthCheck>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.HealthCheck)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.HealthCheck)
    MergeFrom(*source);
  }
}

void HealthCheck::MergeFrom(const HealthCheck& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.HealthCheck)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_delay_seconds()) {
      set_delay_seconds(from.delay_seconds());
    }
    if (from.has_interval_seconds()) {
      set_interval_seconds(from.interval_seconds());
    }
    if (from.has_timeout_seconds()) {
      set_timeout_seconds(from.timeout_seconds());
    }
    if (from.has_consecutive_failures()) {
      set_consecutive_failures(from.consecutive_failures());
    }
    if (from.has_grace_period_seconds()) {
      set_grace_period_seconds(from.grace_period_seconds());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_http()) {
      mutable_http()->::mesos::HealthCheck_HTTPCheckInfo::MergeFrom(from.http());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tcp()) {
      mutable_tcp()->::mesos::HealthCheck_TCPCheckInfo::MergeFrom(from.tcp());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void HealthCheck::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.HealthCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HealthCheck::CopyFrom(const HealthCheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.HealthCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HealthCheck::IsInitialized() const {

  if (has_command()) {
    if (!this->command_->IsInitialized()) return false;
  }
  if (has_http()) {
    if (!this->http_->IsInitialized()) return false;
  }
  if (has_tcp()) {
    if (!this->tcp_->IsInitialized()) return false;
  }
  return true;
}

void HealthCheck::Swap(HealthCheck* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HealthCheck::InternalSwap(HealthCheck* other) {
  std::swap(delay_seconds_, other->delay_seconds_);
  std::swap(interval_seconds_, other->interval_seconds_);
  std::swap(timeout_seconds_, other->timeout_seconds_);
  std::swap(consecutive_failures_, other->consecutive_failures_);
  std::swap(grace_period_seconds_, other->grace_period_seconds_);
  std::swap(type_, other->type_);
  std::swap(command_, other->command_);
  std::swap(http_, other->http_);
  std::swap(tcp_, other->tcp_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HealthCheck::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HealthCheck_descriptor_;
  metadata.reflection = HealthCheck_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HealthCheck_HTTPCheckInfo

// optional string scheme = 3;
bool HealthCheck_HTTPCheckInfo::has_scheme() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HealthCheck_HTTPCheckInfo::set_has_scheme() {
  _has_bits_[0] |= 0x00000001u;
}
void HealthCheck_HTTPCheckInfo::clear_has_scheme() {
  _has_bits_[0] &= ~0x00000001u;
}
void HealthCheck_HTTPCheckInfo::clear_scheme() {
  scheme_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_scheme();
}
 const ::std::string& HealthCheck_HTTPCheckInfo::scheme() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.scheme)
  return scheme_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HealthCheck_HTTPCheckInfo::set_scheme(const ::std::string& value) {
  set_has_scheme();
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
 void HealthCheck_HTTPCheckInfo::set_scheme(const char* value) {
  set_has_scheme();
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
 void HealthCheck_HTTPCheckInfo::set_scheme(const char* value, size_t size) {
  set_has_scheme();
  scheme_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.HealthCheck.HTTPCheckInfo.scheme)
}
 ::std::string* HealthCheck_HTTPCheckInfo::mutable_scheme() {
  set_has_scheme();
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.HTTPCheckInfo.scheme)
  return scheme_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* HealthCheck_HTTPCheckInfo::release_scheme() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.HTTPCheckInfo.scheme)
  clear_has_scheme();
  return scheme_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HealthCheck_HTTPCheckInfo::set_allocated_scheme(::std::string* scheme) {
  if (scheme != NULL) {
    set_has_scheme();
  } else {
    clear_has_scheme();
  }
  scheme_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), scheme);
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.HTTPCheckInfo.scheme)
}

// required uint32 port = 1;
bool HealthCheck_HTTPCheckInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HealthCheck_HTTPCheckInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
void HealthCheck_HTTPCheckInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
void HealthCheck_HTTPCheckInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
 ::google::protobuf::uint32 HealthCheck_HTTPCheckInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.port)
  return port_;
}
 void HealthCheck_HTTPCheckInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.port)
}

// optional string path = 2;
bool HealthCheck_HTTPCheckInfo::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void HealthCheck_HTTPCheckInfo::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
void HealthCheck_HTTPCheckInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
void HealthCheck_HTTPCheckInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
 const ::std::string& HealthCheck_HTTPCheckInfo::path() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HealthCheck_HTTPCheckInfo::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.path)
}
 void HealthCheck_HTTPCheckInfo::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.HealthCheck.HTTPCheckInfo.path)
}
 void HealthCheck_HTTPCheckInfo::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.HealthCheck.HTTPCheckInfo.path)
}
 ::std::string* HealthCheck_HTTPCheckInfo::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.HTTPCheckInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* HealthCheck_HTTPCheckInfo::release_path() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.HTTPCheckInfo.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HealthCheck_HTTPCheckInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.HTTPCheckInfo.path)
}

// repeated uint32 statuses = 4;
int HealthCheck_HTTPCheckInfo::statuses_size() const {
  return statuses_.size();
}
void HealthCheck_HTTPCheckInfo::clear_statuses() {
  statuses_.Clear();
}
 ::google::protobuf::uint32 HealthCheck_HTTPCheckInfo::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return statuses_.Get(index);
}
 void HealthCheck_HTTPCheckInfo::set_statuses(int index, ::google::protobuf::uint32 value) {
  statuses_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.HTTPCheckInfo.statuses)
}
 void HealthCheck_HTTPCheckInfo::add_statuses(::google::protobuf::uint32 value) {
  statuses_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.HealthCheck.HTTPCheckInfo.statuses)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >&
HealthCheck_HTTPCheckInfo::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return statuses_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::uint32 >*
HealthCheck_HTTPCheckInfo::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.HealthCheck.HTTPCheckInfo.statuses)
  return &statuses_;
}

// -------------------------------------------------------------------

// HealthCheck_TCPCheckInfo

// required uint32 port = 1;
bool HealthCheck_TCPCheckInfo::has_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HealthCheck_TCPCheckInfo::set_has_port() {
  _has_bits_[0] |= 0x00000001u;
}
void HealthCheck_TCPCheckInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000001u;
}
void HealthCheck_TCPCheckInfo::clear_port() {
  port_ = 0u;
  clear_has_port();
}
 ::google::protobuf::uint32 HealthCheck_TCPCheckInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.TCPCheckInfo.port)
  return port_;
}
 void HealthCheck_TCPCheckInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.TCPCheckInfo.port)
}

// -------------------------------------------------------------------

// HealthCheck

// optional double delay_seconds = 2 [default = 15];
bool HealthCheck::has_delay_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void HealthCheck::set_has_delay_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
void HealthCheck::clear_has_delay_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void HealthCheck::clear_delay_seconds() {
  delay_seconds_ = 15;
  clear_has_delay_seconds();
}
 double HealthCheck::delay_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.delay_seconds)
  return delay_seconds_;
}
 void HealthCheck::set_delay_seconds(double value) {
  set_has_delay_seconds();
  delay_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.delay_seconds)
}

// optional double interval_seconds = 3 [default = 10];
bool HealthCheck::has_interval_seconds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void HealthCheck::set_has_interval_seconds() {
  _has_bits_[0] |= 0x00000002u;
}
void HealthCheck::clear_has_interval_seconds() {
  _has_bits_[0] &= ~0x00000002u;
}
void HealthCheck::clear_interval_seconds() {
  interval_seconds_ = 10;
  clear_has_interval_seconds();
}
 double HealthCheck::interval_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.interval_seconds)
  return interval_seconds_;
}
 void HealthCheck::set_interval_seconds(double value) {
  set_has_interval_seconds();
  interval_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.interval_seconds)
}

// optional double timeout_seconds = 4 [default = 20];
bool HealthCheck::has_timeout_seconds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void HealthCheck::set_has_timeout_seconds() {
  _has_bits_[0] |= 0x00000004u;
}
void HealthCheck::clear_has_timeout_seconds() {
  _has_bits_[0] &= ~0x00000004u;
}
void HealthCheck::clear_timeout_seconds() {
  timeout_seconds_ = 20;
  clear_has_timeout_seconds();
}
 double HealthCheck::timeout_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.timeout_seconds)
  return timeout_seconds_;
}
 void HealthCheck::set_timeout_seconds(double value) {
  set_has_timeout_seconds();
  timeout_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.timeout_seconds)
}

// optional uint32 consecutive_failures = 5 [default = 3];
bool HealthCheck::has_consecutive_failures() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void HealthCheck::set_has_consecutive_failures() {
  _has_bits_[0] |= 0x00000008u;
}
void HealthCheck::clear_has_consecutive_failures() {
  _has_bits_[0] &= ~0x00000008u;
}
void HealthCheck::clear_consecutive_failures() {
  consecutive_failures_ = 3u;
  clear_has_consecutive_failures();
}
 ::google::protobuf::uint32 HealthCheck::consecutive_failures() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.consecutive_failures)
  return consecutive_failures_;
}
 void HealthCheck::set_consecutive_failures(::google::protobuf::uint32 value) {
  set_has_consecutive_failures();
  consecutive_failures_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.consecutive_failures)
}

// optional double grace_period_seconds = 6 [default = 10];
bool HealthCheck::has_grace_period_seconds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void HealthCheck::set_has_grace_period_seconds() {
  _has_bits_[0] |= 0x00000010u;
}
void HealthCheck::clear_has_grace_period_seconds() {
  _has_bits_[0] &= ~0x00000010u;
}
void HealthCheck::clear_grace_period_seconds() {
  grace_period_seconds_ = 10;
  clear_has_grace_period_seconds();
}
 double HealthCheck::grace_period_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.grace_period_seconds)
  return grace_period_seconds_;
}
 void HealthCheck::set_grace_period_seconds(double value) {
  set_has_grace_period_seconds();
  grace_period_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.grace_period_seconds)
}

// optional .mesos.HealthCheck.Type type = 8;
bool HealthCheck::has_type() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void HealthCheck::set_has_type() {
  _has_bits_[0] |= 0x00000020u;
}
void HealthCheck::clear_has_type() {
  _has_bits_[0] &= ~0x00000020u;
}
void HealthCheck::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::HealthCheck_Type HealthCheck::type() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.type)
  return static_cast< ::mesos::HealthCheck_Type >(type_);
}
 void HealthCheck::set_type(::mesos::HealthCheck_Type value) {
  assert(::mesos::HealthCheck_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.HealthCheck.type)
}

// optional .mesos.CommandInfo command = 7;
bool HealthCheck::has_command() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void HealthCheck::set_has_command() {
  _has_bits_[0] |= 0x00000040u;
}
void HealthCheck::clear_has_command() {
  _has_bits_[0] &= ~0x00000040u;
}
void HealthCheck::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
const ::mesos::CommandInfo& HealthCheck::command() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
::mesos::CommandInfo* HealthCheck::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.command)
  return command_;
}
::mesos::CommandInfo* HealthCheck::release_command() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
void HealthCheck::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.command)
}

// optional .mesos.HealthCheck.HTTPCheckInfo http = 1;
bool HealthCheck::has_http() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void HealthCheck::set_has_http() {
  _has_bits_[0] |= 0x00000080u;
}
void HealthCheck::clear_has_http() {
  _has_bits_[0] &= ~0x00000080u;
}
void HealthCheck::clear_http() {
  if (http_ != NULL) http_->::mesos::HealthCheck_HTTPCheckInfo::Clear();
  clear_has_http();
}
const ::mesos::HealthCheck_HTTPCheckInfo& HealthCheck::http() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.http)
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    http_ = new ::mesos::HealthCheck_HTTPCheckInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.http)
  return http_;
}
::mesos::HealthCheck_HTTPCheckInfo* HealthCheck::release_http() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.http)
  clear_has_http();
  ::mesos::HealthCheck_HTTPCheckInfo* temp = http_;
  http_ = NULL;
  return temp;
}
void HealthCheck::set_allocated_http(::mesos::HealthCheck_HTTPCheckInfo* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.http)
}

// optional .mesos.HealthCheck.TCPCheckInfo tcp = 9;
bool HealthCheck::has_tcp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void HealthCheck::set_has_tcp() {
  _has_bits_[0] |= 0x00000100u;
}
void HealthCheck::clear_has_tcp() {
  _has_bits_[0] &= ~0x00000100u;
}
void HealthCheck::clear_tcp() {
  if (tcp_ != NULL) tcp_->::mesos::HealthCheck_TCPCheckInfo::Clear();
  clear_has_tcp();
}
const ::mesos::HealthCheck_TCPCheckInfo& HealthCheck::tcp() const {
  // @@protoc_insertion_point(field_get:mesos.HealthCheck.tcp)
  return tcp_ != NULL ? *tcp_ : *default_instance_->tcp_;
}
::mesos::HealthCheck_TCPCheckInfo* HealthCheck::mutable_tcp() {
  set_has_tcp();
  if (tcp_ == NULL) {
    tcp_ = new ::mesos::HealthCheck_TCPCheckInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.HealthCheck.tcp)
  return tcp_;
}
::mesos::HealthCheck_TCPCheckInfo* HealthCheck::release_tcp() {
  // @@protoc_insertion_point(field_release:mesos.HealthCheck.tcp)
  clear_has_tcp();
  ::mesos::HealthCheck_TCPCheckInfo* temp = tcp_;
  tcp_ = NULL;
  return temp;
}
void HealthCheck::set_allocated_tcp(::mesos::HealthCheck_TCPCheckInfo* tcp) {
  delete tcp_;
  tcp_ = tcp;
  if (tcp) {
    set_has_tcp();
  } else {
    clear_has_tcp();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.HealthCheck.tcp)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int KillPolicy::kGracePeriodFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

KillPolicy::KillPolicy()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.KillPolicy)
}

void KillPolicy::InitAsDefaultInstance() {
  grace_period_ = const_cast< ::mesos::DurationInfo*>(&::mesos::DurationInfo::default_instance());
}

KillPolicy::KillPolicy(const KillPolicy& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.KillPolicy)
}

void KillPolicy::SharedCtor() {
  _cached_size_ = 0;
  grace_period_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KillPolicy::~KillPolicy() {
  // @@protoc_insertion_point(destructor:mesos.KillPolicy)
  SharedDtor();
}

void KillPolicy::SharedDtor() {
  if (this != default_instance_) {
    delete grace_period_;
  }
}

void KillPolicy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KillPolicy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KillPolicy_descriptor_;
}

const KillPolicy& KillPolicy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

KillPolicy* KillPolicy::default_instance_ = NULL;

KillPolicy* KillPolicy::New(::google::protobuf::Arena* arena) const {
  KillPolicy* n = new KillPolicy;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void KillPolicy::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.KillPolicy)
  if (has_grace_period()) {
    if (grace_period_ != NULL) grace_period_->::mesos::DurationInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool KillPolicy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.KillPolicy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.DurationInfo grace_period = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_grace_period()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.KillPolicy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.KillPolicy)
  return false;
#undef DO_
}

void KillPolicy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.KillPolicy)
  // optional .mesos.DurationInfo grace_period = 1;
  if (has_grace_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->grace_period_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.KillPolicy)
}

::google::protobuf::uint8* KillPolicy::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.KillPolicy)
  // optional .mesos.DurationInfo grace_period = 1;
  if (has_grace_period()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->grace_period_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.KillPolicy)
  return target;
}

int KillPolicy::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.KillPolicy)
  int total_size = 0;

  // optional .mesos.DurationInfo grace_period = 1;
  if (has_grace_period()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->grace_period_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KillPolicy::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.KillPolicy)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const KillPolicy* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const KillPolicy>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.KillPolicy)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.KillPolicy)
    MergeFrom(*source);
  }
}

void KillPolicy::MergeFrom(const KillPolicy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.KillPolicy)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_grace_period()) {
      mutable_grace_period()->::mesos::DurationInfo::MergeFrom(from.grace_period());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void KillPolicy::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.KillPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KillPolicy::CopyFrom(const KillPolicy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.KillPolicy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KillPolicy::IsInitialized() const {

  if (has_grace_period()) {
    if (!this->grace_period_->IsInitialized()) return false;
  }
  return true;
}

void KillPolicy::Swap(KillPolicy* other) {
  if (other == this) return;
  InternalSwap(other);
}
void KillPolicy::InternalSwap(KillPolicy* other) {
  std::swap(grace_period_, other->grace_period_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata KillPolicy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KillPolicy_descriptor_;
  metadata.reflection = KillPolicy_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// KillPolicy

// optional .mesos.DurationInfo grace_period = 1;
bool KillPolicy::has_grace_period() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void KillPolicy::set_has_grace_period() {
  _has_bits_[0] |= 0x00000001u;
}
void KillPolicy::clear_has_grace_period() {
  _has_bits_[0] &= ~0x00000001u;
}
void KillPolicy::clear_grace_period() {
  if (grace_period_ != NULL) grace_period_->::mesos::DurationInfo::Clear();
  clear_has_grace_period();
}
const ::mesos::DurationInfo& KillPolicy::grace_period() const {
  // @@protoc_insertion_point(field_get:mesos.KillPolicy.grace_period)
  return grace_period_ != NULL ? *grace_period_ : *default_instance_->grace_period_;
}
::mesos::DurationInfo* KillPolicy::mutable_grace_period() {
  set_has_grace_period();
  if (grace_period_ == NULL) {
    grace_period_ = new ::mesos::DurationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.KillPolicy.grace_period)
  return grace_period_;
}
::mesos::DurationInfo* KillPolicy::release_grace_period() {
  // @@protoc_insertion_point(field_release:mesos.KillPolicy.grace_period)
  clear_has_grace_period();
  ::mesos::DurationInfo* temp = grace_period_;
  grace_period_ = NULL;
  return temp;
}
void KillPolicy::set_allocated_grace_period(::mesos::DurationInfo* grace_period) {
  delete grace_period_;
  grace_period_ = grace_period;
  if (grace_period) {
    set_has_grace_period();
  } else {
    clear_has_grace_period();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.KillPolicy.grace_period)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CommandInfo_URI::kValueFieldNumber;
const int CommandInfo_URI::kExecutableFieldNumber;
const int CommandInfo_URI::kExtractFieldNumber;
const int CommandInfo_URI::kCacheFieldNumber;
const int CommandInfo_URI::kOutputFileFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommandInfo_URI::CommandInfo_URI()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CommandInfo.URI)
}

void CommandInfo_URI::InitAsDefaultInstance() {
}

CommandInfo_URI::CommandInfo_URI(const CommandInfo_URI& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CommandInfo.URI)
}

void CommandInfo_URI::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  executable_ = false;
  extract_ = true;
  cache_ = false;
  output_file_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommandInfo_URI::~CommandInfo_URI() {
  // @@protoc_insertion_point(destructor:mesos.CommandInfo.URI)
  SharedDtor();
}

void CommandInfo_URI::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  output_file_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void CommandInfo_URI::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CommandInfo_URI::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandInfo_URI_descriptor_;
}

const CommandInfo_URI& CommandInfo_URI::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CommandInfo_URI* CommandInfo_URI::default_instance_ = NULL;

CommandInfo_URI* CommandInfo_URI::New(::google::protobuf::Arena* arena) const {
  CommandInfo_URI* n = new CommandInfo_URI;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommandInfo_URI::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CommandInfo.URI)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    executable_ = false;
    extract_ = true;
    cache_ = false;
    if (has_output_file()) {
      output_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CommandInfo_URI::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CommandInfo.URI)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.CommandInfo.URI.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_executable;
        break;
      }

      // optional bool executable = 2;
      case 2: {
        if (tag == 16) {
         parse_executable:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &executable_)));
          set_has_executable();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_extract;
        break;
      }

      // optional bool extract = 3 [default = true];
      case 3: {
        if (tag == 24) {
         parse_extract:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &extract_)));
          set_has_extract();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cache;
        break;
      }

      // optional bool cache = 4;
      case 4: {
        if (tag == 32) {
         parse_cache:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cache_)));
          set_has_cache();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_output_file;
        break;
      }

      // optional string output_file = 5;
      case 5: {
        if (tag == 42) {
         parse_output_file:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_output_file()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->output_file().data(), this->output_file().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.CommandInfo.URI.output_file");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CommandInfo.URI)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CommandInfo.URI)
  return false;
#undef DO_
}

void CommandInfo_URI::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CommandInfo.URI)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.URI.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  // optional bool executable = 2;
  if (has_executable()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->executable(), output);
  }

  // optional bool extract = 3 [default = true];
  if (has_extract()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(3, this->extract(), output);
  }

  // optional bool cache = 4;
  if (has_cache()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->cache(), output);
  }

  // optional string output_file = 5;
  if (has_output_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output_file().data(), this->output_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.URI.output_file");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->output_file(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CommandInfo.URI)
}

::google::protobuf::uint8* CommandInfo_URI::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CommandInfo.URI)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.URI.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  // optional bool executable = 2;
  if (has_executable()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->executable(), target);
  }

  // optional bool extract = 3 [default = true];
  if (has_extract()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(3, this->extract(), target);
  }

  // optional bool cache = 4;
  if (has_cache()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->cache(), target);
  }

  // optional string output_file = 5;
  if (has_output_file()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->output_file().data(), this->output_file().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.URI.output_file");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->output_file(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CommandInfo.URI)
  return target;
}

int CommandInfo_URI::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CommandInfo.URI)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_has_bits_[1 / 32] & 30u) {
    // optional bool executable = 2;
    if (has_executable()) {
      total_size += 1 + 1;
    }

    // optional bool extract = 3 [default = true];
    if (has_extract()) {
      total_size += 1 + 1;
    }

    // optional bool cache = 4;
    if (has_cache()) {
      total_size += 1 + 1;
    }

    // optional string output_file = 5;
    if (has_output_file()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->output_file());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommandInfo_URI::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CommandInfo.URI)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CommandInfo_URI* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CommandInfo_URI>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CommandInfo.URI)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CommandInfo.URI)
    MergeFrom(*source);
  }
}

void CommandInfo_URI::MergeFrom(const CommandInfo_URI& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CommandInfo.URI)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_executable()) {
      set_executable(from.executable());
    }
    if (from.has_extract()) {
      set_extract(from.extract());
    }
    if (from.has_cache()) {
      set_cache(from.cache());
    }
    if (from.has_output_file()) {
      set_has_output_file();
      output_file_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.output_file_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CommandInfo_URI::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CommandInfo.URI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommandInfo_URI::CopyFrom(const CommandInfo_URI& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CommandInfo.URI)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInfo_URI::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CommandInfo_URI::Swap(CommandInfo_URI* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommandInfo_URI::InternalSwap(CommandInfo_URI* other) {
  value_.Swap(&other->value_);
  std::swap(executable_, other->executable_);
  std::swap(extract_, other->extract_);
  std::swap(cache_, other->cache_);
  output_file_.Swap(&other->output_file_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CommandInfo_URI::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommandInfo_URI_descriptor_;
  metadata.reflection = CommandInfo_URI_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CommandInfo::kUrisFieldNumber;
const int CommandInfo::kEnvironmentFieldNumber;
const int CommandInfo::kShellFieldNumber;
const int CommandInfo::kValueFieldNumber;
const int CommandInfo::kArgumentsFieldNumber;
const int CommandInfo::kUserFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CommandInfo::CommandInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CommandInfo)
}

void CommandInfo::InitAsDefaultInstance() {
  environment_ = const_cast< ::mesos::Environment*>(&::mesos::Environment::default_instance());
}

CommandInfo::CommandInfo(const CommandInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CommandInfo)
}

void CommandInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  environment_ = NULL;
  shell_ = true;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CommandInfo::~CommandInfo() {
  // @@protoc_insertion_point(destructor:mesos.CommandInfo)
  SharedDtor();
}

void CommandInfo::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete environment_;
  }
}

void CommandInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CommandInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CommandInfo_descriptor_;
}

const CommandInfo& CommandInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CommandInfo* CommandInfo::default_instance_ = NULL;

CommandInfo* CommandInfo::New(::google::protobuf::Arena* arena) const {
  CommandInfo* n = new CommandInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CommandInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CommandInfo)
  if (_has_bits_[0 / 32] & 46u) {
    if (has_environment()) {
      if (environment_ != NULL) environment_->::mesos::Environment::Clear();
    }
    shell_ = true;
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_user()) {
      user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  uris_.Clear();
  arguments_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CommandInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CommandInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.CommandInfo.URI uris = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_uris:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_uris()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_uris;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(18)) goto parse_environment;
        break;
      }

      // optional .mesos.Environment environment = 2;
      case 2: {
        if (tag == 18) {
         parse_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_environment()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional string value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.CommandInfo.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_user;
        break;
      }

      // optional string user = 5;
      case 5: {
        if (tag == 42) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.CommandInfo.user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_shell;
        break;
      }

      // optional bool shell = 6 [default = true];
      case 6: {
        if (tag == 48) {
         parse_shell:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &shell_)));
          set_has_shell();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_arguments;
        break;
      }

      // repeated string arguments = 7;
      case 7: {
        if (tag == 58) {
         parse_arguments:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_arguments()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->arguments(this->arguments_size() - 1).data(),
            this->arguments(this->arguments_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.CommandInfo.arguments");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_arguments;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CommandInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CommandInfo)
  return false;
#undef DO_
}

void CommandInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CommandInfo)
  // repeated .mesos.CommandInfo.URI uris = 1;
  for (unsigned int i = 0, n = this->uris_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->uris(i), output);
  }

  // optional .mesos.Environment environment = 2;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->environment_, output);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->value(), output);
  }

  // optional string user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->user(), output);
  }

  // optional bool shell = 6 [default = true];
  if (has_shell()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->shell(), output);
  }

  // repeated string arguments = 7;
  for (int i = 0; i < this->arguments_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->arguments(i).data(), this->arguments(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.arguments");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->arguments(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CommandInfo)
}

::google::protobuf::uint8* CommandInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CommandInfo)
  // repeated .mesos.CommandInfo.URI uris = 1;
  for (unsigned int i = 0, n = this->uris_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->uris(i), false, target);
  }

  // optional .mesos.Environment environment = 2;
  if (has_environment()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->environment_, false, target);
  }

  // optional string value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->value(), target);
  }

  // optional string user = 5;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->user(), target);
  }

  // optional bool shell = 6 [default = true];
  if (has_shell()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->shell(), target);
  }

  // repeated string arguments = 7;
  for (int i = 0; i < this->arguments_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->arguments(i).data(), this->arguments(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.CommandInfo.arguments");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(7, this->arguments(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CommandInfo)
  return target;
}

int CommandInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CommandInfo)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 46u) {
    // optional .mesos.Environment environment = 2;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->environment_);
    }

    // optional bool shell = 6 [default = true];
    if (has_shell()) {
      total_size += 1 + 1;
    }

    // optional string value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional string user = 5;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

  }
  // repeated .mesos.CommandInfo.URI uris = 1;
  total_size += 1 * this->uris_size();
  for (int i = 0; i < this->uris_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->uris(i));
  }

  // repeated string arguments = 7;
  total_size += 1 * this->arguments_size();
  for (int i = 0; i < this->arguments_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->arguments(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CommandInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CommandInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CommandInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CommandInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CommandInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CommandInfo)
    MergeFrom(*source);
  }
}

void CommandInfo::MergeFrom(const CommandInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CommandInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  uris_.MergeFrom(from.uris_);
  arguments_.MergeFrom(from.arguments_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_environment()) {
      mutable_environment()->::mesos::Environment::MergeFrom(from.environment());
    }
    if (from.has_shell()) {
      set_shell(from.shell());
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_user()) {
      set_has_user();
      user_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CommandInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CommandInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CommandInfo::CopyFrom(const CommandInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CommandInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CommandInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->uris())) return false;
  if (has_environment()) {
    if (!this->environment_->IsInitialized()) return false;
  }
  return true;
}

void CommandInfo::Swap(CommandInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CommandInfo::InternalSwap(CommandInfo* other) {
  uris_.UnsafeArenaSwap(&other->uris_);
  std::swap(environment_, other->environment_);
  std::swap(shell_, other->shell_);
  value_.Swap(&other->value_);
  arguments_.UnsafeArenaSwap(&other->arguments_);
  user_.Swap(&other->user_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CommandInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CommandInfo_descriptor_;
  metadata.reflection = CommandInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CommandInfo_URI

// required string value = 1;
bool CommandInfo_URI::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CommandInfo_URI::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void CommandInfo_URI::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void CommandInfo_URI::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& CommandInfo_URI::value() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo_URI::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.value)
}
 void CommandInfo_URI::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.URI.value)
}
 void CommandInfo_URI::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.URI.value)
}
 ::std::string* CommandInfo_URI::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.URI.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CommandInfo_URI::release_value() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.URI.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo_URI::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.URI.value)
}

// optional bool executable = 2;
bool CommandInfo_URI::has_executable() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CommandInfo_URI::set_has_executable() {
  _has_bits_[0] |= 0x00000002u;
}
void CommandInfo_URI::clear_has_executable() {
  _has_bits_[0] &= ~0x00000002u;
}
void CommandInfo_URI::clear_executable() {
  executable_ = false;
  clear_has_executable();
}
 bool CommandInfo_URI::executable() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.executable)
  return executable_;
}
 void CommandInfo_URI::set_executable(bool value) {
  set_has_executable();
  executable_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.executable)
}

// optional bool extract = 3 [default = true];
bool CommandInfo_URI::has_extract() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CommandInfo_URI::set_has_extract() {
  _has_bits_[0] |= 0x00000004u;
}
void CommandInfo_URI::clear_has_extract() {
  _has_bits_[0] &= ~0x00000004u;
}
void CommandInfo_URI::clear_extract() {
  extract_ = true;
  clear_has_extract();
}
 bool CommandInfo_URI::extract() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.extract)
  return extract_;
}
 void CommandInfo_URI::set_extract(bool value) {
  set_has_extract();
  extract_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.extract)
}

// optional bool cache = 4;
bool CommandInfo_URI::has_cache() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CommandInfo_URI::set_has_cache() {
  _has_bits_[0] |= 0x00000008u;
}
void CommandInfo_URI::clear_has_cache() {
  _has_bits_[0] &= ~0x00000008u;
}
void CommandInfo_URI::clear_cache() {
  cache_ = false;
  clear_has_cache();
}
 bool CommandInfo_URI::cache() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.cache)
  return cache_;
}
 void CommandInfo_URI::set_cache(bool value) {
  set_has_cache();
  cache_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.cache)
}

// optional string output_file = 5;
bool CommandInfo_URI::has_output_file() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void CommandInfo_URI::set_has_output_file() {
  _has_bits_[0] |= 0x00000010u;
}
void CommandInfo_URI::clear_has_output_file() {
  _has_bits_[0] &= ~0x00000010u;
}
void CommandInfo_URI::clear_output_file() {
  output_file_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_output_file();
}
 const ::std::string& CommandInfo_URI::output_file() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.URI.output_file)
  return output_file_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo_URI::set_output_file(const ::std::string& value) {
  set_has_output_file();
  output_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.URI.output_file)
}
 void CommandInfo_URI::set_output_file(const char* value) {
  set_has_output_file();
  output_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.URI.output_file)
}
 void CommandInfo_URI::set_output_file(const char* value, size_t size) {
  set_has_output_file();
  output_file_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.URI.output_file)
}
 ::std::string* CommandInfo_URI::mutable_output_file() {
  set_has_output_file();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.URI.output_file)
  return output_file_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CommandInfo_URI::release_output_file() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.URI.output_file)
  clear_has_output_file();
  return output_file_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo_URI::set_allocated_output_file(::std::string* output_file) {
  if (output_file != NULL) {
    set_has_output_file();
  } else {
    clear_has_output_file();
  }
  output_file_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), output_file);
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.URI.output_file)
}

// -------------------------------------------------------------------

// CommandInfo

// repeated .mesos.CommandInfo.URI uris = 1;
int CommandInfo::uris_size() const {
  return uris_.size();
}
void CommandInfo::clear_uris() {
  uris_.Clear();
}
const ::mesos::CommandInfo_URI& CommandInfo::uris(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.uris)
  return uris_.Get(index);
}
::mesos::CommandInfo_URI* CommandInfo::mutable_uris(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.uris)
  return uris_.Mutable(index);
}
::mesos::CommandInfo_URI* CommandInfo::add_uris() {
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.uris)
  return uris_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >*
CommandInfo::mutable_uris() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CommandInfo.uris)
  return &uris_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::CommandInfo_URI >&
CommandInfo::uris() const {
  // @@protoc_insertion_point(field_list:mesos.CommandInfo.uris)
  return uris_;
}

// optional .mesos.Environment environment = 2;
bool CommandInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CommandInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000002u;
}
void CommandInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000002u;
}
void CommandInfo::clear_environment() {
  if (environment_ != NULL) environment_->::mesos::Environment::Clear();
  clear_has_environment();
}
const ::mesos::Environment& CommandInfo::environment() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.environment)
  return environment_ != NULL ? *environment_ : *default_instance_->environment_;
}
::mesos::Environment* CommandInfo::mutable_environment() {
  set_has_environment();
  if (environment_ == NULL) {
    environment_ = new ::mesos::Environment;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.environment)
  return environment_;
}
::mesos::Environment* CommandInfo::release_environment() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.environment)
  clear_has_environment();
  ::mesos::Environment* temp = environment_;
  environment_ = NULL;
  return temp;
}
void CommandInfo::set_allocated_environment(::mesos::Environment* environment) {
  delete environment_;
  environment_ = environment;
  if (environment) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.environment)
}

// optional bool shell = 6 [default = true];
bool CommandInfo::has_shell() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CommandInfo::set_has_shell() {
  _has_bits_[0] |= 0x00000004u;
}
void CommandInfo::clear_has_shell() {
  _has_bits_[0] &= ~0x00000004u;
}
void CommandInfo::clear_shell() {
  shell_ = true;
  clear_has_shell();
}
 bool CommandInfo::shell() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.shell)
  return shell_;
}
 void CommandInfo::set_shell(bool value) {
  set_has_shell();
  shell_ = value;
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.shell)
}

// optional string value = 3;
bool CommandInfo::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void CommandInfo::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
void CommandInfo::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
void CommandInfo::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& CommandInfo::value() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.value)
}
 void CommandInfo::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.value)
}
 void CommandInfo::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.value)
}
 ::std::string* CommandInfo::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CommandInfo::release_value() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.value)
}

// repeated string arguments = 7;
int CommandInfo::arguments_size() const {
  return arguments_.size();
}
void CommandInfo::clear_arguments() {
  arguments_.Clear();
}
 const ::std::string& CommandInfo::arguments(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.arguments)
  return arguments_.Get(index);
}
 ::std::string* CommandInfo::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.arguments)
  return arguments_.Mutable(index);
}
 void CommandInfo::set_arguments(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.arguments)
  arguments_.Mutable(index)->assign(value);
}
 void CommandInfo::set_arguments(int index, const char* value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.arguments)
}
 void CommandInfo::set_arguments(int index, const char* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.arguments)
}
 ::std::string* CommandInfo::add_arguments() {
  // @@protoc_insertion_point(field_add_mutable:mesos.CommandInfo.arguments)
  return arguments_.Add();
}
 void CommandInfo::add_arguments(const ::std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.CommandInfo.arguments)
}
 void CommandInfo::add_arguments(const char* value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.CommandInfo.arguments)
}
 void CommandInfo::add_arguments(const char* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.CommandInfo.arguments)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
CommandInfo::arguments() const {
  // @@protoc_insertion_point(field_list:mesos.CommandInfo.arguments)
  return arguments_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
CommandInfo::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CommandInfo.arguments)
  return &arguments_;
}

// optional string user = 5;
bool CommandInfo::has_user() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void CommandInfo::set_has_user() {
  _has_bits_[0] |= 0x00000020u;
}
void CommandInfo::clear_has_user() {
  _has_bits_[0] &= ~0x00000020u;
}
void CommandInfo::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
 const ::std::string& CommandInfo::user() const {
  // @@protoc_insertion_point(field_get:mesos.CommandInfo.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.CommandInfo.user)
}
 void CommandInfo::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.CommandInfo.user)
}
 void CommandInfo::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.CommandInfo.user)
}
 ::std::string* CommandInfo::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.CommandInfo.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* CommandInfo::release_user() {
  // @@protoc_insertion_point(field_release:mesos.CommandInfo.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void CommandInfo::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mesos.CommandInfo.user)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ExecutorInfo_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorInfo_Type_descriptor_;
}
bool ExecutorInfo_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ExecutorInfo_Type ExecutorInfo::UNKNOWN;
const ExecutorInfo_Type ExecutorInfo::DEFAULT;
const ExecutorInfo_Type ExecutorInfo::CUSTOM;
const ExecutorInfo_Type ExecutorInfo::Type_MIN;
const ExecutorInfo_Type ExecutorInfo::Type_MAX;
const int ExecutorInfo::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ExecutorInfo::kTypeFieldNumber;
const int ExecutorInfo::kExecutorIdFieldNumber;
const int ExecutorInfo::kFrameworkIdFieldNumber;
const int ExecutorInfo::kCommandFieldNumber;
const int ExecutorInfo::kContainerFieldNumber;
const int ExecutorInfo::kResourcesFieldNumber;
const int ExecutorInfo::kNameFieldNumber;
const int ExecutorInfo::kSourceFieldNumber;
const int ExecutorInfo::kDataFieldNumber;
const int ExecutorInfo::kDiscoveryFieldNumber;
const int ExecutorInfo::kShutdownGracePeriodFieldNumber;
const int ExecutorInfo::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ExecutorInfo::ExecutorInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ExecutorInfo)
}

void ExecutorInfo::InitAsDefaultInstance() {
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  container_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
  shutdown_grace_period_ = const_cast< ::mesos::DurationInfo*>(&::mesos::DurationInfo::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

ExecutorInfo::ExecutorInfo(const ExecutorInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ExecutorInfo)
}

void ExecutorInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  executor_id_ = NULL;
  framework_id_ = NULL;
  command_ = NULL;
  container_ = NULL;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  discovery_ = NULL;
  shutdown_grace_period_ = NULL;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ExecutorInfo::~ExecutorInfo() {
  // @@protoc_insertion_point(destructor:mesos.ExecutorInfo)
  SharedDtor();
}

void ExecutorInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete executor_id_;
    delete framework_id_;
    delete command_;
    delete container_;
    delete discovery_;
    delete shutdown_grace_period_;
    delete labels_;
  }
}

void ExecutorInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ExecutorInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ExecutorInfo_descriptor_;
}

const ExecutorInfo& ExecutorInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ExecutorInfo* ExecutorInfo::default_instance_ = NULL;

ExecutorInfo* ExecutorInfo::New(::google::protobuf::Arena* arena) const {
  ExecutorInfo* n = new ExecutorInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ExecutorInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ExecutorInfo)
  if (_has_bits_[0 / 32] & 223u) {
    type_ = 0;
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
    }
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_source()) {
      source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  if (_has_bits_[8 / 32] & 3840u) {
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
    if (has_shutdown_grace_period()) {
      if (shutdown_grace_period_ != NULL) shutdown_grace_period_->::mesos::DurationInfo::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ExecutorInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ExecutorInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorID executor_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_data;
        break;
      }

      // optional bytes data = 4;
      case 4: {
        if (tag == 34) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 5;
      case 5: {
        if (tag == 42) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(58)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 7;
      case 7: {
        if (tag == 58) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_framework_id;
        break;
      }

      // optional .mesos.FrameworkID framework_id = 8;
      case 8: {
        if (tag == 66) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_name;
        break;
      }

      // optional string name = 9;
      case 9: {
        if (tag == 74) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ExecutorInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_source;
        break;
      }

      // optional string source = 10 [deprecated = true];
      case 10: {
        if (tag == 82) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_source()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->source().data(), this->source().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ExecutorInfo.source");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_container;
        break;
      }

      // optional .mesos.ContainerInfo container = 11;
      case 11: {
        if (tag == 90) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 12;
      case 12: {
        if (tag == 98) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_shutdown_grace_period;
        break;
      }

      // optional .mesos.DurationInfo shutdown_grace_period = 13;
      case 13: {
        if (tag == 106) {
         parse_shutdown_grace_period:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shutdown_grace_period()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 14;
      case 14: {
        if (tag == 114) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_type;
        break;
      }

      // optional .mesos.ExecutorInfo.Type type = 15;
      case 15: {
        if (tag == 120) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::ExecutorInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::ExecutorInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(15, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ExecutorInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ExecutorInfo)
  return false;
#undef DO_
}

void ExecutorInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ExecutorInfo)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->executor_id_, output);
  }

  // optional bytes data = 4;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->data(), output);
  }

  // repeated .mesos.Resource resources = 5;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->resources(i), output);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->command_, output);
  }

  // optional .mesos.FrameworkID framework_id = 8;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->framework_id_, output);
  }

  // optional string name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ExecutorInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      9, this->name(), output);
  }

  // optional string source = 10 [deprecated = true];
  if (has_source()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source().data(), this->source().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ExecutorInfo.source");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      10, this->source(), output);
  }

  // optional .mesos.ContainerInfo container = 11;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->container_, output);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->discovery_, output);
  }

  // optional .mesos.DurationInfo shutdown_grace_period = 13;
  if (has_shutdown_grace_period()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->shutdown_grace_period_, output);
  }

  // optional .mesos.Labels labels = 14;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->labels_, output);
  }

  // optional .mesos.ExecutorInfo.Type type = 15;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      15, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ExecutorInfo)
}

::google::protobuf::uint8* ExecutorInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ExecutorInfo)
  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->executor_id_, false, target);
  }

  // optional bytes data = 4;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->data(), target);
  }

  // repeated .mesos.Resource resources = 5;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->resources(i), false, target);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->command_, false, target);
  }

  // optional .mesos.FrameworkID framework_id = 8;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->framework_id_, false, target);
  }

  // optional string name = 9;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ExecutorInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        9, this->name(), target);
  }

  // optional string source = 10 [deprecated = true];
  if (has_source()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->source().data(), this->source().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ExecutorInfo.source");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        10, this->source(), target);
  }

  // optional .mesos.ContainerInfo container = 11;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->container_, false, target);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *this->discovery_, false, target);
  }

  // optional .mesos.DurationInfo shutdown_grace_period = 13;
  if (has_shutdown_grace_period()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->shutdown_grace_period_, false, target);
  }

  // optional .mesos.Labels labels = 14;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, *this->labels_, false, target);
  }

  // optional .mesos.ExecutorInfo.Type type = 15;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      15, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ExecutorInfo)
  return target;
}

int ExecutorInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ExecutorInfo)
  int total_size = 0;

  // required .mesos.ExecutorID executor_id = 1;
  if (has_executor_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->executor_id_);
  }
  if (_has_bits_[0 / 32] & 221u) {
    // optional .mesos.ExecutorInfo.Type type = 15;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.FrameworkID framework_id = 8;
    if (has_framework_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->framework_id_);
    }

    // optional .mesos.CommandInfo command = 7;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->command_);
    }

    // optional .mesos.ContainerInfo container = 11;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->container_);
    }

    // optional string name = 9;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string source = 10 [deprecated = true];
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->source());
    }

  }
  if (_has_bits_[8 / 32] & 3840u) {
    // optional bytes data = 4;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .mesos.DiscoveryInfo discovery = 12;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->discovery_);
    }

    // optional .mesos.DurationInfo shutdown_grace_period = 13;
    if (has_shutdown_grace_period()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->shutdown_grace_period_);
    }

    // optional .mesos.Labels labels = 14;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  // repeated .mesos.Resource resources = 5;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ExecutorInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ExecutorInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ExecutorInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ExecutorInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ExecutorInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ExecutorInfo)
    MergeFrom(*source);
  }
}

void ExecutorInfo::MergeFrom(const ExecutorInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ExecutorInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_container()) {
      mutable_container()->::mesos::ContainerInfo::MergeFrom(from.container());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_source()) {
      set_has_source();
      source_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.source_);
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
    if (from.has_shutdown_grace_period()) {
      mutable_shutdown_grace_period()->::mesos::DurationInfo::MergeFrom(from.shutdown_grace_period());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ExecutorInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ExecutorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ExecutorInfo::CopyFrom(const ExecutorInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ExecutorInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ExecutorInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_executor_id()) {
    if (!this->executor_id_->IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id_->IsInitialized()) return false;
  }
  if (has_command()) {
    if (!this->command_->IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_discovery()) {
    if (!this->discovery_->IsInitialized()) return false;
  }
  if (has_shutdown_grace_period()) {
    if (!this->shutdown_grace_period_->IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void ExecutorInfo::Swap(ExecutorInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ExecutorInfo::InternalSwap(ExecutorInfo* other) {
  std::swap(type_, other->type_);
  std::swap(executor_id_, other->executor_id_);
  std::swap(framework_id_, other->framework_id_);
  std::swap(command_, other->command_);
  std::swap(container_, other->container_);
  resources_.UnsafeArenaSwap(&other->resources_);
  name_.Swap(&other->name_);
  source_.Swap(&other->source_);
  data_.Swap(&other->data_);
  std::swap(discovery_, other->discovery_);
  std::swap(shutdown_grace_period_, other->shutdown_grace_period_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ExecutorInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ExecutorInfo_descriptor_;
  metadata.reflection = ExecutorInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ExecutorInfo

// optional .mesos.ExecutorInfo.Type type = 15;
bool ExecutorInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ExecutorInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ExecutorInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ExecutorInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::ExecutorInfo_Type ExecutorInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.type)
  return static_cast< ::mesos::ExecutorInfo_Type >(type_);
}
 void ExecutorInfo::set_type(::mesos::ExecutorInfo_Type value) {
  assert(::mesos::ExecutorInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.type)
}

// required .mesos.ExecutorID executor_id = 1;
bool ExecutorInfo::has_executor_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ExecutorInfo::set_has_executor_id() {
  _has_bits_[0] |= 0x00000002u;
}
void ExecutorInfo::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void ExecutorInfo::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
const ::mesos::ExecutorID& ExecutorInfo::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
::mesos::ExecutorID* ExecutorInfo::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    executor_id_ = new ::mesos::ExecutorID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.executor_id)
  return executor_id_;
}
::mesos::ExecutorID* ExecutorInfo::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.executor_id)
}

// optional .mesos.FrameworkID framework_id = 8;
bool ExecutorInfo::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ExecutorInfo::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
void ExecutorInfo::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void ExecutorInfo::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
const ::mesos::FrameworkID& ExecutorInfo::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
::mesos::FrameworkID* ExecutorInfo::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    framework_id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.framework_id)
  return framework_id_;
}
::mesos::FrameworkID* ExecutorInfo::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.framework_id)
}

// optional .mesos.CommandInfo command = 7;
bool ExecutorInfo::has_command() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ExecutorInfo::set_has_command() {
  _has_bits_[0] |= 0x00000008u;
}
void ExecutorInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000008u;
}
void ExecutorInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
const ::mesos::CommandInfo& ExecutorInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
::mesos::CommandInfo* ExecutorInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.command)
  return command_;
}
::mesos::CommandInfo* ExecutorInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.command)
}

// optional .mesos.ContainerInfo container = 11;
bool ExecutorInfo::has_container() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ExecutorInfo::set_has_container() {
  _has_bits_[0] |= 0x00000010u;
}
void ExecutorInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000010u;
}
void ExecutorInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
const ::mesos::ContainerInfo& ExecutorInfo::container() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
::mesos::ContainerInfo* ExecutorInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    container_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.container)
  return container_;
}
::mesos::ContainerInfo* ExecutorInfo::release_container() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.container)
}

// repeated .mesos.Resource resources = 5;
int ExecutorInfo::resources_size() const {
  return resources_.size();
}
void ExecutorInfo::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& ExecutorInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.resources)
  return resources_.Get(index);
}
::mesos::Resource* ExecutorInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* ExecutorInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.ExecutorInfo.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ExecutorInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ExecutorInfo.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ExecutorInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.ExecutorInfo.resources)
  return resources_;
}

// optional string name = 9;
bool ExecutorInfo::has_name() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ExecutorInfo::set_has_name() {
  _has_bits_[0] |= 0x00000040u;
}
void ExecutorInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000040u;
}
void ExecutorInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& ExecutorInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.name)
}
 void ExecutorInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.name)
}
 void ExecutorInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.name)
}
 ::std::string* ExecutorInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExecutorInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.name)
}

// optional string source = 10 [deprecated = true];
bool ExecutorInfo::has_source() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ExecutorInfo::set_has_source() {
  _has_bits_[0] |= 0x00000080u;
}
void ExecutorInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000080u;
}
void ExecutorInfo::clear_source() {
  source_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_source();
}
 const ::std::string& ExecutorInfo::source() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.source)
  return source_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorInfo::set_source(const ::std::string& value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.source)
}
 void ExecutorInfo::set_source(const char* value) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.source)
}
 void ExecutorInfo::set_source(const char* value, size_t size) {
  set_has_source();
  source_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.source)
}
 ::std::string* ExecutorInfo::mutable_source() {
  set_has_source();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.source)
  return source_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExecutorInfo::release_source() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.source)
  clear_has_source();
  return source_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorInfo::set_allocated_source(::std::string* source) {
  if (source != NULL) {
    set_has_source();
  } else {
    clear_has_source();
  }
  source_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), source);
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.source)
}

// optional bytes data = 4;
bool ExecutorInfo::has_data() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ExecutorInfo::set_has_data() {
  _has_bits_[0] |= 0x00000100u;
}
void ExecutorInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000100u;
}
void ExecutorInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& ExecutorInfo::data() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorInfo::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ExecutorInfo.data)
}
 void ExecutorInfo::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ExecutorInfo.data)
}
 void ExecutorInfo::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ExecutorInfo.data)
}
 ::std::string* ExecutorInfo::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ExecutorInfo::release_data() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ExecutorInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.data)
}

// optional .mesos.DiscoveryInfo discovery = 12;
bool ExecutorInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ExecutorInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00000200u;
}
void ExecutorInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000200u;
}
void ExecutorInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
const ::mesos::DiscoveryInfo& ExecutorInfo::discovery() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.discovery)
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
::mesos::DiscoveryInfo* ExecutorInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) {
    discovery_ = new ::mesos::DiscoveryInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.discovery)
  return discovery_;
}
::mesos::DiscoveryInfo* ExecutorInfo::release_discovery() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.discovery)
}

// optional .mesos.DurationInfo shutdown_grace_period = 13;
bool ExecutorInfo::has_shutdown_grace_period() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ExecutorInfo::set_has_shutdown_grace_period() {
  _has_bits_[0] |= 0x00000400u;
}
void ExecutorInfo::clear_has_shutdown_grace_period() {
  _has_bits_[0] &= ~0x00000400u;
}
void ExecutorInfo::clear_shutdown_grace_period() {
  if (shutdown_grace_period_ != NULL) shutdown_grace_period_->::mesos::DurationInfo::Clear();
  clear_has_shutdown_grace_period();
}
const ::mesos::DurationInfo& ExecutorInfo::shutdown_grace_period() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.shutdown_grace_period)
  return shutdown_grace_period_ != NULL ? *shutdown_grace_period_ : *default_instance_->shutdown_grace_period_;
}
::mesos::DurationInfo* ExecutorInfo::mutable_shutdown_grace_period() {
  set_has_shutdown_grace_period();
  if (shutdown_grace_period_ == NULL) {
    shutdown_grace_period_ = new ::mesos::DurationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.shutdown_grace_period)
  return shutdown_grace_period_;
}
::mesos::DurationInfo* ExecutorInfo::release_shutdown_grace_period() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.shutdown_grace_period)
  clear_has_shutdown_grace_period();
  ::mesos::DurationInfo* temp = shutdown_grace_period_;
  shutdown_grace_period_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_shutdown_grace_period(::mesos::DurationInfo* shutdown_grace_period) {
  delete shutdown_grace_period_;
  shutdown_grace_period_ = shutdown_grace_period;
  if (shutdown_grace_period) {
    set_has_shutdown_grace_period();
  } else {
    clear_has_shutdown_grace_period();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.shutdown_grace_period)
}

// optional .mesos.Labels labels = 14;
bool ExecutorInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ExecutorInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000800u;
}
void ExecutorInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000800u;
}
void ExecutorInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& ExecutorInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.ExecutorInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* ExecutorInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ExecutorInfo.labels)
  return labels_;
}
::mesos::Labels* ExecutorInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.ExecutorInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void ExecutorInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ExecutorInfo.labels)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int MasterInfo::kIdFieldNumber;
const int MasterInfo::kIpFieldNumber;
const int MasterInfo::kPortFieldNumber;
const int MasterInfo::kPidFieldNumber;
const int MasterInfo::kHostnameFieldNumber;
const int MasterInfo::kVersionFieldNumber;
const int MasterInfo::kAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

MasterInfo::MasterInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.MasterInfo)
}

void MasterInfo::InitAsDefaultInstance() {
  address_ = const_cast< ::mesos::Address*>(&::mesos::Address::default_instance());
}

MasterInfo::MasterInfo(const MasterInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.MasterInfo)
}

void MasterInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ip_ = 0u;
  port_ = 5050u;
  pid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  address_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MasterInfo::~MasterInfo() {
  // @@protoc_insertion_point(destructor:mesos.MasterInfo)
  SharedDtor();
}

void MasterInfo::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  pid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete address_;
  }
}

void MasterInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MasterInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MasterInfo_descriptor_;
}

const MasterInfo& MasterInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

MasterInfo* MasterInfo::default_instance_ = NULL;

MasterInfo* MasterInfo::New(::google::protobuf::Arena* arena) const {
  MasterInfo* n = new MasterInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void MasterInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.MasterInfo)
  if (_has_bits_[0 / 32] & 127u) {
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    ip_ = 0u;
    port_ = 5050u;
    if (has_pid()) {
      pid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_version()) {
      version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_address()) {
      if (address_ != NULL) address_->::mesos::Address::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool MasterInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.MasterInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.MasterInfo.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_ip;
        break;
      }

      // required uint32 ip = 2;
      case 2: {
        if (tag == 16) {
         parse_ip:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &ip_)));
          set_has_ip();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_port;
        break;
      }

      // required uint32 port = 3 [default = 5050];
      case 3: {
        if (tag == 24) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_pid;
        break;
      }

      // optional string pid = 4;
      case 4: {
        if (tag == 34) {
         parse_pid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_pid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->pid().data(), this->pid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.MasterInfo.pid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_hostname;
        break;
      }

      // optional string hostname = 5;
      case 5: {
        if (tag == 42) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.MasterInfo.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_version;
        break;
      }

      // optional string version = 6;
      case 6: {
        if (tag == 50) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.MasterInfo.version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_address;
        break;
      }

      // optional .mesos.Address address = 7;
      case 7: {
        if (tag == 58) {
         parse_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.MasterInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.MasterInfo)
  return false;
#undef DO_
}

void MasterInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.MasterInfo)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // required uint32 ip = 2;
  if (has_ip()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->ip(), output);
  }

  // required uint32 port = 3 [default = 5050];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->port(), output);
  }

  // optional string pid = 4;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.pid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->pid(), output);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->hostname(), output);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->version(), output);
  }

  // optional .mesos.Address address = 7;
  if (has_address()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->address_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.MasterInfo)
}

::google::protobuf::uint8* MasterInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.MasterInfo)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // required uint32 ip = 2;
  if (has_ip()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->ip(), target);
  }

  // required uint32 port = 3 [default = 5050];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->port(), target);
  }

  // optional string pid = 4;
  if (has_pid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->pid().data(), this->pid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.pid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->pid(), target);
  }

  // optional string hostname = 5;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->hostname(), target);
  }

  // optional string version = 6;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.MasterInfo.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->version(), target);
  }

  // optional .mesos.Address address = 7;
  if (has_address()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->address_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.MasterInfo)
  return target;
}

int MasterInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.MasterInfo)
  int total_size = 0;

  if (has_id()) {
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }

  if (has_ip()) {
    // required uint32 ip = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ip());
  }

  if (has_port()) {
    // required uint32 port = 3 [default = 5050];
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());
  }

  return total_size;
}
int MasterInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.MasterInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());

    // required uint32 ip = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->ip());

    // required uint32 port = 3 [default = 5050];
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[3 / 32] & 120u) {
    // optional string pid = 4;
    if (has_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->pid());
    }

    // optional string hostname = 5;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional string version = 6;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .mesos.Address address = 7;
    if (has_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->address_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MasterInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.MasterInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const MasterInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const MasterInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.MasterInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.MasterInfo)
    MergeFrom(*source);
  }
}

void MasterInfo::MergeFrom(const MasterInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.MasterInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_ip()) {
      set_ip(from.ip());
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_pid()) {
      set_has_pid();
      pid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.pid_);
    }
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_version()) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (from.has_address()) {
      mutable_address()->::mesos::Address::MergeFrom(from.address());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void MasterInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.MasterInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MasterInfo::CopyFrom(const MasterInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.MasterInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MasterInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  return true;
}

void MasterInfo::Swap(MasterInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void MasterInfo::InternalSwap(MasterInfo* other) {
  id_.Swap(&other->id_);
  std::swap(ip_, other->ip_);
  std::swap(port_, other->port_);
  pid_.Swap(&other->pid_);
  hostname_.Swap(&other->hostname_);
  version_.Swap(&other->version_);
  std::swap(address_, other->address_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata MasterInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MasterInfo_descriptor_;
  metadata.reflection = MasterInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// MasterInfo

// required string id = 1;
bool MasterInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void MasterInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void MasterInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void MasterInfo::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& MasterInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.id)
}
 void MasterInfo::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.id)
}
 void MasterInfo::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.id)
}
 ::std::string* MasterInfo::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MasterInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.id)
}

// required uint32 ip = 2;
bool MasterInfo::has_ip() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void MasterInfo::set_has_ip() {
  _has_bits_[0] |= 0x00000002u;
}
void MasterInfo::clear_has_ip() {
  _has_bits_[0] &= ~0x00000002u;
}
void MasterInfo::clear_ip() {
  ip_ = 0u;
  clear_has_ip();
}
 ::google::protobuf::uint32 MasterInfo::ip() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.ip)
  return ip_;
}
 void MasterInfo::set_ip(::google::protobuf::uint32 value) {
  set_has_ip();
  ip_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.ip)
}

// required uint32 port = 3 [default = 5050];
bool MasterInfo::has_port() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void MasterInfo::set_has_port() {
  _has_bits_[0] |= 0x00000004u;
}
void MasterInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000004u;
}
void MasterInfo::clear_port() {
  port_ = 5050u;
  clear_has_port();
}
 ::google::protobuf::uint32 MasterInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.port)
  return port_;
}
 void MasterInfo::set_port(::google::protobuf::uint32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.port)
}

// optional string pid = 4;
bool MasterInfo::has_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void MasterInfo::set_has_pid() {
  _has_bits_[0] |= 0x00000008u;
}
void MasterInfo::clear_has_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
void MasterInfo::clear_pid() {
  pid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_pid();
}
 const ::std::string& MasterInfo::pid() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.pid)
  return pid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_pid(const ::std::string& value) {
  set_has_pid();
  pid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.pid)
}
 void MasterInfo::set_pid(const char* value) {
  set_has_pid();
  pid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.pid)
}
 void MasterInfo::set_pid(const char* value, size_t size) {
  set_has_pid();
  pid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.pid)
}
 ::std::string* MasterInfo::mutable_pid() {
  set_has_pid();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.pid)
  return pid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MasterInfo::release_pid() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.pid)
  clear_has_pid();
  return pid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_allocated_pid(::std::string* pid) {
  if (pid != NULL) {
    set_has_pid();
  } else {
    clear_has_pid();
  }
  pid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pid);
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.pid)
}

// optional string hostname = 5;
bool MasterInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void MasterInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000010u;
}
void MasterInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000010u;
}
void MasterInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& MasterInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.hostname)
}
 void MasterInfo::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.hostname)
}
 void MasterInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.hostname)
}
 ::std::string* MasterInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MasterInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.hostname)
}

// optional string version = 6;
bool MasterInfo::has_version() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void MasterInfo::set_has_version() {
  _has_bits_[0] |= 0x00000020u;
}
void MasterInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000020u;
}
void MasterInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
 const ::std::string& MasterInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.MasterInfo.version)
}
 void MasterInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.MasterInfo.version)
}
 void MasterInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.MasterInfo.version)
}
 ::std::string* MasterInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* MasterInfo::release_version() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void MasterInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.version)
}

// optional .mesos.Address address = 7;
bool MasterInfo::has_address() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void MasterInfo::set_has_address() {
  _has_bits_[0] |= 0x00000040u;
}
void MasterInfo::clear_has_address() {
  _has_bits_[0] &= ~0x00000040u;
}
void MasterInfo::clear_address() {
  if (address_ != NULL) address_->::mesos::Address::Clear();
  clear_has_address();
}
const ::mesos::Address& MasterInfo::address() const {
  // @@protoc_insertion_point(field_get:mesos.MasterInfo.address)
  return address_ != NULL ? *address_ : *default_instance_->address_;
}
::mesos::Address* MasterInfo::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    address_ = new ::mesos::Address;
  }
  // @@protoc_insertion_point(field_mutable:mesos.MasterInfo.address)
  return address_;
}
::mesos::Address* MasterInfo::release_address() {
  // @@protoc_insertion_point(field_release:mesos.MasterInfo.address)
  clear_has_address();
  ::mesos::Address* temp = address_;
  address_ = NULL;
  return temp;
}
void MasterInfo::set_allocated_address(::mesos::Address* address) {
  delete address_;
  address_ = address;
  if (address) {
    set_has_address();
  } else {
    clear_has_address();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.MasterInfo.address)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* SlaveInfo_Capability_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveInfo_Capability_Type_descriptor_;
}
bool SlaveInfo_Capability_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const SlaveInfo_Capability_Type SlaveInfo_Capability::UNKNOWN;
const SlaveInfo_Capability_Type SlaveInfo_Capability::MULTI_ROLE;
const SlaveInfo_Capability_Type SlaveInfo_Capability::Type_MIN;
const SlaveInfo_Capability_Type SlaveInfo_Capability::Type_MAX;
const int SlaveInfo_Capability::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SlaveInfo_Capability::kTypeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SlaveInfo_Capability::SlaveInfo_Capability()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SlaveInfo.Capability)
}

void SlaveInfo_Capability::InitAsDefaultInstance() {
}

SlaveInfo_Capability::SlaveInfo_Capability(const SlaveInfo_Capability& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SlaveInfo.Capability)
}

void SlaveInfo_Capability::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveInfo_Capability::~SlaveInfo_Capability() {
  // @@protoc_insertion_point(destructor:mesos.SlaveInfo.Capability)
  SharedDtor();
}

void SlaveInfo_Capability::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SlaveInfo_Capability::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveInfo_Capability::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveInfo_Capability_descriptor_;
}

const SlaveInfo_Capability& SlaveInfo_Capability::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SlaveInfo_Capability* SlaveInfo_Capability::default_instance_ = NULL;

SlaveInfo_Capability* SlaveInfo_Capability::New(::google::protobuf::Arena* arena) const {
  SlaveInfo_Capability* n = new SlaveInfo_Capability;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SlaveInfo_Capability::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.SlaveInfo.Capability)
  type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SlaveInfo_Capability::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SlaveInfo.Capability)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.SlaveInfo.Capability.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::SlaveInfo_Capability_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::SlaveInfo_Capability_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SlaveInfo.Capability)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SlaveInfo.Capability)
  return false;
#undef DO_
}

void SlaveInfo_Capability::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SlaveInfo.Capability)
  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SlaveInfo.Capability)
}

::google::protobuf::uint8* SlaveInfo_Capability::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SlaveInfo.Capability)
  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SlaveInfo.Capability)
  return target;
}

int SlaveInfo_Capability::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.SlaveInfo.Capability)
  int total_size = 0;

  // optional .mesos.SlaveInfo.Capability.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveInfo_Capability::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.SlaveInfo.Capability)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SlaveInfo_Capability* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SlaveInfo_Capability>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.SlaveInfo.Capability)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.SlaveInfo.Capability)
    MergeFrom(*source);
  }
}

void SlaveInfo_Capability::MergeFrom(const SlaveInfo_Capability& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.SlaveInfo.Capability)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SlaveInfo_Capability::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.SlaveInfo.Capability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveInfo_Capability::CopyFrom(const SlaveInfo_Capability& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.SlaveInfo.Capability)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveInfo_Capability::IsInitialized() const {

  return true;
}

void SlaveInfo_Capability::Swap(SlaveInfo_Capability* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SlaveInfo_Capability::InternalSwap(SlaveInfo_Capability* other) {
  std::swap(type_, other->type_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SlaveInfo_Capability::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveInfo_Capability_descriptor_;
  metadata.reflection = SlaveInfo_Capability_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SlaveInfo::kHostnameFieldNumber;
const int SlaveInfo::kPortFieldNumber;
const int SlaveInfo::kResourcesFieldNumber;
const int SlaveInfo::kAttributesFieldNumber;
const int SlaveInfo::kIdFieldNumber;
const int SlaveInfo::kCheckpointFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SlaveInfo::SlaveInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SlaveInfo)
}

void SlaveInfo::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

SlaveInfo::SlaveInfo(const SlaveInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SlaveInfo)
}

void SlaveInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  port_ = 5051;
  id_ = NULL;
  checkpoint_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SlaveInfo::~SlaveInfo() {
  // @@protoc_insertion_point(destructor:mesos.SlaveInfo)
  SharedDtor();
}

void SlaveInfo::SharedDtor() {
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete id_;
  }
}

void SlaveInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SlaveInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SlaveInfo_descriptor_;
}

const SlaveInfo& SlaveInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SlaveInfo* SlaveInfo::default_instance_ = NULL;

SlaveInfo* SlaveInfo::New(::google::protobuf::Arena* arena) const {
  SlaveInfo* n = new SlaveInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SlaveInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.SlaveInfo)
  if (_has_bits_[0 / 32] & 51u) {
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    port_ = 5051;
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::SlaveID::Clear();
    }
    checkpoint_ = false;
  }
  resources_.Clear();
  attributes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SlaveInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SlaveInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string hostname = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.SlaveInfo.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 3;
      case 3: {
        if (tag == 26) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_resources;
        if (input->ExpectTag(42)) goto parse_loop_attributes;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mesos.Attribute attributes = 5;
      case 5: {
        if (tag == 42) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_attributes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_attributes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(50)) goto parse_id;
        break;
      }

      // optional .mesos.SlaveID id = 6;
      case 6: {
        if (tag == 50) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_checkpoint;
        break;
      }

      // optional bool checkpoint = 7 [default = false];
      case 7: {
        if (tag == 56) {
         parse_checkpoint:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &checkpoint_)));
          set_has_checkpoint();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_port;
        break;
      }

      // optional int32 port = 8 [default = 5051];
      case 8: {
        if (tag == 64) {
         parse_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &port_)));
          set_has_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SlaveInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SlaveInfo)
  return false;
#undef DO_
}

void SlaveInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SlaveInfo)
  // required string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.SlaveInfo.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->hostname(), output);
  }

  // repeated .mesos.Resource resources = 3;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->resources(i), output);
  }

  // repeated .mesos.Attribute attributes = 5;
  for (unsigned int i = 0, n = this->attributes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->attributes(i), output);
  }

  // optional .mesos.SlaveID id = 6;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->id_, output);
  }

  // optional bool checkpoint = 7 [default = false];
  if (has_checkpoint()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(7, this->checkpoint(), output);
  }

  // optional int32 port = 8 [default = 5051];
  if (has_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(8, this->port(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SlaveInfo)
}

::google::protobuf::uint8* SlaveInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SlaveInfo)
  // required string hostname = 1;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.SlaveInfo.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->hostname(), target);
  }

  // repeated .mesos.Resource resources = 3;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->resources(i), false, target);
  }

  // repeated .mesos.Attribute attributes = 5;
  for (unsigned int i = 0, n = this->attributes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->attributes(i), false, target);
  }

  // optional .mesos.SlaveID id = 6;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->id_, false, target);
  }

  // optional bool checkpoint = 7 [default = false];
  if (has_checkpoint()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(7, this->checkpoint(), target);
  }

  // optional int32 port = 8 [default = 5051];
  if (has_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(8, this->port(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SlaveInfo)
  return target;
}

int SlaveInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.SlaveInfo)
  int total_size = 0;

  // required string hostname = 1;
  if (has_hostname()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->hostname());
  }
  if (_has_bits_[1 / 32] & 50u) {
    // optional int32 port = 8 [default = 5051];
    if (has_port()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->port());
    }

    // optional .mesos.SlaveID id = 6;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->id_);
    }

    // optional bool checkpoint = 7 [default = false];
    if (has_checkpoint()) {
      total_size += 1 + 1;
    }

  }
  // repeated .mesos.Resource resources = 3;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.Attribute attributes = 5;
  total_size += 1 * this->attributes_size();
  for (int i = 0; i < this->attributes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attributes(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SlaveInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.SlaveInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SlaveInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SlaveInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.SlaveInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.SlaveInfo)
    MergeFrom(*source);
  }
}

void SlaveInfo::MergeFrom(const SlaveInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.SlaveInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  attributes_.MergeFrom(from.attributes_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_port()) {
      set_port(from.port());
    }
    if (from.has_id()) {
      mutable_id()->::mesos::SlaveID::MergeFrom(from.id());
    }
    if (from.has_checkpoint()) {
      set_checkpoint(from.checkpoint());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SlaveInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.SlaveInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SlaveInfo::CopyFrom(const SlaveInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.SlaveInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SlaveInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->attributes())) return false;
  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  return true;
}

void SlaveInfo::Swap(SlaveInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SlaveInfo::InternalSwap(SlaveInfo* other) {
  hostname_.Swap(&other->hostname_);
  std::swap(port_, other->port_);
  resources_.UnsafeArenaSwap(&other->resources_);
  attributes_.UnsafeArenaSwap(&other->attributes_);
  std::swap(id_, other->id_);
  std::swap(checkpoint_, other->checkpoint_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SlaveInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SlaveInfo_descriptor_;
  metadata.reflection = SlaveInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SlaveInfo_Capability

// optional .mesos.SlaveInfo.Capability.Type type = 1;
bool SlaveInfo_Capability::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SlaveInfo_Capability::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void SlaveInfo_Capability::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void SlaveInfo_Capability::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::SlaveInfo_Capability_Type SlaveInfo_Capability::type() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.Capability.type)
  return static_cast< ::mesos::SlaveInfo_Capability_Type >(type_);
}
 void SlaveInfo_Capability::set_type(::mesos::SlaveInfo_Capability_Type value) {
  assert(::mesos::SlaveInfo_Capability_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.Capability.type)
}

// -------------------------------------------------------------------

// SlaveInfo

// required string hostname = 1;
bool SlaveInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SlaveInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
void SlaveInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
void SlaveInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& SlaveInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SlaveInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.hostname)
}
 void SlaveInfo::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.SlaveInfo.hostname)
}
 void SlaveInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.SlaveInfo.hostname)
}
 ::std::string* SlaveInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* SlaveInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.SlaveInfo.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void SlaveInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.hostname)
}

// optional int32 port = 8 [default = 5051];
bool SlaveInfo::has_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SlaveInfo::set_has_port() {
  _has_bits_[0] |= 0x00000002u;
}
void SlaveInfo::clear_has_port() {
  _has_bits_[0] &= ~0x00000002u;
}
void SlaveInfo::clear_port() {
  port_ = 5051;
  clear_has_port();
}
 ::google::protobuf::int32 SlaveInfo::port() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.port)
  return port_;
}
 void SlaveInfo::set_port(::google::protobuf::int32 value) {
  set_has_port();
  port_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.port)
}

// repeated .mesos.Resource resources = 3;
int SlaveInfo::resources_size() const {
  return resources_.size();
}
void SlaveInfo::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& SlaveInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.resources)
  return resources_.Get(index);
}
::mesos::Resource* SlaveInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* SlaveInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.SlaveInfo.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
SlaveInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.SlaveInfo.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
SlaveInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.SlaveInfo.resources)
  return resources_;
}

// repeated .mesos.Attribute attributes = 5;
int SlaveInfo::attributes_size() const {
  return attributes_.size();
}
void SlaveInfo::clear_attributes() {
  attributes_.Clear();
}
const ::mesos::Attribute& SlaveInfo::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.attributes)
  return attributes_.Get(index);
}
::mesos::Attribute* SlaveInfo::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.attributes)
  return attributes_.Mutable(index);
}
::mesos::Attribute* SlaveInfo::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.SlaveInfo.attributes)
  return attributes_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
SlaveInfo::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.SlaveInfo.attributes)
  return &attributes_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
SlaveInfo::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.SlaveInfo.attributes)
  return attributes_;
}

// optional .mesos.SlaveID id = 6;
bool SlaveInfo::has_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void SlaveInfo::set_has_id() {
  _has_bits_[0] |= 0x00000010u;
}
void SlaveInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void SlaveInfo::clear_id() {
  if (id_ != NULL) id_->::mesos::SlaveID::Clear();
  clear_has_id();
}
const ::mesos::SlaveID& SlaveInfo::id() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::mesos::SlaveID* SlaveInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SlaveInfo.id)
  return id_;
}
::mesos::SlaveID* SlaveInfo::release_id() {
  // @@protoc_insertion_point(field_release:mesos.SlaveInfo.id)
  clear_has_id();
  ::mesos::SlaveID* temp = id_;
  id_ = NULL;
  return temp;
}
void SlaveInfo::set_allocated_id(::mesos::SlaveID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SlaveInfo.id)
}

// optional bool checkpoint = 7 [default = false];
bool SlaveInfo::has_checkpoint() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void SlaveInfo::set_has_checkpoint() {
  _has_bits_[0] |= 0x00000020u;
}
void SlaveInfo::clear_has_checkpoint() {
  _has_bits_[0] &= ~0x00000020u;
}
void SlaveInfo::clear_checkpoint() {
  checkpoint_ = false;
  clear_has_checkpoint();
}
 bool SlaveInfo::checkpoint() const {
  // @@protoc_insertion_point(field_get:mesos.SlaveInfo.checkpoint)
  return checkpoint_;
}
 void SlaveInfo::set_checkpoint(bool value) {
  set_has_checkpoint();
  checkpoint_ = value;
  // @@protoc_insertion_point(field_set:mesos.SlaveInfo.checkpoint)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Value_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Type_descriptor_;
}
bool Value_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Value_Type Value::SCALAR;
const Value_Type Value::RANGES;
const Value_Type Value::SET;
const Value_Type Value::TEXT;
const Value_Type Value::Type_MIN;
const Value_Type Value::Type_MAX;
const int Value::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value_Scalar::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value_Scalar::Value_Scalar()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Scalar)
}

void Value_Scalar::InitAsDefaultInstance() {
}

Value_Scalar::Value_Scalar(const Value_Scalar& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Scalar)
}

void Value_Scalar::SharedCtor() {
  _cached_size_ = 0;
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Scalar::~Value_Scalar() {
  // @@protoc_insertion_point(destructor:mesos.Value.Scalar)
  SharedDtor();
}

void Value_Scalar::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Scalar::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Scalar::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Scalar_descriptor_;
}

const Value_Scalar& Value_Scalar::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Scalar* Value_Scalar::default_instance_ = NULL;

Value_Scalar* Value_Scalar::New(::google::protobuf::Arena* arena) const {
  Value_Scalar* n = new Value_Scalar;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value_Scalar::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Value.Scalar)
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Value_Scalar::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Scalar)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double value = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Scalar)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Scalar)
  return false;
#undef DO_
}

void Value_Scalar::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Scalar)
  // required double value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Scalar)
}

::google::protobuf::uint8* Value_Scalar::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Scalar)
  // required double value = 1;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Scalar)
  return target;
}

int Value_Scalar::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Value.Scalar)
  int total_size = 0;

  // required double value = 1;
  if (has_value()) {
    total_size += 1 + 8;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Scalar::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Value.Scalar)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Value_Scalar* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Value_Scalar>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Value.Scalar)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Value.Scalar)
    MergeFrom(*source);
  }
}

void Value_Scalar::MergeFrom(const Value_Scalar& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Value.Scalar)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Value_Scalar::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Value.Scalar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Scalar::CopyFrom(const Value_Scalar& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Value.Scalar)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Scalar::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Value_Scalar::Swap(Value_Scalar* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value_Scalar::InternalSwap(Value_Scalar* other) {
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Value_Scalar::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Scalar_descriptor_;
  metadata.reflection = Value_Scalar_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value_Range::kBeginFieldNumber;
const int Value_Range::kEndFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value_Range::Value_Range()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Range)
}

void Value_Range::InitAsDefaultInstance() {
}

Value_Range::Value_Range(const Value_Range& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Range)
}

void Value_Range::SharedCtor() {
  _cached_size_ = 0;
  begin_ = GOOGLE_ULONGLONG(0);
  end_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Range::~Value_Range() {
  // @@protoc_insertion_point(destructor:mesos.Value.Range)
  SharedDtor();
}

void Value_Range::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Range::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Range::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Range_descriptor_;
}

const Value_Range& Value_Range::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Range* Value_Range::default_instance_ = NULL;

Value_Range* Value_Range::New(::google::protobuf::Arena* arena) const {
  Value_Range* n = new Value_Range;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value_Range::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Value.Range)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Value_Range, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Value_Range*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(begin_, end_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Value_Range::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Range)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 begin = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &begin_)));
          set_has_begin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_end;
        break;
      }

      // required uint64 end = 2;
      case 2: {
        if (tag == 16) {
         parse_end:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &end_)));
          set_has_end();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Range)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Range)
  return false;
#undef DO_
}

void Value_Range::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Range)
  // required uint64 begin = 1;
  if (has_begin()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(1, this->begin(), output);
  }

  // required uint64 end = 2;
  if (has_end()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->end(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Range)
}

::google::protobuf::uint8* Value_Range::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Range)
  // required uint64 begin = 1;
  if (has_begin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(1, this->begin(), target);
  }

  // required uint64 end = 2;
  if (has_end()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->end(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Range)
  return target;
}

int Value_Range::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Value.Range)
  int total_size = 0;

  if (has_begin()) {
    // required uint64 begin = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->begin());
  }

  if (has_end()) {
    // required uint64 end = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->end());
  }

  return total_size;
}
int Value_Range::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Value.Range)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 begin = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->begin());

    // required uint64 end = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt64Size(
        this->end());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Range::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Value.Range)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Value_Range* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Value_Range>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Value.Range)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Value.Range)
    MergeFrom(*source);
  }
}

void Value_Range::MergeFrom(const Value_Range& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Value.Range)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_begin()) {
      set_begin(from.begin());
    }
    if (from.has_end()) {
      set_end(from.end());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Value_Range::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Value.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Range::CopyFrom(const Value_Range& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Value.Range)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Range::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Value_Range::Swap(Value_Range* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value_Range::InternalSwap(Value_Range* other) {
  std::swap(begin_, other->begin_);
  std::swap(end_, other->end_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Value_Range::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Range_descriptor_;
  metadata.reflection = Value_Range_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value_Ranges::kRangeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value_Ranges::Value_Ranges()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Ranges)
}

void Value_Ranges::InitAsDefaultInstance() {
}

Value_Ranges::Value_Ranges(const Value_Ranges& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Ranges)
}

void Value_Ranges::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Ranges::~Value_Ranges() {
  // @@protoc_insertion_point(destructor:mesos.Value.Ranges)
  SharedDtor();
}

void Value_Ranges::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Ranges::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Ranges::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Ranges_descriptor_;
}

const Value_Ranges& Value_Ranges::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Ranges* Value_Ranges::default_instance_ = NULL;

Value_Ranges* Value_Ranges::New(::google::protobuf::Arena* arena) const {
  Value_Ranges* n = new Value_Ranges;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value_Ranges::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Value.Ranges)
  range_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Value_Ranges::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Ranges)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Value.Range range = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_range:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_range()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_range;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Ranges)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Ranges)
  return false;
#undef DO_
}

void Value_Ranges::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Ranges)
  // repeated .mesos.Value.Range range = 1;
  for (unsigned int i = 0, n = this->range_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->range(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Ranges)
}

::google::protobuf::uint8* Value_Ranges::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Ranges)
  // repeated .mesos.Value.Range range = 1;
  for (unsigned int i = 0, n = this->range_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->range(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Ranges)
  return target;
}

int Value_Ranges::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Value.Ranges)
  int total_size = 0;

  // repeated .mesos.Value.Range range = 1;
  total_size += 1 * this->range_size();
  for (int i = 0; i < this->range_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->range(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Ranges::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Value.Ranges)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Value_Ranges* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Value_Ranges>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Value.Ranges)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Value.Ranges)
    MergeFrom(*source);
  }
}

void Value_Ranges::MergeFrom(const Value_Ranges& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Value.Ranges)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  range_.MergeFrom(from.range_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Value_Ranges::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Value.Ranges)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Ranges::CopyFrom(const Value_Ranges& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Value.Ranges)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Ranges::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->range())) return false;
  return true;
}

void Value_Ranges::Swap(Value_Ranges* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value_Ranges::InternalSwap(Value_Ranges* other) {
  range_.UnsafeArenaSwap(&other->range_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Value_Ranges::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Ranges_descriptor_;
  metadata.reflection = Value_Ranges_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value_Set::kItemFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value_Set::Value_Set()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Set)
}

void Value_Set::InitAsDefaultInstance() {
}

Value_Set::Value_Set(const Value_Set& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Set)
}

void Value_Set::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Set::~Value_Set() {
  // @@protoc_insertion_point(destructor:mesos.Value.Set)
  SharedDtor();
}

void Value_Set::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Value_Set::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Set::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Set_descriptor_;
}

const Value_Set& Value_Set::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Set* Value_Set::default_instance_ = NULL;

Value_Set* Value_Set::New(::google::protobuf::Arena* arena) const {
  Value_Set* n = new Value_Set;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value_Set::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Value.Set)
  item_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Value_Set::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Set)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string item = 1;
      case 1: {
        if (tag == 10) {
         parse_item:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_item()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->item(this->item_size() - 1).data(),
            this->item(this->item_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Value.Set.item");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_item;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Set)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Set)
  return false;
#undef DO_
}

void Value_Set::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Set)
  // repeated string item = 1;
  for (int i = 0; i < this->item_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->item(i).data(), this->item(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Value.Set.item");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->item(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Set)
}

::google::protobuf::uint8* Value_Set::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Set)
  // repeated string item = 1;
  for (int i = 0; i < this->item_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->item(i).data(), this->item(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Value.Set.item");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->item(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Set)
  return target;
}

int Value_Set::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Value.Set)
  int total_size = 0;

  // repeated string item = 1;
  total_size += 1 * this->item_size();
  for (int i = 0; i < this->item_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->item(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Set::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Value.Set)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Value_Set* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Value_Set>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Value.Set)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Value.Set)
    MergeFrom(*source);
  }
}

void Value_Set::MergeFrom(const Value_Set& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Value.Set)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  item_.MergeFrom(from.item_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Value_Set::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Value.Set)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Set::CopyFrom(const Value_Set& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Value.Set)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Set::IsInitialized() const {

  return true;
}

void Value_Set::Swap(Value_Set* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value_Set::InternalSwap(Value_Set* other) {
  item_.UnsafeArenaSwap(&other->item_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Value_Set::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Set_descriptor_;
  metadata.reflection = Value_Set_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value_Text::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value_Text::Value_Text()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value.Text)
}

void Value_Text::InitAsDefaultInstance() {
}

Value_Text::Value_Text(const Value_Text& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value.Text)
}

void Value_Text::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value_Text::~Value_Text() {
  // @@protoc_insertion_point(destructor:mesos.Value.Text)
  SharedDtor();
}

void Value_Text::SharedDtor() {
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Value_Text::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value_Text::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_Text_descriptor_;
}

const Value_Text& Value_Text::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value_Text* Value_Text::default_instance_ = NULL;

Value_Text* Value_Text::New(::google::protobuf::Arena* arena) const {
  Value_Text* n = new Value_Text;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value_Text::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Value.Text)
  if (has_value()) {
    value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Value_Text::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value.Text)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string value = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Value.Text.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value.Text)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value.Text)
  return false;
#undef DO_
}

void Value_Text::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value.Text)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Value.Text.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value.Text)
}

::google::protobuf::uint8* Value_Text::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value.Text)
  // required string value = 1;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Value.Text.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value.Text)
  return target;
}

int Value_Text::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Value.Text)
  int total_size = 0;

  // required string value = 1;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value_Text::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Value.Text)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Value_Text* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Value_Text>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Value.Text)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Value.Text)
    MergeFrom(*source);
  }
}

void Value_Text::MergeFrom(const Value_Text& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Value.Text)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Value_Text::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Value.Text)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value_Text::CopyFrom(const Value_Text& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Value.Text)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value_Text::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Value_Text::Swap(Value_Text* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value_Text::InternalSwap(Value_Text* other) {
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Value_Text::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_Text_descriptor_;
  metadata.reflection = Value_Text_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Value::kTypeFieldNumber;
const int Value::kScalarFieldNumber;
const int Value::kRangesFieldNumber;
const int Value::kSetFieldNumber;
const int Value::kTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Value::Value()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Value)
}

void Value::InitAsDefaultInstance() {
  scalar_ = const_cast< ::mesos::Value_Scalar*>(&::mesos::Value_Scalar::default_instance());
  ranges_ = const_cast< ::mesos::Value_Ranges*>(&::mesos::Value_Ranges::default_instance());
  set_ = const_cast< ::mesos::Value_Set*>(&::mesos::Value_Set::default_instance());
  text_ = const_cast< ::mesos::Value_Text*>(&::mesos::Value_Text::default_instance());
}

Value::Value(const Value& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Value)
}

void Value::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  scalar_ = NULL;
  ranges_ = NULL;
  set_ = NULL;
  text_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Value::~Value() {
  // @@protoc_insertion_point(destructor:mesos.Value)
  SharedDtor();
}

void Value::SharedDtor() {
  if (this != default_instance_) {
    delete scalar_;
    delete ranges_;
    delete set_;
    delete text_;
  }
}

void Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Value::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Value_descriptor_;
}

const Value& Value::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Value* Value::default_instance_ = NULL;

Value* Value::New(::google::protobuf::Arena* arena) const {
  Value* n = new Value;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Value::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Value)
  if (_has_bits_[0 / 32] & 31u) {
    type_ = 0;
    if (has_scalar()) {
      if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
    }
    if (has_ranges()) {
      if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
    }
    if (has_set()) {
      if (set_ != NULL) set_->::mesos::Value_Set::Clear();
    }
    if (has_text()) {
      if (text_ != NULL) text_->::mesos::Value_Text::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Value)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Value.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Value_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Value_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_scalar;
        break;
      }

      // optional .mesos.Value.Scalar scalar = 2;
      case 2: {
        if (tag == 18) {
         parse_scalar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ranges;
        break;
      }

      // optional .mesos.Value.Ranges ranges = 3;
      case 3: {
        if (tag == 26) {
         parse_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_set;
        break;
      }

      // optional .mesos.Value.Set set = 4;
      case 4: {
        if (tag == 34) {
         parse_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_text;
        break;
      }

      // optional .mesos.Value.Text text = 5;
      case 5: {
        if (tag == 42) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_text()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Value)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Value)
  return false;
#undef DO_
}

void Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Value)
  // required .mesos.Value.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Value.Scalar scalar = 2;
  if (has_scalar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->scalar_, output);
  }

  // optional .mesos.Value.Ranges ranges = 3;
  if (has_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->ranges_, output);
  }

  // optional .mesos.Value.Set set = 4;
  if (has_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->set_, output);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->text_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Value)
}

::google::protobuf::uint8* Value::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Value)
  // required .mesos.Value.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Value.Scalar scalar = 2;
  if (has_scalar()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->scalar_, false, target);
  }

  // optional .mesos.Value.Ranges ranges = 3;
  if (has_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->ranges_, false, target);
  }

  // optional .mesos.Value.Set set = 4;
  if (has_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->set_, false, target);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->text_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Value)
  return target;
}

int Value::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Value)
  int total_size = 0;

  // required .mesos.Value.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  if (_has_bits_[1 / 32] & 30u) {
    // optional .mesos.Value.Scalar scalar = 2;
    if (has_scalar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scalar_);
    }

    // optional .mesos.Value.Ranges ranges = 3;
    if (has_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ranges_);
    }

    // optional .mesos.Value.Set set = 4;
    if (has_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->set_);
    }

    // optional .mesos.Value.Text text = 5;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->text_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Value::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Value)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Value* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Value>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Value)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Value)
    MergeFrom(*source);
  }
}

void Value::MergeFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Value)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_scalar()) {
      mutable_scalar()->::mesos::Value_Scalar::MergeFrom(from.scalar());
    }
    if (from.has_ranges()) {
      mutable_ranges()->::mesos::Value_Ranges::MergeFrom(from.ranges());
    }
    if (from.has_set()) {
      mutable_set()->::mesos::Value_Set::MergeFrom(from.set());
    }
    if (from.has_text()) {
      mutable_text()->::mesos::Value_Text::MergeFrom(from.text());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Value::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Value::CopyFrom(const Value& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Value::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_scalar()) {
    if (!this->scalar_->IsInitialized()) return false;
  }
  if (has_ranges()) {
    if (!this->ranges_->IsInitialized()) return false;
  }
  if (has_text()) {
    if (!this->text_->IsInitialized()) return false;
  }
  return true;
}

void Value::Swap(Value* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Value::InternalSwap(Value* other) {
  std::swap(type_, other->type_);
  std::swap(scalar_, other->scalar_);
  std::swap(ranges_, other->ranges_);
  std::swap(set_, other->set_);
  std::swap(text_, other->text_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Value::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Value_descriptor_;
  metadata.reflection = Value_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Value_Scalar

// required double value = 1;
bool Value_Scalar::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Value_Scalar::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void Value_Scalar::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void Value_Scalar::clear_value() {
  value_ = 0;
  clear_has_value();
}
 double Value_Scalar::value() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Scalar.value)
  return value_;
}
 void Value_Scalar::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Scalar.value)
}

// -------------------------------------------------------------------

// Value_Range

// required uint64 begin = 1;
bool Value_Range::has_begin() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Value_Range::set_has_begin() {
  _has_bits_[0] |= 0x00000001u;
}
void Value_Range::clear_has_begin() {
  _has_bits_[0] &= ~0x00000001u;
}
void Value_Range::clear_begin() {
  begin_ = GOOGLE_ULONGLONG(0);
  clear_has_begin();
}
 ::google::protobuf::uint64 Value_Range::begin() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Range.begin)
  return begin_;
}
 void Value_Range::set_begin(::google::protobuf::uint64 value) {
  set_has_begin();
  begin_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Range.begin)
}

// required uint64 end = 2;
bool Value_Range::has_end() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Value_Range::set_has_end() {
  _has_bits_[0] |= 0x00000002u;
}
void Value_Range::clear_has_end() {
  _has_bits_[0] &= ~0x00000002u;
}
void Value_Range::clear_end() {
  end_ = GOOGLE_ULONGLONG(0);
  clear_has_end();
}
 ::google::protobuf::uint64 Value_Range::end() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Range.end)
  return end_;
}
 void Value_Range::set_end(::google::protobuf::uint64 value) {
  set_has_end();
  end_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.Range.end)
}

// -------------------------------------------------------------------

// Value_Ranges

// repeated .mesos.Value.Range range = 1;
int Value_Ranges::range_size() const {
  return range_.size();
}
void Value_Ranges::clear_range() {
  range_.Clear();
}
const ::mesos::Value_Range& Value_Ranges::range(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Value.Ranges.range)
  return range_.Get(index);
}
::mesos::Value_Range* Value_Ranges::mutable_range(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Value.Ranges.range)
  return range_.Mutable(index);
}
::mesos::Value_Range* Value_Ranges::add_range() {
  // @@protoc_insertion_point(field_add:mesos.Value.Ranges.range)
  return range_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >*
Value_Ranges::mutable_range() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Value.Ranges.range)
  return &range_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Value_Range >&
Value_Ranges::range() const {
  // @@protoc_insertion_point(field_list:mesos.Value.Ranges.range)
  return range_;
}

// -------------------------------------------------------------------

// Value_Set

// repeated string item = 1;
int Value_Set::item_size() const {
  return item_.size();
}
void Value_Set::clear_item() {
  item_.Clear();
}
 const ::std::string& Value_Set::item(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Value.Set.item)
  return item_.Get(index);
}
 ::std::string* Value_Set::mutable_item(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Value.Set.item)
  return item_.Mutable(index);
}
 void Value_Set::set_item(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.Value.Set.item)
  item_.Mutable(index)->assign(value);
}
 void Value_Set::set_item(int index, const char* value) {
  item_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.Value.Set.item)
}
 void Value_Set::set_item(int index, const char* value, size_t size) {
  item_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.Value.Set.item)
}
 ::std::string* Value_Set::add_item() {
  // @@protoc_insertion_point(field_add_mutable:mesos.Value.Set.item)
  return item_.Add();
}
 void Value_Set::add_item(const ::std::string& value) {
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.Value.Set.item)
}
 void Value_Set::add_item(const char* value) {
  item_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.Value.Set.item)
}
 void Value_Set::add_item(const char* value, size_t size) {
  item_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.Value.Set.item)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
Value_Set::item() const {
  // @@protoc_insertion_point(field_list:mesos.Value.Set.item)
  return item_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
Value_Set::mutable_item() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Value.Set.item)
  return &item_;
}

// -------------------------------------------------------------------

// Value_Text

// required string value = 1;
bool Value_Text::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Value_Text::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
void Value_Text::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
void Value_Text::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Value_Text::value() const {
  // @@protoc_insertion_point(field_get:mesos.Value.Text.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Value_Text::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Value.Text.value)
}
 void Value_Text::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Value.Text.value)
}
 void Value_Text::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Value.Text.value)
}
 ::std::string* Value_Text::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Value.Text.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Value_Text::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Value.Text.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Value_Text::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.Text.value)
}

// -------------------------------------------------------------------

// Value

// required .mesos.Value.Type type = 1;
bool Value::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Value::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Value::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Value::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Value_Type Value::type() const {
  // @@protoc_insertion_point(field_get:mesos.Value.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
 void Value::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Value.type)
}

// optional .mesos.Value.Scalar scalar = 2;
bool Value::has_scalar() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Value::set_has_scalar() {
  _has_bits_[0] |= 0x00000002u;
}
void Value::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000002u;
}
void Value::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
const ::mesos::Value_Scalar& Value::scalar() const {
  // @@protoc_insertion_point(field_get:mesos.Value.scalar)
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
::mesos::Value_Scalar* Value::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) {
    scalar_ = new ::mesos::Value_Scalar;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.scalar)
  return scalar_;
}
::mesos::Value_Scalar* Value::release_scalar() {
  // @@protoc_insertion_point(field_release:mesos.Value.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
void Value::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.scalar)
}

// optional .mesos.Value.Ranges ranges = 3;
bool Value::has_ranges() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Value::set_has_ranges() {
  _has_bits_[0] |= 0x00000004u;
}
void Value::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000004u;
}
void Value::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
const ::mesos::Value_Ranges& Value::ranges() const {
  // @@protoc_insertion_point(field_get:mesos.Value.ranges)
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
::mesos::Value_Ranges* Value::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) {
    ranges_ = new ::mesos::Value_Ranges;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.ranges)
  return ranges_;
}
::mesos::Value_Ranges* Value::release_ranges() {
  // @@protoc_insertion_point(field_release:mesos.Value.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
void Value::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.ranges)
}

// optional .mesos.Value.Set set = 4;
bool Value::has_set() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Value::set_has_set() {
  _has_bits_[0] |= 0x00000008u;
}
void Value::clear_has_set() {
  _has_bits_[0] &= ~0x00000008u;
}
void Value::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
const ::mesos::Value_Set& Value::set() const {
  // @@protoc_insertion_point(field_get:mesos.Value.set)
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
::mesos::Value_Set* Value::mutable_set() {
  set_has_set();
  if (set_ == NULL) {
    set_ = new ::mesos::Value_Set;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.set)
  return set_;
}
::mesos::Value_Set* Value::release_set() {
  // @@protoc_insertion_point(field_release:mesos.Value.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
void Value::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.set)
}

// optional .mesos.Value.Text text = 5;
bool Value::has_text() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Value::set_has_text() {
  _has_bits_[0] |= 0x00000010u;
}
void Value::clear_has_text() {
  _has_bits_[0] &= ~0x00000010u;
}
void Value::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
const ::mesos::Value_Text& Value::text() const {
  // @@protoc_insertion_point(field_get:mesos.Value.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
::mesos::Value_Text* Value::mutable_text() {
  set_has_text();
  if (text_ == NULL) {
    text_ = new ::mesos::Value_Text;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Value.text)
  return text_;
}
::mesos::Value_Text* Value::release_text() {
  // @@protoc_insertion_point(field_release:mesos.Value.text)
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
void Value::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Value.text)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Attribute::kNameFieldNumber;
const int Attribute::kTypeFieldNumber;
const int Attribute::kScalarFieldNumber;
const int Attribute::kRangesFieldNumber;
const int Attribute::kSetFieldNumber;
const int Attribute::kTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Attribute::Attribute()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Attribute)
}

void Attribute::InitAsDefaultInstance() {
  scalar_ = const_cast< ::mesos::Value_Scalar*>(&::mesos::Value_Scalar::default_instance());
  ranges_ = const_cast< ::mesos::Value_Ranges*>(&::mesos::Value_Ranges::default_instance());
  set_ = const_cast< ::mesos::Value_Set*>(&::mesos::Value_Set::default_instance());
  text_ = const_cast< ::mesos::Value_Text*>(&::mesos::Value_Text::default_instance());
}

Attribute::Attribute(const Attribute& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Attribute)
}

void Attribute::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  scalar_ = NULL;
  ranges_ = NULL;
  set_ = NULL;
  text_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Attribute::~Attribute() {
  // @@protoc_insertion_point(destructor:mesos.Attribute)
  SharedDtor();
}

void Attribute::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete scalar_;
    delete ranges_;
    delete set_;
    delete text_;
  }
}

void Attribute::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Attribute::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Attribute_descriptor_;
}

const Attribute& Attribute::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Attribute* Attribute::default_instance_ = NULL;

Attribute* Attribute::New(::google::protobuf::Arena* arena) const {
  Attribute* n = new Attribute;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Attribute::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Attribute)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    type_ = 0;
    if (has_scalar()) {
      if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
    }
    if (has_ranges()) {
      if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
    }
    if (has_set()) {
      if (set_ != NULL) set_->::mesos::Value_Set::Clear();
    }
    if (has_text()) {
      if (text_ != NULL) text_->::mesos::Value_Text::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Attribute::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Attribute)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Attribute.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .mesos.Value.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Value_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Value_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scalar;
        break;
      }

      // optional .mesos.Value.Scalar scalar = 3;
      case 3: {
        if (tag == 26) {
         parse_scalar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ranges;
        break;
      }

      // optional .mesos.Value.Ranges ranges = 4;
      case 4: {
        if (tag == 34) {
         parse_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_text;
        break;
      }

      // optional .mesos.Value.Text text = 5;
      case 5: {
        if (tag == 42) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_text()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_set;
        break;
      }

      // optional .mesos.Value.Set set = 6;
      case 6: {
        if (tag == 50) {
         parse_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Attribute)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Attribute)
  return false;
#undef DO_
}

void Attribute::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Attribute)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Attribute.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->scalar_, output);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->ranges_, output);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->text_, output);
  }

  // optional .mesos.Value.Set set = 6;
  if (has_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->set_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Attribute)
}

::google::protobuf::uint8* Attribute::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Attribute)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Attribute.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->scalar_, false, target);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->ranges_, false, target);
  }

  // optional .mesos.Value.Text text = 5;
  if (has_text()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->text_, false, target);
  }

  // optional .mesos.Value.Set set = 6;
  if (has_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->set_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Attribute)
  return target;
}

int Attribute::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Attribute)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_type()) {
    // required .mesos.Value.Type type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
int Attribute::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Attribute)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required .mesos.Value.Type type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 60u) {
    // optional .mesos.Value.Scalar scalar = 3;
    if (has_scalar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scalar_);
    }

    // optional .mesos.Value.Ranges ranges = 4;
    if (has_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ranges_);
    }

    // optional .mesos.Value.Set set = 6;
    if (has_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->set_);
    }

    // optional .mesos.Value.Text text = 5;
    if (has_text()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->text_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Attribute::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Attribute)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Attribute* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Attribute>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Attribute)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Attribute)
    MergeFrom(*source);
  }
}

void Attribute::MergeFrom(const Attribute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Attribute)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_scalar()) {
      mutable_scalar()->::mesos::Value_Scalar::MergeFrom(from.scalar());
    }
    if (from.has_ranges()) {
      mutable_ranges()->::mesos::Value_Ranges::MergeFrom(from.ranges());
    }
    if (from.has_set()) {
      mutable_set()->::mesos::Value_Set::MergeFrom(from.set());
    }
    if (from.has_text()) {
      mutable_text()->::mesos::Value_Text::MergeFrom(from.text());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Attribute::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Attribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Attribute::CopyFrom(const Attribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Attribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Attribute::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_scalar()) {
    if (!this->scalar_->IsInitialized()) return false;
  }
  if (has_ranges()) {
    if (!this->ranges_->IsInitialized()) return false;
  }
  if (has_text()) {
    if (!this->text_->IsInitialized()) return false;
  }
  return true;
}

void Attribute::Swap(Attribute* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Attribute::InternalSwap(Attribute* other) {
  name_.Swap(&other->name_);
  std::swap(type_, other->type_);
  std::swap(scalar_, other->scalar_);
  std::swap(ranges_, other->ranges_);
  std::swap(set_, other->set_);
  std::swap(text_, other->text_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Attribute::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Attribute_descriptor_;
  metadata.reflection = Attribute_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Attribute

// required string name = 1;
bool Attribute::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Attribute::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Attribute::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Attribute::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Attribute::name() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Attribute::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Attribute.name)
}
 void Attribute::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Attribute.name)
}
 void Attribute::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Attribute.name)
}
 ::std::string* Attribute::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Attribute::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Attribute::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.name)
}

// required .mesos.Value.Type type = 2;
bool Attribute::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Attribute::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void Attribute::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void Attribute::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Value_Type Attribute::type() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
 void Attribute::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Attribute.type)
}

// optional .mesos.Value.Scalar scalar = 3;
bool Attribute::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Attribute::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
void Attribute::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
void Attribute::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
const ::mesos::Value_Scalar& Attribute::scalar() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.scalar)
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
::mesos::Value_Scalar* Attribute::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) {
    scalar_ = new ::mesos::Value_Scalar;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.scalar)
  return scalar_;
}
::mesos::Value_Scalar* Attribute::release_scalar() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
void Attribute::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.scalar)
}

// optional .mesos.Value.Ranges ranges = 4;
bool Attribute::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Attribute::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
void Attribute::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
void Attribute::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
const ::mesos::Value_Ranges& Attribute::ranges() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.ranges)
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
::mesos::Value_Ranges* Attribute::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) {
    ranges_ = new ::mesos::Value_Ranges;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.ranges)
  return ranges_;
}
::mesos::Value_Ranges* Attribute::release_ranges() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
void Attribute::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.ranges)
}

// optional .mesos.Value.Set set = 6;
bool Attribute::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Attribute::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
void Attribute::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
void Attribute::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
const ::mesos::Value_Set& Attribute::set() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.set)
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
::mesos::Value_Set* Attribute::mutable_set() {
  set_has_set();
  if (set_ == NULL) {
    set_ = new ::mesos::Value_Set;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.set)
  return set_;
}
::mesos::Value_Set* Attribute::release_set() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
void Attribute::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.set)
}

// optional .mesos.Value.Text text = 5;
bool Attribute::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Attribute::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
void Attribute::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
void Attribute::clear_text() {
  if (text_ != NULL) text_->::mesos::Value_Text::Clear();
  clear_has_text();
}
const ::mesos::Value_Text& Attribute::text() const {
  // @@protoc_insertion_point(field_get:mesos.Attribute.text)
  return text_ != NULL ? *text_ : *default_instance_->text_;
}
::mesos::Value_Text* Attribute::mutable_text() {
  set_has_text();
  if (text_ == NULL) {
    text_ = new ::mesos::Value_Text;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Attribute.text)
  return text_;
}
::mesos::Value_Text* Attribute::release_text() {
  // @@protoc_insertion_point(field_release:mesos.Attribute.text)
  clear_has_text();
  ::mesos::Value_Text* temp = text_;
  text_ = NULL;
  return temp;
}
void Attribute::set_allocated_text(::mesos::Value_Text* text) {
  delete text_;
  text_ = text;
  if (text) {
    set_has_text();
  } else {
    clear_has_text();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Attribute.text)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_AllocationInfo::kRoleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_AllocationInfo::Resource_AllocationInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.AllocationInfo)
}

void Resource_AllocationInfo::InitAsDefaultInstance() {
}

Resource_AllocationInfo::Resource_AllocationInfo(const Resource_AllocationInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.AllocationInfo)
}

void Resource_AllocationInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  role_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_AllocationInfo::~Resource_AllocationInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.AllocationInfo)
  SharedDtor();
}

void Resource_AllocationInfo::SharedDtor() {
  role_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Resource_AllocationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_AllocationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_AllocationInfo_descriptor_;
}

const Resource_AllocationInfo& Resource_AllocationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_AllocationInfo* Resource_AllocationInfo::default_instance_ = NULL;

Resource_AllocationInfo* Resource_AllocationInfo::New(::google::protobuf::Arena* arena) const {
  Resource_AllocationInfo* n = new Resource_AllocationInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_AllocationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.AllocationInfo)
  if (has_role()) {
    role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_AllocationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.AllocationInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string role = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.AllocationInfo.role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.AllocationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.AllocationInfo)
  return false;
#undef DO_
}

void Resource_AllocationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.AllocationInfo)
  // optional string role = 1;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.AllocationInfo.role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->role(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.AllocationInfo)
}

::google::protobuf::uint8* Resource_AllocationInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.AllocationInfo)
  // optional string role = 1;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.AllocationInfo.role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->role(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.AllocationInfo)
  return target;
}

int Resource_AllocationInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.AllocationInfo)
  int total_size = 0;

  // optional string role = 1;
  if (has_role()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->role());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_AllocationInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.AllocationInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_AllocationInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_AllocationInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.AllocationInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.AllocationInfo)
    MergeFrom(*source);
  }
}

void Resource_AllocationInfo::MergeFrom(const Resource_AllocationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.AllocationInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_role()) {
      set_has_role();
      role_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.role_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_AllocationInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.AllocationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_AllocationInfo::CopyFrom(const Resource_AllocationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.AllocationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_AllocationInfo::IsInitialized() const {

  return true;
}

void Resource_AllocationInfo::Swap(Resource_AllocationInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_AllocationInfo::InternalSwap(Resource_AllocationInfo* other) {
  role_.Swap(&other->role_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_AllocationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_AllocationInfo_descriptor_;
  metadata.reflection = Resource_AllocationInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_ReservationInfo::kPrincipalFieldNumber;
const int Resource_ReservationInfo::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_ReservationInfo::Resource_ReservationInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.ReservationInfo)
}

void Resource_ReservationInfo::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

Resource_ReservationInfo::Resource_ReservationInfo(const Resource_ReservationInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.ReservationInfo)
}

void Resource_ReservationInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_ReservationInfo::~Resource_ReservationInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.ReservationInfo)
  SharedDtor();
}

void Resource_ReservationInfo::SharedDtor() {
  principal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete labels_;
  }
}

void Resource_ReservationInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_ReservationInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_ReservationInfo_descriptor_;
}

const Resource_ReservationInfo& Resource_ReservationInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_ReservationInfo* Resource_ReservationInfo::default_instance_ = NULL;

Resource_ReservationInfo* Resource_ReservationInfo::New(::google::protobuf::Arena* arena) const {
  Resource_ReservationInfo* n = new Resource_ReservationInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_ReservationInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.ReservationInfo)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_principal()) {
      principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_ReservationInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.ReservationInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string principal = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.ReservationInfo.principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 2;
      case 2: {
        if (tag == 18) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.ReservationInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.ReservationInfo)
  return false;
#undef DO_
}

void Resource_ReservationInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.ReservationInfo)
  // optional string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.ReservationInfo.principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->principal(), output);
  }

  // optional .mesos.Labels labels = 2;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->labels_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.ReservationInfo)
}

::google::protobuf::uint8* Resource_ReservationInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.ReservationInfo)
  // optional string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.ReservationInfo.principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->principal(), target);
  }

  // optional .mesos.Labels labels = 2;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->labels_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.ReservationInfo)
  return target;
}

int Resource_ReservationInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.ReservationInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional string principal = 1;
    if (has_principal()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->principal());
    }

    // optional .mesos.Labels labels = 2;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_ReservationInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.ReservationInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_ReservationInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_ReservationInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.ReservationInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.ReservationInfo)
    MergeFrom(*source);
  }
}

void Resource_ReservationInfo::MergeFrom(const Resource_ReservationInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.ReservationInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_principal()) {
      set_has_principal();
      principal_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.principal_);
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_ReservationInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.ReservationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_ReservationInfo::CopyFrom(const Resource_ReservationInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.ReservationInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_ReservationInfo::IsInitialized() const {

  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void Resource_ReservationInfo::Swap(Resource_ReservationInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_ReservationInfo::InternalSwap(Resource_ReservationInfo* other) {
  principal_.Swap(&other->principal_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_ReservationInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_ReservationInfo_descriptor_;
  metadata.reflection = Resource_ReservationInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_DiskInfo_Persistence::kIdFieldNumber;
const int Resource_DiskInfo_Persistence::kPrincipalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_DiskInfo_Persistence::Resource_DiskInfo_Persistence()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Persistence)
}

void Resource_DiskInfo_Persistence::InitAsDefaultInstance() {
}

Resource_DiskInfo_Persistence::Resource_DiskInfo_Persistence(const Resource_DiskInfo_Persistence& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Persistence)
}

void Resource_DiskInfo_Persistence::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Persistence::~Resource_DiskInfo_Persistence() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Persistence)
  SharedDtor();
}

void Resource_DiskInfo_Persistence::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  principal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Resource_DiskInfo_Persistence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Persistence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Persistence_descriptor_;
}

const Resource_DiskInfo_Persistence& Resource_DiskInfo_Persistence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Persistence* Resource_DiskInfo_Persistence::default_instance_ = NULL;

Resource_DiskInfo_Persistence* Resource_DiskInfo_Persistence::New(::google::protobuf::Arena* arena) const {
  Resource_DiskInfo_Persistence* n = new Resource_DiskInfo_Persistence;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_DiskInfo_Persistence::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.DiskInfo.Persistence)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_principal()) {
      principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_DiskInfo_Persistence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Persistence)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.DiskInfo.Persistence.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_principal;
        break;
      }

      // optional string principal = 2;
      case 2: {
        if (tag == 18) {
         parse_principal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.DiskInfo.Persistence.principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Persistence)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Persistence)
  return false;
#undef DO_
}

void Resource_DiskInfo_Persistence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Persistence)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Persistence.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // optional string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Persistence.principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->principal(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Persistence)
}

::google::protobuf::uint8* Resource_DiskInfo_Persistence::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Persistence)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Persistence.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // optional string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Persistence.principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->principal(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Persistence)
  return target;
}

int Resource_DiskInfo_Persistence::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.DiskInfo.Persistence)
  int total_size = 0;

  // required string id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }
  // optional string principal = 2;
  if (has_principal()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->principal());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Persistence::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.DiskInfo.Persistence)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_DiskInfo_Persistence* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_DiskInfo_Persistence>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.DiskInfo.Persistence)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.DiskInfo.Persistence)
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Persistence::MergeFrom(const Resource_DiskInfo_Persistence& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.DiskInfo.Persistence)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_principal()) {
      set_has_principal();
      principal_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.principal_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_DiskInfo_Persistence::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.DiskInfo.Persistence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Persistence::CopyFrom(const Resource_DiskInfo_Persistence& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.DiskInfo.Persistence)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Persistence::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Resource_DiskInfo_Persistence::Swap(Resource_DiskInfo_Persistence* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_DiskInfo_Persistence::InternalSwap(Resource_DiskInfo_Persistence* other) {
  id_.Swap(&other->id_);
  principal_.Swap(&other->principal_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_DiskInfo_Persistence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Persistence_descriptor_;
  metadata.reflection = Resource_DiskInfo_Persistence_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* Resource_DiskInfo_Source_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_Type_descriptor_;
}
bool Resource_DiskInfo_Source_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::PATH;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::MOUNT;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::Type_MIN;
const Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::Type_MAX;
const int Resource_DiskInfo_Source::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_DiskInfo_Source_Path::kRootFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_DiskInfo_Source_Path::Resource_DiskInfo_Source_Path()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Source.Path)
}

void Resource_DiskInfo_Source_Path::InitAsDefaultInstance() {
}

Resource_DiskInfo_Source_Path::Resource_DiskInfo_Source_Path(const Resource_DiskInfo_Source_Path& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Source.Path)
}

void Resource_DiskInfo_Source_Path::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  root_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Source_Path::~Resource_DiskInfo_Source_Path() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Source.Path)
  SharedDtor();
}

void Resource_DiskInfo_Source_Path::SharedDtor() {
  root_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Resource_DiskInfo_Source_Path::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Path::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_Path_descriptor_;
}

const Resource_DiskInfo_Source_Path& Resource_DiskInfo_Source_Path::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source_Path::default_instance_ = NULL;

Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source_Path::New(::google::protobuf::Arena* arena) const {
  Resource_DiskInfo_Source_Path* n = new Resource_DiskInfo_Source_Path;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_DiskInfo_Source_Path::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.DiskInfo.Source.Path)
  if (has_root()) {
    root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_DiskInfo_Source_Path::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Source.Path)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string root = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_root()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->root().data(), this->root().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.DiskInfo.Source.Path.root");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Source.Path)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Source.Path)
  return false;
#undef DO_
}

void Resource_DiskInfo_Source_Path::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Source.Path)
  // required string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Source.Path.root");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->root(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Source.Path)
}

::google::protobuf::uint8* Resource_DiskInfo_Source_Path::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Source.Path)
  // required string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Source.Path.root");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->root(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Source.Path)
  return target;
}

int Resource_DiskInfo_Source_Path::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.DiskInfo.Source.Path)
  int total_size = 0;

  // required string root = 1;
  if (has_root()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->root());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Source_Path::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.DiskInfo.Source.Path)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_DiskInfo_Source_Path* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_DiskInfo_Source_Path>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.DiskInfo.Source.Path)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.DiskInfo.Source.Path)
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Source_Path::MergeFrom(const Resource_DiskInfo_Source_Path& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.DiskInfo.Source.Path)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_root()) {
      set_has_root();
      root_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.root_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_DiskInfo_Source_Path::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.DiskInfo.Source.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Source_Path::CopyFrom(const Resource_DiskInfo_Source_Path& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.DiskInfo.Source.Path)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Source_Path::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Resource_DiskInfo_Source_Path::Swap(Resource_DiskInfo_Source_Path* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_DiskInfo_Source_Path::InternalSwap(Resource_DiskInfo_Source_Path* other) {
  root_.Swap(&other->root_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_DiskInfo_Source_Path::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Source_Path_descriptor_;
  metadata.reflection = Resource_DiskInfo_Source_Path_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_DiskInfo_Source_Mount::kRootFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_DiskInfo_Source_Mount::Resource_DiskInfo_Source_Mount()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Source.Mount)
}

void Resource_DiskInfo_Source_Mount::InitAsDefaultInstance() {
}

Resource_DiskInfo_Source_Mount::Resource_DiskInfo_Source_Mount(const Resource_DiskInfo_Source_Mount& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Source.Mount)
}

void Resource_DiskInfo_Source_Mount::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  root_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Source_Mount::~Resource_DiskInfo_Source_Mount() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Source.Mount)
  SharedDtor();
}

void Resource_DiskInfo_Source_Mount::SharedDtor() {
  root_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Resource_DiskInfo_Source_Mount::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source_Mount::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_Mount_descriptor_;
}

const Resource_DiskInfo_Source_Mount& Resource_DiskInfo_Source_Mount::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source_Mount::default_instance_ = NULL;

Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source_Mount::New(::google::protobuf::Arena* arena) const {
  Resource_DiskInfo_Source_Mount* n = new Resource_DiskInfo_Source_Mount;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_DiskInfo_Source_Mount::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.DiskInfo.Source.Mount)
  if (has_root()) {
    root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_DiskInfo_Source_Mount::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Source.Mount)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string root = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_root()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->root().data(), this->root().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.DiskInfo.Source.Mount.root");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Source.Mount)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Source.Mount)
  return false;
#undef DO_
}

void Resource_DiskInfo_Source_Mount::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Source.Mount)
  // required string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Source.Mount.root");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->root(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Source.Mount)
}

::google::protobuf::uint8* Resource_DiskInfo_Source_Mount::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Source.Mount)
  // required string root = 1;
  if (has_root()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->root().data(), this->root().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.DiskInfo.Source.Mount.root");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->root(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Source.Mount)
  return target;
}

int Resource_DiskInfo_Source_Mount::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.DiskInfo.Source.Mount)
  int total_size = 0;

  // required string root = 1;
  if (has_root()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->root());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Source_Mount::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.DiskInfo.Source.Mount)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_DiskInfo_Source_Mount* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_DiskInfo_Source_Mount>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.DiskInfo.Source.Mount)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.DiskInfo.Source.Mount)
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Source_Mount::MergeFrom(const Resource_DiskInfo_Source_Mount& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.DiskInfo.Source.Mount)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_root()) {
      set_has_root();
      root_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.root_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_DiskInfo_Source_Mount::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.DiskInfo.Source.Mount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Source_Mount::CopyFrom(const Resource_DiskInfo_Source_Mount& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.DiskInfo.Source.Mount)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Source_Mount::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Resource_DiskInfo_Source_Mount::Swap(Resource_DiskInfo_Source_Mount* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_DiskInfo_Source_Mount::InternalSwap(Resource_DiskInfo_Source_Mount* other) {
  root_.Swap(&other->root_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_DiskInfo_Source_Mount::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Source_Mount_descriptor_;
  metadata.reflection = Resource_DiskInfo_Source_Mount_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_DiskInfo_Source::kTypeFieldNumber;
const int Resource_DiskInfo_Source::kPathFieldNumber;
const int Resource_DiskInfo_Source::kMountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_DiskInfo_Source::Resource_DiskInfo_Source()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo.Source)
}

void Resource_DiskInfo_Source::InitAsDefaultInstance() {
  path_ = const_cast< ::mesos::Resource_DiskInfo_Source_Path*>(&::mesos::Resource_DiskInfo_Source_Path::default_instance());
  mount_ = const_cast< ::mesos::Resource_DiskInfo_Source_Mount*>(&::mesos::Resource_DiskInfo_Source_Mount::default_instance());
}

Resource_DiskInfo_Source::Resource_DiskInfo_Source(const Resource_DiskInfo_Source& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo.Source)
}

void Resource_DiskInfo_Source::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  path_ = NULL;
  mount_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo_Source::~Resource_DiskInfo_Source() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo.Source)
  SharedDtor();
}

void Resource_DiskInfo_Source::SharedDtor() {
  if (this != default_instance_) {
    delete path_;
    delete mount_;
  }
}

void Resource_DiskInfo_Source::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo_Source::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_Source_descriptor_;
}

const Resource_DiskInfo_Source& Resource_DiskInfo_Source::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo_Source* Resource_DiskInfo_Source::default_instance_ = NULL;

Resource_DiskInfo_Source* Resource_DiskInfo_Source::New(::google::protobuf::Arena* arena) const {
  Resource_DiskInfo_Source* n = new Resource_DiskInfo_Source;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_DiskInfo_Source::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.DiskInfo.Source)
  if (_has_bits_[0 / 32] & 7u) {
    type_ = 1;
    if (has_path()) {
      if (path_ != NULL) path_->::mesos::Resource_DiskInfo_Source_Path::Clear();
    }
    if (has_mount()) {
      if (mount_ != NULL) mount_->::mesos::Resource_DiskInfo_Source_Mount::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_DiskInfo_Source::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo.Source)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Resource.DiskInfo.Source.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Resource_DiskInfo_Source_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Resource_DiskInfo_Source_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_mount;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
      case 3: {
        if (tag == 26) {
         parse_mount:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mount()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo.Source)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo.Source)
  return false;
#undef DO_
}

void Resource_DiskInfo_Source::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo.Source)
  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->path_, output);
  }

  // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
  if (has_mount()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->mount_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo.Source)
}

::google::protobuf::uint8* Resource_DiskInfo_Source::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo.Source)
  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
  if (has_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->path_, false, target);
  }

  // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
  if (has_mount()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->mount_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo.Source)
  return target;
}

int Resource_DiskInfo_Source::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.DiskInfo.Source)
  int total_size = 0;

  // required .mesos.Resource.DiskInfo.Source.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional .mesos.Resource.DiskInfo.Source.Path path = 2;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->path_);
    }

    // optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
    if (has_mount()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mount_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo_Source::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.DiskInfo.Source)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_DiskInfo_Source* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_DiskInfo_Source>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.DiskInfo.Source)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.DiskInfo.Source)
    MergeFrom(*source);
  }
}

void Resource_DiskInfo_Source::MergeFrom(const Resource_DiskInfo_Source& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.DiskInfo.Source)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_path()) {
      mutable_path()->::mesos::Resource_DiskInfo_Source_Path::MergeFrom(from.path());
    }
    if (from.has_mount()) {
      mutable_mount()->::mesos::Resource_DiskInfo_Source_Mount::MergeFrom(from.mount());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_DiskInfo_Source::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.DiskInfo.Source)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo_Source::CopyFrom(const Resource_DiskInfo_Source& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.DiskInfo.Source)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo_Source::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_path()) {
    if (!this->path_->IsInitialized()) return false;
  }
  if (has_mount()) {
    if (!this->mount_->IsInitialized()) return false;
  }
  return true;
}

void Resource_DiskInfo_Source::Swap(Resource_DiskInfo_Source* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_DiskInfo_Source::InternalSwap(Resource_DiskInfo_Source* other) {
  std::swap(type_, other->type_);
  std::swap(path_, other->path_);
  std::swap(mount_, other->mount_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_DiskInfo_Source::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_Source_descriptor_;
  metadata.reflection = Resource_DiskInfo_Source_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource_DiskInfo::kPersistenceFieldNumber;
const int Resource_DiskInfo::kVolumeFieldNumber;
const int Resource_DiskInfo::kSourceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_DiskInfo::Resource_DiskInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.DiskInfo)
}

void Resource_DiskInfo::InitAsDefaultInstance() {
  persistence_ = const_cast< ::mesos::Resource_DiskInfo_Persistence*>(&::mesos::Resource_DiskInfo_Persistence::default_instance());
  volume_ = const_cast< ::mesos::Volume*>(&::mesos::Volume::default_instance());
  source_ = const_cast< ::mesos::Resource_DiskInfo_Source*>(&::mesos::Resource_DiskInfo_Source::default_instance());
}

Resource_DiskInfo::Resource_DiskInfo(const Resource_DiskInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.DiskInfo)
}

void Resource_DiskInfo::SharedCtor() {
  _cached_size_ = 0;
  persistence_ = NULL;
  volume_ = NULL;
  source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_DiskInfo::~Resource_DiskInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.DiskInfo)
  SharedDtor();
}

void Resource_DiskInfo::SharedDtor() {
  if (this != default_instance_) {
    delete persistence_;
    delete volume_;
    delete source_;
  }
}

void Resource_DiskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_DiskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_DiskInfo_descriptor_;
}

const Resource_DiskInfo& Resource_DiskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_DiskInfo* Resource_DiskInfo::default_instance_ = NULL;

Resource_DiskInfo* Resource_DiskInfo::New(::google::protobuf::Arena* arena) const {
  Resource_DiskInfo* n = new Resource_DiskInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_DiskInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.DiskInfo)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_persistence()) {
      if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
    }
    if (has_volume()) {
      if (volume_ != NULL) volume_->::mesos::Volume::Clear();
    }
    if (has_source()) {
      if (source_ != NULL) source_->::mesos::Resource_DiskInfo_Source::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_DiskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.DiskInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_persistence()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_volume;
        break;
      }

      // optional .mesos.Volume volume = 2;
      case 2: {
        if (tag == 18) {
         parse_volume:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_volume()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_source;
        break;
      }

      // optional .mesos.Resource.DiskInfo.Source source = 3;
      case 3: {
        if (tag == 26) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.DiskInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.DiskInfo)
  return false;
#undef DO_
}

void Resource_DiskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.DiskInfo)
  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  if (has_persistence()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->persistence_, output);
  }

  // optional .mesos.Volume volume = 2;
  if (has_volume()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->volume_, output);
  }

  // optional .mesos.Resource.DiskInfo.Source source = 3;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->source_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.DiskInfo)
}

::google::protobuf::uint8* Resource_DiskInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.DiskInfo)
  // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
  if (has_persistence()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->persistence_, false, target);
  }

  // optional .mesos.Volume volume = 2;
  if (has_volume()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->volume_, false, target);
  }

  // optional .mesos.Resource.DiskInfo.Source source = 3;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->source_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.DiskInfo)
  return target;
}

int Resource_DiskInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.DiskInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
    if (has_persistence()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->persistence_);
    }

    // optional .mesos.Volume volume = 2;
    if (has_volume()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->volume_);
    }

    // optional .mesos.Resource.DiskInfo.Source source = 3;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_DiskInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.DiskInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_DiskInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_DiskInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.DiskInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.DiskInfo)
    MergeFrom(*source);
  }
}

void Resource_DiskInfo::MergeFrom(const Resource_DiskInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.DiskInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_persistence()) {
      mutable_persistence()->::mesos::Resource_DiskInfo_Persistence::MergeFrom(from.persistence());
    }
    if (from.has_volume()) {
      mutable_volume()->::mesos::Volume::MergeFrom(from.volume());
    }
    if (from.has_source()) {
      mutable_source()->::mesos::Resource_DiskInfo_Source::MergeFrom(from.source());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_DiskInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.DiskInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_DiskInfo::CopyFrom(const Resource_DiskInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.DiskInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_DiskInfo::IsInitialized() const {

  if (has_persistence()) {
    if (!this->persistence_->IsInitialized()) return false;
  }
  if (has_volume()) {
    if (!this->volume_->IsInitialized()) return false;
  }
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  return true;
}

void Resource_DiskInfo::Swap(Resource_DiskInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_DiskInfo::InternalSwap(Resource_DiskInfo* other) {
  std::swap(persistence_, other->persistence_);
  std::swap(volume_, other->volume_);
  std::swap(source_, other->source_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_DiskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_DiskInfo_descriptor_;
  metadata.reflection = Resource_DiskInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_RevocableInfo::Resource_RevocableInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.RevocableInfo)
}

void Resource_RevocableInfo::InitAsDefaultInstance() {
}

Resource_RevocableInfo::Resource_RevocableInfo(const Resource_RevocableInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.RevocableInfo)
}

void Resource_RevocableInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_RevocableInfo::~Resource_RevocableInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.RevocableInfo)
  SharedDtor();
}

void Resource_RevocableInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Resource_RevocableInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_RevocableInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_RevocableInfo_descriptor_;
}

const Resource_RevocableInfo& Resource_RevocableInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_RevocableInfo* Resource_RevocableInfo::default_instance_ = NULL;

Resource_RevocableInfo* Resource_RevocableInfo::New(::google::protobuf::Arena* arena) const {
  Resource_RevocableInfo* n = new Resource_RevocableInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_RevocableInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.RevocableInfo)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_RevocableInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.RevocableInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.RevocableInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.RevocableInfo)
  return false;
#undef DO_
}

void Resource_RevocableInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.RevocableInfo)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.RevocableInfo)
}

::google::protobuf::uint8* Resource_RevocableInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.RevocableInfo)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.RevocableInfo)
  return target;
}

int Resource_RevocableInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.RevocableInfo)
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_RevocableInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.RevocableInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_RevocableInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_RevocableInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.RevocableInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.RevocableInfo)
    MergeFrom(*source);
  }
}

void Resource_RevocableInfo::MergeFrom(const Resource_RevocableInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.RevocableInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_RevocableInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.RevocableInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_RevocableInfo::CopyFrom(const Resource_RevocableInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.RevocableInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_RevocableInfo::IsInitialized() const {

  return true;
}

void Resource_RevocableInfo::Swap(Resource_RevocableInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_RevocableInfo::InternalSwap(Resource_RevocableInfo* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_RevocableInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_RevocableInfo_descriptor_;
  metadata.reflection = Resource_RevocableInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource_SharedInfo::Resource_SharedInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource.SharedInfo)
}

void Resource_SharedInfo::InitAsDefaultInstance() {
}

Resource_SharedInfo::Resource_SharedInfo(const Resource_SharedInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource.SharedInfo)
}

void Resource_SharedInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource_SharedInfo::~Resource_SharedInfo() {
  // @@protoc_insertion_point(destructor:mesos.Resource.SharedInfo)
  SharedDtor();
}

void Resource_SharedInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Resource_SharedInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource_SharedInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_SharedInfo_descriptor_;
}

const Resource_SharedInfo& Resource_SharedInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource_SharedInfo* Resource_SharedInfo::default_instance_ = NULL;

Resource_SharedInfo* Resource_SharedInfo::New(::google::protobuf::Arena* arena) const {
  Resource_SharedInfo* n = new Resource_SharedInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource_SharedInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource.SharedInfo)
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource_SharedInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource.SharedInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormat::SkipField(
          input, tag, mutable_unknown_fields()));
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource.SharedInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource.SharedInfo)
  return false;
#undef DO_
}

void Resource_SharedInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource.SharedInfo)
  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource.SharedInfo)
}

::google::protobuf::uint8* Resource_SharedInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource.SharedInfo)
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource.SharedInfo)
  return target;
}

int Resource_SharedInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource.SharedInfo)
  int total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource_SharedInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource.SharedInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource_SharedInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource_SharedInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource.SharedInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource.SharedInfo)
    MergeFrom(*source);
  }
}

void Resource_SharedInfo::MergeFrom(const Resource_SharedInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource.SharedInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource_SharedInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource.SharedInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource_SharedInfo::CopyFrom(const Resource_SharedInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource.SharedInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource_SharedInfo::IsInitialized() const {

  return true;
}

void Resource_SharedInfo::Swap(Resource_SharedInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource_SharedInfo::InternalSwap(Resource_SharedInfo* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource_SharedInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_SharedInfo_descriptor_;
  metadata.reflection = Resource_SharedInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

::std::string* Resource::_default_role_ = NULL;
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Resource::kNameFieldNumber;
const int Resource::kTypeFieldNumber;
const int Resource::kScalarFieldNumber;
const int Resource::kRangesFieldNumber;
const int Resource::kSetFieldNumber;
const int Resource::kRoleFieldNumber;
const int Resource::kAllocationInfoFieldNumber;
const int Resource::kReservationFieldNumber;
const int Resource::kDiskFieldNumber;
const int Resource::kRevocableFieldNumber;
const int Resource::kSharedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Resource::Resource()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Resource)
}

void Resource::InitAsDefaultInstance() {
  scalar_ = const_cast< ::mesos::Value_Scalar*>(&::mesos::Value_Scalar::default_instance());
  ranges_ = const_cast< ::mesos::Value_Ranges*>(&::mesos::Value_Ranges::default_instance());
  set_ = const_cast< ::mesos::Value_Set*>(&::mesos::Value_Set::default_instance());
  allocation_info_ = const_cast< ::mesos::Resource_AllocationInfo*>(&::mesos::Resource_AllocationInfo::default_instance());
  reservation_ = const_cast< ::mesos::Resource_ReservationInfo*>(&::mesos::Resource_ReservationInfo::default_instance());
  disk_ = const_cast< ::mesos::Resource_DiskInfo*>(&::mesos::Resource_DiskInfo::default_instance());
  revocable_ = const_cast< ::mesos::Resource_RevocableInfo*>(&::mesos::Resource_RevocableInfo::default_instance());
  shared_ = const_cast< ::mesos::Resource_SharedInfo*>(&::mesos::Resource_SharedInfo::default_instance());
}

Resource::Resource(const Resource& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Resource)
}

void Resource::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 0;
  scalar_ = NULL;
  ranges_ = NULL;
  set_ = NULL;
  role_.UnsafeSetDefault(_default_role_);
  allocation_info_ = NULL;
  reservation_ = NULL;
  disk_ = NULL;
  revocable_ = NULL;
  shared_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Resource::~Resource() {
  // @@protoc_insertion_point(destructor:mesos.Resource)
  SharedDtor();
}

void Resource::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  role_.DestroyNoArena(_default_role_);
  if (this != default_instance_) {
    delete scalar_;
    delete ranges_;
    delete set_;
    delete allocation_info_;
    delete reservation_;
    delete disk_;
    delete revocable_;
    delete shared_;
  }
}

void Resource::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Resource::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Resource_descriptor_;
}

const Resource& Resource::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Resource* Resource::default_instance_ = NULL;

Resource* Resource::New(::google::protobuf::Arena* arena) const {
  Resource* n = new Resource;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Resource::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Resource)
  if (_has_bits_[0 / 32] & 255u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    type_ = 0;
    if (has_scalar()) {
      if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
    }
    if (has_ranges()) {
      if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
    }
    if (has_set()) {
      if (set_ != NULL) set_->::mesos::Value_Set::Clear();
    }
    if (has_role()) {
      role_.ClearToDefaultNoArena(_default_role_);
    }
    if (has_allocation_info()) {
      if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
    }
    if (has_reservation()) {
      if (reservation_ != NULL) reservation_->::mesos::Resource_ReservationInfo::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 1792u) {
    if (has_disk()) {
      if (disk_ != NULL) disk_->::mesos::Resource_DiskInfo::Clear();
    }
    if (has_revocable()) {
      if (revocable_ != NULL) revocable_->::mesos::Resource_RevocableInfo::Clear();
    }
    if (has_shared()) {
      if (shared_ != NULL) shared_->::mesos::Resource_SharedInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Resource::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Resource)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // required .mesos.Value.Type type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Value_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Value_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_scalar;
        break;
      }

      // optional .mesos.Value.Scalar scalar = 3;
      case 3: {
        if (tag == 26) {
         parse_scalar:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_scalar()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_ranges;
        break;
      }

      // optional .mesos.Value.Ranges ranges = 4;
      case 4: {
        if (tag == 34) {
         parse_ranges:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ranges()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_set;
        break;
      }

      // optional .mesos.Value.Set set = 5;
      case 5: {
        if (tag == 42) {
         parse_set:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_set()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_role;
        break;
      }

      // optional string role = 6 [default = "*"];
      case 6: {
        if (tag == 50) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Resource.role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_disk;
        break;
      }

      // optional .mesos.Resource.DiskInfo disk = 7;
      case 7: {
        if (tag == 58) {
         parse_disk:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_disk()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_reservation;
        break;
      }

      // optional .mesos.Resource.ReservationInfo reservation = 8;
      case 8: {
        if (tag == 66) {
         parse_reservation:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reservation()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_revocable;
        break;
      }

      // optional .mesos.Resource.RevocableInfo revocable = 9;
      case 9: {
        if (tag == 74) {
         parse_revocable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_revocable()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_shared;
        break;
      }

      // optional .mesos.Resource.SharedInfo shared = 10;
      case 10: {
        if (tag == 82) {
         parse_shared:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_shared()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_allocation_info;
        break;
      }

      // optional .mesos.Resource.AllocationInfo allocation_info = 11;
      case 11: {
        if (tag == 90) {
         parse_allocation_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_allocation_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Resource)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Resource)
  return false;
#undef DO_
}

void Resource::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Resource)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->type(), output);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->scalar_, output);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->ranges_, output);
  }

  // optional .mesos.Value.Set set = 5;
  if (has_set()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->set_, output);
  }

  // optional string role = 6 [default = "*"];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->role(), output);
  }

  // optional .mesos.Resource.DiskInfo disk = 7;
  if (has_disk()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->disk_, output);
  }

  // optional .mesos.Resource.ReservationInfo reservation = 8;
  if (has_reservation()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->reservation_, output);
  }

  // optional .mesos.Resource.RevocableInfo revocable = 9;
  if (has_revocable()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->revocable_, output);
  }

  // optional .mesos.Resource.SharedInfo shared = 10;
  if (has_shared()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->shared_, output);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 11;
  if (has_allocation_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->allocation_info_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Resource)
}

::google::protobuf::uint8* Resource::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Resource)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.Value.Type type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->type(), target);
  }

  // optional .mesos.Value.Scalar scalar = 3;
  if (has_scalar()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->scalar_, false, target);
  }

  // optional .mesos.Value.Ranges ranges = 4;
  if (has_ranges()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->ranges_, false, target);
  }

  // optional .mesos.Value.Set set = 5;
  if (has_set()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->set_, false, target);
  }

  // optional string role = 6 [default = "*"];
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Resource.role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->role(), target);
  }

  // optional .mesos.Resource.DiskInfo disk = 7;
  if (has_disk()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->disk_, false, target);
  }

  // optional .mesos.Resource.ReservationInfo reservation = 8;
  if (has_reservation()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->reservation_, false, target);
  }

  // optional .mesos.Resource.RevocableInfo revocable = 9;
  if (has_revocable()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->revocable_, false, target);
  }

  // optional .mesos.Resource.SharedInfo shared = 10;
  if (has_shared()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->shared_, false, target);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 11;
  if (has_allocation_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->allocation_info_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Resource)
  return target;
}

int Resource::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Resource)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_type()) {
    // required .mesos.Value.Type type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  return total_size;
}
int Resource::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Resource)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required .mesos.Value.Type type = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 252u) {
    // optional .mesos.Value.Scalar scalar = 3;
    if (has_scalar()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->scalar_);
    }

    // optional .mesos.Value.Ranges ranges = 4;
    if (has_ranges()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ranges_);
    }

    // optional .mesos.Value.Set set = 5;
    if (has_set()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->set_);
    }

    // optional string role = 6 [default = "*"];
    if (has_role()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->role());
    }

    // optional .mesos.Resource.AllocationInfo allocation_info = 11;
    if (has_allocation_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->allocation_info_);
    }

    // optional .mesos.Resource.ReservationInfo reservation = 8;
    if (has_reservation()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reservation_);
    }

  }
  if (_has_bits_[8 / 32] & 1792u) {
    // optional .mesos.Resource.DiskInfo disk = 7;
    if (has_disk()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->disk_);
    }

    // optional .mesos.Resource.RevocableInfo revocable = 9;
    if (has_revocable()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->revocable_);
    }

    // optional .mesos.Resource.SharedInfo shared = 10;
    if (has_shared()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->shared_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Resource::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Resource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Resource* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Resource>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Resource)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Resource)
    MergeFrom(*source);
  }
}

void Resource::MergeFrom(const Resource& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Resource)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_scalar()) {
      mutable_scalar()->::mesos::Value_Scalar::MergeFrom(from.scalar());
    }
    if (from.has_ranges()) {
      mutable_ranges()->::mesos::Value_Ranges::MergeFrom(from.ranges());
    }
    if (from.has_set()) {
      mutable_set()->::mesos::Value_Set::MergeFrom(from.set());
    }
    if (from.has_role()) {
      set_has_role();
      role_.AssignWithDefault(_default_role_, from.role_);
    }
    if (from.has_allocation_info()) {
      mutable_allocation_info()->::mesos::Resource_AllocationInfo::MergeFrom(from.allocation_info());
    }
    if (from.has_reservation()) {
      mutable_reservation()->::mesos::Resource_ReservationInfo::MergeFrom(from.reservation());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_disk()) {
      mutable_disk()->::mesos::Resource_DiskInfo::MergeFrom(from.disk());
    }
    if (from.has_revocable()) {
      mutable_revocable()->::mesos::Resource_RevocableInfo::MergeFrom(from.revocable());
    }
    if (from.has_shared()) {
      mutable_shared()->::mesos::Resource_SharedInfo::MergeFrom(from.shared());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Resource::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Resource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Resource::CopyFrom(const Resource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Resource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Resource::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_scalar()) {
    if (!this->scalar_->IsInitialized()) return false;
  }
  if (has_ranges()) {
    if (!this->ranges_->IsInitialized()) return false;
  }
  if (has_reservation()) {
    if (!this->reservation_->IsInitialized()) return false;
  }
  if (has_disk()) {
    if (!this->disk_->IsInitialized()) return false;
  }
  return true;
}

void Resource::Swap(Resource* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Resource::InternalSwap(Resource* other) {
  name_.Swap(&other->name_);
  std::swap(type_, other->type_);
  std::swap(scalar_, other->scalar_);
  std::swap(ranges_, other->ranges_);
  std::swap(set_, other->set_);
  role_.Swap(&other->role_);
  std::swap(allocation_info_, other->allocation_info_);
  std::swap(reservation_, other->reservation_);
  std::swap(disk_, other->disk_);
  std::swap(revocable_, other->revocable_);
  std::swap(shared_, other->shared_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Resource::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Resource_descriptor_;
  metadata.reflection = Resource_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Resource_AllocationInfo

// optional string role = 1;
bool Resource_AllocationInfo::has_role() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_AllocationInfo::set_has_role() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_AllocationInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_AllocationInfo::clear_role() {
  role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_role();
}
 const ::std::string& Resource_AllocationInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.AllocationInfo.role)
  return role_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_AllocationInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.AllocationInfo.role)
}
 void Resource_AllocationInfo::set_role(const char* value) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.AllocationInfo.role)
}
 void Resource_AllocationInfo::set_role(const char* value, size_t size) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.AllocationInfo.role)
}
 ::std::string* Resource_AllocationInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.AllocationInfo.role)
  return role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource_AllocationInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.Resource.AllocationInfo.role)
  clear_has_role();
  return role_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_AllocationInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.AllocationInfo.role)
}

// -------------------------------------------------------------------

// Resource_ReservationInfo

// optional string principal = 1;
bool Resource_ReservationInfo::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_ReservationInfo::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_ReservationInfo::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_ReservationInfo::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_principal();
}
 const ::std::string& Resource_ReservationInfo::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.principal)
  return principal_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_ReservationInfo::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.ReservationInfo.principal)
}
 void Resource_ReservationInfo::set_principal(const char* value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.ReservationInfo.principal)
}
 void Resource_ReservationInfo::set_principal(const char* value, size_t size) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.ReservationInfo.principal)
}
 ::std::string* Resource_ReservationInfo::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource_ReservationInfo::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ReservationInfo.principal)
  clear_has_principal();
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_ReservationInfo::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.principal)
}

// optional .mesos.Labels labels = 2;
bool Resource_ReservationInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Resource_ReservationInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000002u;
}
void Resource_ReservationInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000002u;
}
void Resource_ReservationInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& Resource_ReservationInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ReservationInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* Resource_ReservationInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ReservationInfo.labels)
  return labels_;
}
::mesos::Labels* Resource_ReservationInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ReservationInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void Resource_ReservationInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ReservationInfo.labels)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Persistence

// required string id = 1;
bool Resource_DiskInfo_Persistence::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_DiskInfo_Persistence::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_DiskInfo_Persistence::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_DiskInfo_Persistence::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& Resource_DiskInfo_Persistence::id() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Persistence.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Persistence::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Persistence.id)
}
 void Resource_DiskInfo_Persistence::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Persistence.id)
}
 void Resource_DiskInfo_Persistence::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Persistence.id)
}
 ::std::string* Resource_DiskInfo_Persistence::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Persistence.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource_DiskInfo_Persistence::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Persistence.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Persistence::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Persistence.id)
}

// optional string principal = 2;
bool Resource_DiskInfo_Persistence::has_principal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Resource_DiskInfo_Persistence::set_has_principal() {
  _has_bits_[0] |= 0x00000002u;
}
void Resource_DiskInfo_Persistence::clear_has_principal() {
  _has_bits_[0] &= ~0x00000002u;
}
void Resource_DiskInfo_Persistence::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_principal();
}
 const ::std::string& Resource_DiskInfo_Persistence::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Persistence.principal)
  return principal_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Persistence::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Persistence.principal)
}
 void Resource_DiskInfo_Persistence::set_principal(const char* value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Persistence.principal)
}
 void Resource_DiskInfo_Persistence::set_principal(const char* value, size_t size) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Persistence.principal)
}
 ::std::string* Resource_DiskInfo_Persistence::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Persistence.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource_DiskInfo_Persistence::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Persistence.principal)
  clear_has_principal();
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Persistence::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Persistence.principal)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source_Path

// required string root = 1;
bool Resource_DiskInfo_Source_Path::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_DiskInfo_Source_Path::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_DiskInfo_Source_Path::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_DiskInfo_Source_Path::clear_root() {
  root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_root();
}
 const ::std::string& Resource_DiskInfo_Source_Path::root() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.Path.root)
  return root_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Source_Path::set_root(const ::std::string& value) {
  set_has_root();
  root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.Path.root)
}
 void Resource_DiskInfo_Source_Path::set_root(const char* value) {
  set_has_root();
  root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.Path.root)
}
 void Resource_DiskInfo_Source_Path::set_root(const char* value, size_t size) {
  set_has_root();
  root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.Path.root)
}
 ::std::string* Resource_DiskInfo_Source_Path::mutable_root() {
  set_has_root();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.Path.root)
  return root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource_DiskInfo_Source_Path::release_root() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.Path.root)
  clear_has_root();
  return root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Source_Path::set_allocated_root(::std::string* root) {
  if (root != NULL) {
    set_has_root();
  } else {
    clear_has_root();
  }
  root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.Path.root)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source_Mount

// required string root = 1;
bool Resource_DiskInfo_Source_Mount::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_DiskInfo_Source_Mount::set_has_root() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_DiskInfo_Source_Mount::clear_has_root() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_DiskInfo_Source_Mount::clear_root() {
  root_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_root();
}
 const ::std::string& Resource_DiskInfo_Source_Mount::root() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.Mount.root)
  return root_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Source_Mount::set_root(const ::std::string& value) {
  set_has_root();
  root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.Mount.root)
}
 void Resource_DiskInfo_Source_Mount::set_root(const char* value) {
  set_has_root();
  root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.DiskInfo.Source.Mount.root)
}
 void Resource_DiskInfo_Source_Mount::set_root(const char* value, size_t size) {
  set_has_root();
  root_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.DiskInfo.Source.Mount.root)
}
 ::std::string* Resource_DiskInfo_Source_Mount::mutable_root() {
  set_has_root();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.Mount.root)
  return root_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource_DiskInfo_Source_Mount::release_root() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.Mount.root)
  clear_has_root();
  return root_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource_DiskInfo_Source_Mount::set_allocated_root(::std::string* root) {
  if (root != NULL) {
    set_has_root();
  } else {
    clear_has_root();
  }
  root_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), root);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.Mount.root)
}

// -------------------------------------------------------------------

// Resource_DiskInfo_Source

// required .mesos.Resource.DiskInfo.Source.Type type = 1;
bool Resource_DiskInfo_Source::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_DiskInfo_Source::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_DiskInfo_Source::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_DiskInfo_Source::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::mesos::Resource_DiskInfo_Source_Type Resource_DiskInfo_Source::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.type)
  return static_cast< ::mesos::Resource_DiskInfo_Source_Type >(type_);
}
 void Resource_DiskInfo_Source::set_type(::mesos::Resource_DiskInfo_Source_Type value) {
  assert(::mesos::Resource_DiskInfo_Source_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.DiskInfo.Source.type)
}

// optional .mesos.Resource.DiskInfo.Source.Path path = 2;
bool Resource_DiskInfo_Source::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Resource_DiskInfo_Source::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
void Resource_DiskInfo_Source::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
void Resource_DiskInfo_Source::clear_path() {
  if (path_ != NULL) path_->::mesos::Resource_DiskInfo_Source_Path::Clear();
  clear_has_path();
}
const ::mesos::Resource_DiskInfo_Source_Path& Resource_DiskInfo_Source::path() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.path)
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::mutable_path() {
  set_has_path();
  if (path_ == NULL) {
    path_ = new ::mesos::Resource_DiskInfo_Source_Path;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.path)
  return path_;
}
::mesos::Resource_DiskInfo_Source_Path* Resource_DiskInfo_Source::release_path() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.path)
  clear_has_path();
  ::mesos::Resource_DiskInfo_Source_Path* temp = path_;
  path_ = NULL;
  return temp;
}
void Resource_DiskInfo_Source::set_allocated_path(::mesos::Resource_DiskInfo_Source_Path* path) {
  delete path_;
  path_ = path;
  if (path) {
    set_has_path();
  } else {
    clear_has_path();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.path)
}

// optional .mesos.Resource.DiskInfo.Source.Mount mount = 3;
bool Resource_DiskInfo_Source::has_mount() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Resource_DiskInfo_Source::set_has_mount() {
  _has_bits_[0] |= 0x00000004u;
}
void Resource_DiskInfo_Source::clear_has_mount() {
  _has_bits_[0] &= ~0x00000004u;
}
void Resource_DiskInfo_Source::clear_mount() {
  if (mount_ != NULL) mount_->::mesos::Resource_DiskInfo_Source_Mount::Clear();
  clear_has_mount();
}
const ::mesos::Resource_DiskInfo_Source_Mount& Resource_DiskInfo_Source::mount() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.Source.mount)
  return mount_ != NULL ? *mount_ : *default_instance_->mount_;
}
::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::mutable_mount() {
  set_has_mount();
  if (mount_ == NULL) {
    mount_ = new ::mesos::Resource_DiskInfo_Source_Mount;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.Source.mount)
  return mount_;
}
::mesos::Resource_DiskInfo_Source_Mount* Resource_DiskInfo_Source::release_mount() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.Source.mount)
  clear_has_mount();
  ::mesos::Resource_DiskInfo_Source_Mount* temp = mount_;
  mount_ = NULL;
  return temp;
}
void Resource_DiskInfo_Source::set_allocated_mount(::mesos::Resource_DiskInfo_Source_Mount* mount) {
  delete mount_;
  mount_ = mount;
  if (mount) {
    set_has_mount();
  } else {
    clear_has_mount();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.Source.mount)
}

// -------------------------------------------------------------------

// Resource_DiskInfo

// optional .mesos.Resource.DiskInfo.Persistence persistence = 1;
bool Resource_DiskInfo::has_persistence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource_DiskInfo::set_has_persistence() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource_DiskInfo::clear_has_persistence() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource_DiskInfo::clear_persistence() {
  if (persistence_ != NULL) persistence_->::mesos::Resource_DiskInfo_Persistence::Clear();
  clear_has_persistence();
}
const ::mesos::Resource_DiskInfo_Persistence& Resource_DiskInfo::persistence() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.persistence)
  return persistence_ != NULL ? *persistence_ : *default_instance_->persistence_;
}
::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::mutable_persistence() {
  set_has_persistence();
  if (persistence_ == NULL) {
    persistence_ = new ::mesos::Resource_DiskInfo_Persistence;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.persistence)
  return persistence_;
}
::mesos::Resource_DiskInfo_Persistence* Resource_DiskInfo::release_persistence() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.persistence)
  clear_has_persistence();
  ::mesos::Resource_DiskInfo_Persistence* temp = persistence_;
  persistence_ = NULL;
  return temp;
}
void Resource_DiskInfo::set_allocated_persistence(::mesos::Resource_DiskInfo_Persistence* persistence) {
  delete persistence_;
  persistence_ = persistence;
  if (persistence) {
    set_has_persistence();
  } else {
    clear_has_persistence();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.persistence)
}

// optional .mesos.Volume volume = 2;
bool Resource_DiskInfo::has_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Resource_DiskInfo::set_has_volume() {
  _has_bits_[0] |= 0x00000002u;
}
void Resource_DiskInfo::clear_has_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
void Resource_DiskInfo::clear_volume() {
  if (volume_ != NULL) volume_->::mesos::Volume::Clear();
  clear_has_volume();
}
const ::mesos::Volume& Resource_DiskInfo::volume() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.volume)
  return volume_ != NULL ? *volume_ : *default_instance_->volume_;
}
::mesos::Volume* Resource_DiskInfo::mutable_volume() {
  set_has_volume();
  if (volume_ == NULL) {
    volume_ = new ::mesos::Volume;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.volume)
  return volume_;
}
::mesos::Volume* Resource_DiskInfo::release_volume() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.volume)
  clear_has_volume();
  ::mesos::Volume* temp = volume_;
  volume_ = NULL;
  return temp;
}
void Resource_DiskInfo::set_allocated_volume(::mesos::Volume* volume) {
  delete volume_;
  volume_ = volume;
  if (volume) {
    set_has_volume();
  } else {
    clear_has_volume();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.volume)
}

// optional .mesos.Resource.DiskInfo.Source source = 3;
bool Resource_DiskInfo::has_source() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Resource_DiskInfo::set_has_source() {
  _has_bits_[0] |= 0x00000004u;
}
void Resource_DiskInfo::clear_has_source() {
  _has_bits_[0] &= ~0x00000004u;
}
void Resource_DiskInfo::clear_source() {
  if (source_ != NULL) source_->::mesos::Resource_DiskInfo_Source::Clear();
  clear_has_source();
}
const ::mesos::Resource_DiskInfo_Source& Resource_DiskInfo::source() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.DiskInfo.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::mesos::Resource_DiskInfo_Source;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.DiskInfo.source)
  return source_;
}
::mesos::Resource_DiskInfo_Source* Resource_DiskInfo::release_source() {
  // @@protoc_insertion_point(field_release:mesos.Resource.DiskInfo.source)
  clear_has_source();
  ::mesos::Resource_DiskInfo_Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Resource_DiskInfo::set_allocated_source(::mesos::Resource_DiskInfo_Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.DiskInfo.source)
}

// -------------------------------------------------------------------

// Resource_RevocableInfo

// -------------------------------------------------------------------

// Resource_SharedInfo

// -------------------------------------------------------------------

// Resource

// required string name = 1;
bool Resource::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Resource::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Resource::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Resource::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Resource::name() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Resource.name)
}
 void Resource::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.name)
}
 void Resource::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.name)
}
 ::std::string* Resource::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Resource::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Resource.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Resource::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.name)
}

// required .mesos.Value.Type type = 2;
bool Resource::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Resource::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void Resource::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void Resource::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Value_Type Resource::type() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.type)
  return static_cast< ::mesos::Value_Type >(type_);
}
 void Resource::set_type(::mesos::Value_Type value) {
  assert(::mesos::Value_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Resource.type)
}

// optional .mesos.Value.Scalar scalar = 3;
bool Resource::has_scalar() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Resource::set_has_scalar() {
  _has_bits_[0] |= 0x00000004u;
}
void Resource::clear_has_scalar() {
  _has_bits_[0] &= ~0x00000004u;
}
void Resource::clear_scalar() {
  if (scalar_ != NULL) scalar_->::mesos::Value_Scalar::Clear();
  clear_has_scalar();
}
const ::mesos::Value_Scalar& Resource::scalar() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.scalar)
  return scalar_ != NULL ? *scalar_ : *default_instance_->scalar_;
}
::mesos::Value_Scalar* Resource::mutable_scalar() {
  set_has_scalar();
  if (scalar_ == NULL) {
    scalar_ = new ::mesos::Value_Scalar;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.scalar)
  return scalar_;
}
::mesos::Value_Scalar* Resource::release_scalar() {
  // @@protoc_insertion_point(field_release:mesos.Resource.scalar)
  clear_has_scalar();
  ::mesos::Value_Scalar* temp = scalar_;
  scalar_ = NULL;
  return temp;
}
void Resource::set_allocated_scalar(::mesos::Value_Scalar* scalar) {
  delete scalar_;
  scalar_ = scalar;
  if (scalar) {
    set_has_scalar();
  } else {
    clear_has_scalar();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.scalar)
}

// optional .mesos.Value.Ranges ranges = 4;
bool Resource::has_ranges() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Resource::set_has_ranges() {
  _has_bits_[0] |= 0x00000008u;
}
void Resource::clear_has_ranges() {
  _has_bits_[0] &= ~0x00000008u;
}
void Resource::clear_ranges() {
  if (ranges_ != NULL) ranges_->::mesos::Value_Ranges::Clear();
  clear_has_ranges();
}
const ::mesos::Value_Ranges& Resource::ranges() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.ranges)
  return ranges_ != NULL ? *ranges_ : *default_instance_->ranges_;
}
::mesos::Value_Ranges* Resource::mutable_ranges() {
  set_has_ranges();
  if (ranges_ == NULL) {
    ranges_ = new ::mesos::Value_Ranges;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.ranges)
  return ranges_;
}
::mesos::Value_Ranges* Resource::release_ranges() {
  // @@protoc_insertion_point(field_release:mesos.Resource.ranges)
  clear_has_ranges();
  ::mesos::Value_Ranges* temp = ranges_;
  ranges_ = NULL;
  return temp;
}
void Resource::set_allocated_ranges(::mesos::Value_Ranges* ranges) {
  delete ranges_;
  ranges_ = ranges;
  if (ranges) {
    set_has_ranges();
  } else {
    clear_has_ranges();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.ranges)
}

// optional .mesos.Value.Set set = 5;
bool Resource::has_set() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Resource::set_has_set() {
  _has_bits_[0] |= 0x00000010u;
}
void Resource::clear_has_set() {
  _has_bits_[0] &= ~0x00000010u;
}
void Resource::clear_set() {
  if (set_ != NULL) set_->::mesos::Value_Set::Clear();
  clear_has_set();
}
const ::mesos::Value_Set& Resource::set() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.set)
  return set_ != NULL ? *set_ : *default_instance_->set_;
}
::mesos::Value_Set* Resource::mutable_set() {
  set_has_set();
  if (set_ == NULL) {
    set_ = new ::mesos::Value_Set;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.set)
  return set_;
}
::mesos::Value_Set* Resource::release_set() {
  // @@protoc_insertion_point(field_release:mesos.Resource.set)
  clear_has_set();
  ::mesos::Value_Set* temp = set_;
  set_ = NULL;
  return temp;
}
void Resource::set_allocated_set(::mesos::Value_Set* set) {
  delete set_;
  set_ = set;
  if (set) {
    set_has_set();
  } else {
    clear_has_set();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.set)
}

// optional string role = 6 [default = "*"];
bool Resource::has_role() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Resource::set_has_role() {
  _has_bits_[0] |= 0x00000020u;
}
void Resource::clear_has_role() {
  _has_bits_[0] &= ~0x00000020u;
}
void Resource::clear_role() {
  role_.ClearToDefaultNoArena(_default_role_);
  clear_has_role();
}
 const ::std::string& Resource::role() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.role)
  return role_.GetNoArena(_default_role_);
}
 void Resource::set_role(const ::std::string& value) {
  set_has_role();
  role_.SetNoArena(_default_role_, value);
  // @@protoc_insertion_point(field_set:mesos.Resource.role)
}
 void Resource::set_role(const char* value) {
  set_has_role();
  role_.SetNoArena(_default_role_, ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Resource.role)
}
 void Resource::set_role(const char* value, size_t size) {
  set_has_role();
  role_.SetNoArena(_default_role_,
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Resource.role)
}
 ::std::string* Resource::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.Resource.role)
  return role_.MutableNoArena(_default_role_);
}
 ::std::string* Resource::release_role() {
  // @@protoc_insertion_point(field_release:mesos.Resource.role)
  clear_has_role();
  return role_.ReleaseNoArena(_default_role_);
}
 void Resource::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocatedNoArena(_default_role_, role);
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.role)
}

// optional .mesos.Resource.AllocationInfo allocation_info = 11;
bool Resource::has_allocation_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Resource::set_has_allocation_info() {
  _has_bits_[0] |= 0x00000040u;
}
void Resource::clear_has_allocation_info() {
  _has_bits_[0] &= ~0x00000040u;
}
void Resource::clear_allocation_info() {
  if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
  clear_has_allocation_info();
}
const ::mesos::Resource_AllocationInfo& Resource::allocation_info() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.allocation_info)
  return allocation_info_ != NULL ? *allocation_info_ : *default_instance_->allocation_info_;
}
::mesos::Resource_AllocationInfo* Resource::mutable_allocation_info() {
  set_has_allocation_info();
  if (allocation_info_ == NULL) {
    allocation_info_ = new ::mesos::Resource_AllocationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.allocation_info)
  return allocation_info_;
}
::mesos::Resource_AllocationInfo* Resource::release_allocation_info() {
  // @@protoc_insertion_point(field_release:mesos.Resource.allocation_info)
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  allocation_info_ = NULL;
  return temp;
}
void Resource::set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info) {
  delete allocation_info_;
  allocation_info_ = allocation_info;
  if (allocation_info) {
    set_has_allocation_info();
  } else {
    clear_has_allocation_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.allocation_info)
}

// optional .mesos.Resource.ReservationInfo reservation = 8;
bool Resource::has_reservation() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void Resource::set_has_reservation() {
  _has_bits_[0] |= 0x00000080u;
}
void Resource::clear_has_reservation() {
  _has_bits_[0] &= ~0x00000080u;
}
void Resource::clear_reservation() {
  if (reservation_ != NULL) reservation_->::mesos::Resource_ReservationInfo::Clear();
  clear_has_reservation();
}
const ::mesos::Resource_ReservationInfo& Resource::reservation() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.reservation)
  return reservation_ != NULL ? *reservation_ : *default_instance_->reservation_;
}
::mesos::Resource_ReservationInfo* Resource::mutable_reservation() {
  set_has_reservation();
  if (reservation_ == NULL) {
    reservation_ = new ::mesos::Resource_ReservationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.reservation)
  return reservation_;
}
::mesos::Resource_ReservationInfo* Resource::release_reservation() {
  // @@protoc_insertion_point(field_release:mesos.Resource.reservation)
  clear_has_reservation();
  ::mesos::Resource_ReservationInfo* temp = reservation_;
  reservation_ = NULL;
  return temp;
}
void Resource::set_allocated_reservation(::mesos::Resource_ReservationInfo* reservation) {
  delete reservation_;
  reservation_ = reservation;
  if (reservation) {
    set_has_reservation();
  } else {
    clear_has_reservation();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.reservation)
}

// optional .mesos.Resource.DiskInfo disk = 7;
bool Resource::has_disk() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Resource::set_has_disk() {
  _has_bits_[0] |= 0x00000100u;
}
void Resource::clear_has_disk() {
  _has_bits_[0] &= ~0x00000100u;
}
void Resource::clear_disk() {
  if (disk_ != NULL) disk_->::mesos::Resource_DiskInfo::Clear();
  clear_has_disk();
}
const ::mesos::Resource_DiskInfo& Resource::disk() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.disk)
  return disk_ != NULL ? *disk_ : *default_instance_->disk_;
}
::mesos::Resource_DiskInfo* Resource::mutable_disk() {
  set_has_disk();
  if (disk_ == NULL) {
    disk_ = new ::mesos::Resource_DiskInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.disk)
  return disk_;
}
::mesos::Resource_DiskInfo* Resource::release_disk() {
  // @@protoc_insertion_point(field_release:mesos.Resource.disk)
  clear_has_disk();
  ::mesos::Resource_DiskInfo* temp = disk_;
  disk_ = NULL;
  return temp;
}
void Resource::set_allocated_disk(::mesos::Resource_DiskInfo* disk) {
  delete disk_;
  disk_ = disk;
  if (disk) {
    set_has_disk();
  } else {
    clear_has_disk();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.disk)
}

// optional .mesos.Resource.RevocableInfo revocable = 9;
bool Resource::has_revocable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Resource::set_has_revocable() {
  _has_bits_[0] |= 0x00000200u;
}
void Resource::clear_has_revocable() {
  _has_bits_[0] &= ~0x00000200u;
}
void Resource::clear_revocable() {
  if (revocable_ != NULL) revocable_->::mesos::Resource_RevocableInfo::Clear();
  clear_has_revocable();
}
const ::mesos::Resource_RevocableInfo& Resource::revocable() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.revocable)
  return revocable_ != NULL ? *revocable_ : *default_instance_->revocable_;
}
::mesos::Resource_RevocableInfo* Resource::mutable_revocable() {
  set_has_revocable();
  if (revocable_ == NULL) {
    revocable_ = new ::mesos::Resource_RevocableInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.revocable)
  return revocable_;
}
::mesos::Resource_RevocableInfo* Resource::release_revocable() {
  // @@protoc_insertion_point(field_release:mesos.Resource.revocable)
  clear_has_revocable();
  ::mesos::Resource_RevocableInfo* temp = revocable_;
  revocable_ = NULL;
  return temp;
}
void Resource::set_allocated_revocable(::mesos::Resource_RevocableInfo* revocable) {
  delete revocable_;
  revocable_ = revocable;
  if (revocable) {
    set_has_revocable();
  } else {
    clear_has_revocable();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.revocable)
}

// optional .mesos.Resource.SharedInfo shared = 10;
bool Resource::has_shared() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Resource::set_has_shared() {
  _has_bits_[0] |= 0x00000400u;
}
void Resource::clear_has_shared() {
  _has_bits_[0] &= ~0x00000400u;
}
void Resource::clear_shared() {
  if (shared_ != NULL) shared_->::mesos::Resource_SharedInfo::Clear();
  clear_has_shared();
}
const ::mesos::Resource_SharedInfo& Resource::shared() const {
  // @@protoc_insertion_point(field_get:mesos.Resource.shared)
  return shared_ != NULL ? *shared_ : *default_instance_->shared_;
}
::mesos::Resource_SharedInfo* Resource::mutable_shared() {
  set_has_shared();
  if (shared_ == NULL) {
    shared_ = new ::mesos::Resource_SharedInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Resource.shared)
  return shared_;
}
::mesos::Resource_SharedInfo* Resource::release_shared() {
  // @@protoc_insertion_point(field_release:mesos.Resource.shared)
  clear_has_shared();
  ::mesos::Resource_SharedInfo* temp = shared_;
  shared_ = NULL;
  return temp;
}
void Resource::set_allocated_shared(::mesos::Resource_SharedInfo* shared) {
  delete shared_;
  shared_ = shared;
  if (shared) {
    set_has_shared();
  } else {
    clear_has_shared();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Resource.shared)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TrafficControlStatistics::kIdFieldNumber;
const int TrafficControlStatistics::kBacklogFieldNumber;
const int TrafficControlStatistics::kBytesFieldNumber;
const int TrafficControlStatistics::kDropsFieldNumber;
const int TrafficControlStatistics::kOverlimitsFieldNumber;
const int TrafficControlStatistics::kPacketsFieldNumber;
const int TrafficControlStatistics::kQlenFieldNumber;
const int TrafficControlStatistics::kRatebpsFieldNumber;
const int TrafficControlStatistics::kRateppsFieldNumber;
const int TrafficControlStatistics::kRequeuesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TrafficControlStatistics::TrafficControlStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TrafficControlStatistics)
}

void TrafficControlStatistics::InitAsDefaultInstance() {
}

TrafficControlStatistics::TrafficControlStatistics(const TrafficControlStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TrafficControlStatistics)
}

void TrafficControlStatistics::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  backlog_ = GOOGLE_ULONGLONG(0);
  bytes_ = GOOGLE_ULONGLONG(0);
  drops_ = GOOGLE_ULONGLONG(0);
  overlimits_ = GOOGLE_ULONGLONG(0);
  packets_ = GOOGLE_ULONGLONG(0);
  qlen_ = GOOGLE_ULONGLONG(0);
  ratebps_ = GOOGLE_ULONGLONG(0);
  ratepps_ = GOOGLE_ULONGLONG(0);
  requeues_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TrafficControlStatistics::~TrafficControlStatistics() {
  // @@protoc_insertion_point(destructor:mesos.TrafficControlStatistics)
  SharedDtor();
}

void TrafficControlStatistics::SharedDtor() {
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void TrafficControlStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TrafficControlStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TrafficControlStatistics_descriptor_;
}

const TrafficControlStatistics& TrafficControlStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TrafficControlStatistics* TrafficControlStatistics::default_instance_ = NULL;

TrafficControlStatistics* TrafficControlStatistics::New(::google::protobuf::Arena* arena) const {
  TrafficControlStatistics* n = new TrafficControlStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TrafficControlStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TrafficControlStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TrafficControlStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TrafficControlStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(backlog_, ratebps_);
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ZR_(ratepps_, requeues_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TrafficControlStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TrafficControlStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.TrafficControlStatistics.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_backlog;
        break;
      }

      // optional uint64 backlog = 2;
      case 2: {
        if (tag == 16) {
         parse_backlog:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &backlog_)));
          set_has_backlog();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_bytes;
        break;
      }

      // optional uint64 bytes = 3;
      case 3: {
        if (tag == 24) {
         parse_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bytes_)));
          set_has_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_drops;
        break;
      }

      // optional uint64 drops = 4;
      case 4: {
        if (tag == 32) {
         parse_drops:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &drops_)));
          set_has_drops();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_overlimits;
        break;
      }

      // optional uint64 overlimits = 5;
      case 5: {
        if (tag == 40) {
         parse_overlimits:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &overlimits_)));
          set_has_overlimits();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_packets;
        break;
      }

      // optional uint64 packets = 6;
      case 6: {
        if (tag == 48) {
         parse_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &packets_)));
          set_has_packets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_qlen;
        break;
      }

      // optional uint64 qlen = 7;
      case 7: {
        if (tag == 56) {
         parse_qlen:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &qlen_)));
          set_has_qlen();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_ratebps;
        break;
      }

      // optional uint64 ratebps = 8;
      case 8: {
        if (tag == 64) {
         parse_ratebps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ratebps_)));
          set_has_ratebps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_ratepps;
        break;
      }

      // optional uint64 ratepps = 9;
      case 9: {
        if (tag == 72) {
         parse_ratepps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ratepps_)));
          set_has_ratepps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_requeues;
        break;
      }

      // optional uint64 requeues = 10;
      case 10: {
        if (tag == 80) {
         parse_requeues:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &requeues_)));
          set_has_requeues();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TrafficControlStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TrafficControlStatistics)
  return false;
#undef DO_
}

void TrafficControlStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TrafficControlStatistics)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TrafficControlStatistics.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->id(), output);
  }

  // optional uint64 backlog = 2;
  if (has_backlog()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->backlog(), output);
  }

  // optional uint64 bytes = 3;
  if (has_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->bytes(), output);
  }

  // optional uint64 drops = 4;
  if (has_drops()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->drops(), output);
  }

  // optional uint64 overlimits = 5;
  if (has_overlimits()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->overlimits(), output);
  }

  // optional uint64 packets = 6;
  if (has_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->packets(), output);
  }

  // optional uint64 qlen = 7;
  if (has_qlen()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->qlen(), output);
  }

  // optional uint64 ratebps = 8;
  if (has_ratebps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->ratebps(), output);
  }

  // optional uint64 ratepps = 9;
  if (has_ratepps()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->ratepps(), output);
  }

  // optional uint64 requeues = 10;
  if (has_requeues()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->requeues(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TrafficControlStatistics)
}

::google::protobuf::uint8* TrafficControlStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TrafficControlStatistics)
  // required string id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TrafficControlStatistics.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->id(), target);
  }

  // optional uint64 backlog = 2;
  if (has_backlog()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->backlog(), target);
  }

  // optional uint64 bytes = 3;
  if (has_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->bytes(), target);
  }

  // optional uint64 drops = 4;
  if (has_drops()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->drops(), target);
  }

  // optional uint64 overlimits = 5;
  if (has_overlimits()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->overlimits(), target);
  }

  // optional uint64 packets = 6;
  if (has_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->packets(), target);
  }

  // optional uint64 qlen = 7;
  if (has_qlen()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->qlen(), target);
  }

  // optional uint64 ratebps = 8;
  if (has_ratebps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->ratebps(), target);
  }

  // optional uint64 ratepps = 9;
  if (has_ratepps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->ratepps(), target);
  }

  // optional uint64 requeues = 10;
  if (has_requeues()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->requeues(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TrafficControlStatistics)
  return target;
}

int TrafficControlStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TrafficControlStatistics)
  int total_size = 0;

  // required string id = 1;
  if (has_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->id());
  }
  if (_has_bits_[1 / 32] & 254u) {
    // optional uint64 backlog = 2;
    if (has_backlog()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->backlog());
    }

    // optional uint64 bytes = 3;
    if (has_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bytes());
    }

    // optional uint64 drops = 4;
    if (has_drops()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->drops());
    }

    // optional uint64 overlimits = 5;
    if (has_overlimits()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->overlimits());
    }

    // optional uint64 packets = 6;
    if (has_packets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->packets());
    }

    // optional uint64 qlen = 7;
    if (has_qlen()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->qlen());
    }

    // optional uint64 ratebps = 8;
    if (has_ratebps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ratebps());
    }

  }
  if (_has_bits_[8 / 32] & 768u) {
    // optional uint64 ratepps = 9;
    if (has_ratepps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ratepps());
    }

    // optional uint64 requeues = 10;
    if (has_requeues()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->requeues());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TrafficControlStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TrafficControlStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TrafficControlStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TrafficControlStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TrafficControlStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TrafficControlStatistics)
    MergeFrom(*source);
  }
}

void TrafficControlStatistics::MergeFrom(const TrafficControlStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TrafficControlStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_backlog()) {
      set_backlog(from.backlog());
    }
    if (from.has_bytes()) {
      set_bytes(from.bytes());
    }
    if (from.has_drops()) {
      set_drops(from.drops());
    }
    if (from.has_overlimits()) {
      set_overlimits(from.overlimits());
    }
    if (from.has_packets()) {
      set_packets(from.packets());
    }
    if (from.has_qlen()) {
      set_qlen(from.qlen());
    }
    if (from.has_ratebps()) {
      set_ratebps(from.ratebps());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_ratepps()) {
      set_ratepps(from.ratepps());
    }
    if (from.has_requeues()) {
      set_requeues(from.requeues());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TrafficControlStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TrafficControlStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TrafficControlStatistics::CopyFrom(const TrafficControlStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TrafficControlStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TrafficControlStatistics::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void TrafficControlStatistics::Swap(TrafficControlStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TrafficControlStatistics::InternalSwap(TrafficControlStatistics* other) {
  id_.Swap(&other->id_);
  std::swap(backlog_, other->backlog_);
  std::swap(bytes_, other->bytes_);
  std::swap(drops_, other->drops_);
  std::swap(overlimits_, other->overlimits_);
  std::swap(packets_, other->packets_);
  std::swap(qlen_, other->qlen_);
  std::swap(ratebps_, other->ratebps_);
  std::swap(ratepps_, other->ratepps_);
  std::swap(requeues_, other->requeues_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TrafficControlStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TrafficControlStatistics_descriptor_;
  metadata.reflection = TrafficControlStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TrafficControlStatistics

// required string id = 1;
bool TrafficControlStatistics::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TrafficControlStatistics::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TrafficControlStatistics::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TrafficControlStatistics::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& TrafficControlStatistics::id() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TrafficControlStatistics::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.id)
}
 void TrafficControlStatistics::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TrafficControlStatistics.id)
}
 void TrafficControlStatistics::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TrafficControlStatistics.id)
}
 ::std::string* TrafficControlStatistics::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.TrafficControlStatistics.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TrafficControlStatistics::release_id() {
  // @@protoc_insertion_point(field_release:mesos.TrafficControlStatistics.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TrafficControlStatistics::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mesos.TrafficControlStatistics.id)
}

// optional uint64 backlog = 2;
bool TrafficControlStatistics::has_backlog() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TrafficControlStatistics::set_has_backlog() {
  _has_bits_[0] |= 0x00000002u;
}
void TrafficControlStatistics::clear_has_backlog() {
  _has_bits_[0] &= ~0x00000002u;
}
void TrafficControlStatistics::clear_backlog() {
  backlog_ = GOOGLE_ULONGLONG(0);
  clear_has_backlog();
}
 ::google::protobuf::uint64 TrafficControlStatistics::backlog() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.backlog)
  return backlog_;
}
 void TrafficControlStatistics::set_backlog(::google::protobuf::uint64 value) {
  set_has_backlog();
  backlog_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.backlog)
}

// optional uint64 bytes = 3;
bool TrafficControlStatistics::has_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TrafficControlStatistics::set_has_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
void TrafficControlStatistics::clear_has_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
void TrafficControlStatistics::clear_bytes() {
  bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes();
}
 ::google::protobuf::uint64 TrafficControlStatistics::bytes() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.bytes)
  return bytes_;
}
 void TrafficControlStatistics::set_bytes(::google::protobuf::uint64 value) {
  set_has_bytes();
  bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.bytes)
}

// optional uint64 drops = 4;
bool TrafficControlStatistics::has_drops() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TrafficControlStatistics::set_has_drops() {
  _has_bits_[0] |= 0x00000008u;
}
void TrafficControlStatistics::clear_has_drops() {
  _has_bits_[0] &= ~0x00000008u;
}
void TrafficControlStatistics::clear_drops() {
  drops_ = GOOGLE_ULONGLONG(0);
  clear_has_drops();
}
 ::google::protobuf::uint64 TrafficControlStatistics::drops() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.drops)
  return drops_;
}
 void TrafficControlStatistics::set_drops(::google::protobuf::uint64 value) {
  set_has_drops();
  drops_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.drops)
}

// optional uint64 overlimits = 5;
bool TrafficControlStatistics::has_overlimits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TrafficControlStatistics::set_has_overlimits() {
  _has_bits_[0] |= 0x00000010u;
}
void TrafficControlStatistics::clear_has_overlimits() {
  _has_bits_[0] &= ~0x00000010u;
}
void TrafficControlStatistics::clear_overlimits() {
  overlimits_ = GOOGLE_ULONGLONG(0);
  clear_has_overlimits();
}
 ::google::protobuf::uint64 TrafficControlStatistics::overlimits() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.overlimits)
  return overlimits_;
}
 void TrafficControlStatistics::set_overlimits(::google::protobuf::uint64 value) {
  set_has_overlimits();
  overlimits_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.overlimits)
}

// optional uint64 packets = 6;
bool TrafficControlStatistics::has_packets() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TrafficControlStatistics::set_has_packets() {
  _has_bits_[0] |= 0x00000020u;
}
void TrafficControlStatistics::clear_has_packets() {
  _has_bits_[0] &= ~0x00000020u;
}
void TrafficControlStatistics::clear_packets() {
  packets_ = GOOGLE_ULONGLONG(0);
  clear_has_packets();
}
 ::google::protobuf::uint64 TrafficControlStatistics::packets() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.packets)
  return packets_;
}
 void TrafficControlStatistics::set_packets(::google::protobuf::uint64 value) {
  set_has_packets();
  packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.packets)
}

// optional uint64 qlen = 7;
bool TrafficControlStatistics::has_qlen() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TrafficControlStatistics::set_has_qlen() {
  _has_bits_[0] |= 0x00000040u;
}
void TrafficControlStatistics::clear_has_qlen() {
  _has_bits_[0] &= ~0x00000040u;
}
void TrafficControlStatistics::clear_qlen() {
  qlen_ = GOOGLE_ULONGLONG(0);
  clear_has_qlen();
}
 ::google::protobuf::uint64 TrafficControlStatistics::qlen() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.qlen)
  return qlen_;
}
 void TrafficControlStatistics::set_qlen(::google::protobuf::uint64 value) {
  set_has_qlen();
  qlen_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.qlen)
}

// optional uint64 ratebps = 8;
bool TrafficControlStatistics::has_ratebps() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TrafficControlStatistics::set_has_ratebps() {
  _has_bits_[0] |= 0x00000080u;
}
void TrafficControlStatistics::clear_has_ratebps() {
  _has_bits_[0] &= ~0x00000080u;
}
void TrafficControlStatistics::clear_ratebps() {
  ratebps_ = GOOGLE_ULONGLONG(0);
  clear_has_ratebps();
}
 ::google::protobuf::uint64 TrafficControlStatistics::ratebps() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.ratebps)
  return ratebps_;
}
 void TrafficControlStatistics::set_ratebps(::google::protobuf::uint64 value) {
  set_has_ratebps();
  ratebps_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.ratebps)
}

// optional uint64 ratepps = 9;
bool TrafficControlStatistics::has_ratepps() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TrafficControlStatistics::set_has_ratepps() {
  _has_bits_[0] |= 0x00000100u;
}
void TrafficControlStatistics::clear_has_ratepps() {
  _has_bits_[0] &= ~0x00000100u;
}
void TrafficControlStatistics::clear_ratepps() {
  ratepps_ = GOOGLE_ULONGLONG(0);
  clear_has_ratepps();
}
 ::google::protobuf::uint64 TrafficControlStatistics::ratepps() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.ratepps)
  return ratepps_;
}
 void TrafficControlStatistics::set_ratepps(::google::protobuf::uint64 value) {
  set_has_ratepps();
  ratepps_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.ratepps)
}

// optional uint64 requeues = 10;
bool TrafficControlStatistics::has_requeues() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TrafficControlStatistics::set_has_requeues() {
  _has_bits_[0] |= 0x00000200u;
}
void TrafficControlStatistics::clear_has_requeues() {
  _has_bits_[0] &= ~0x00000200u;
}
void TrafficControlStatistics::clear_requeues() {
  requeues_ = GOOGLE_ULONGLONG(0);
  clear_has_requeues();
}
 ::google::protobuf::uint64 TrafficControlStatistics::requeues() const {
  // @@protoc_insertion_point(field_get:mesos.TrafficControlStatistics.requeues)
  return requeues_;
}
 void TrafficControlStatistics::set_requeues(::google::protobuf::uint64 value) {
  set_has_requeues();
  requeues_ = value;
  // @@protoc_insertion_point(field_set:mesos.TrafficControlStatistics.requeues)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IpStatistics::kForwardingFieldNumber;
const int IpStatistics::kDefaultTTLFieldNumber;
const int IpStatistics::kInReceivesFieldNumber;
const int IpStatistics::kInHdrErrorsFieldNumber;
const int IpStatistics::kInAddrErrorsFieldNumber;
const int IpStatistics::kForwDatagramsFieldNumber;
const int IpStatistics::kInUnknownProtosFieldNumber;
const int IpStatistics::kInDiscardsFieldNumber;
const int IpStatistics::kInDeliversFieldNumber;
const int IpStatistics::kOutRequestsFieldNumber;
const int IpStatistics::kOutDiscardsFieldNumber;
const int IpStatistics::kOutNoRoutesFieldNumber;
const int IpStatistics::kReasmTimeoutFieldNumber;
const int IpStatistics::kReasmReqdsFieldNumber;
const int IpStatistics::kReasmOKsFieldNumber;
const int IpStatistics::kReasmFailsFieldNumber;
const int IpStatistics::kFragOKsFieldNumber;
const int IpStatistics::kFragFailsFieldNumber;
const int IpStatistics::kFragCreatesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IpStatistics::IpStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.IpStatistics)
}

void IpStatistics::InitAsDefaultInstance() {
}

IpStatistics::IpStatistics(const IpStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.IpStatistics)
}

void IpStatistics::SharedCtor() {
  _cached_size_ = 0;
  forwarding_ = GOOGLE_LONGLONG(0);
  defaultttl_ = GOOGLE_LONGLONG(0);
  inreceives_ = GOOGLE_LONGLONG(0);
  inhdrerrors_ = GOOGLE_LONGLONG(0);
  inaddrerrors_ = GOOGLE_LONGLONG(0);
  forwdatagrams_ = GOOGLE_LONGLONG(0);
  inunknownprotos_ = GOOGLE_LONGLONG(0);
  indiscards_ = GOOGLE_LONGLONG(0);
  indelivers_ = GOOGLE_LONGLONG(0);
  outrequests_ = GOOGLE_LONGLONG(0);
  outdiscards_ = GOOGLE_LONGLONG(0);
  outnoroutes_ = GOOGLE_LONGLONG(0);
  reasmtimeout_ = GOOGLE_LONGLONG(0);
  reasmreqds_ = GOOGLE_LONGLONG(0);
  reasmoks_ = GOOGLE_LONGLONG(0);
  reasmfails_ = GOOGLE_LONGLONG(0);
  fragoks_ = GOOGLE_LONGLONG(0);
  fragfails_ = GOOGLE_LONGLONG(0);
  fragcreates_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IpStatistics::~IpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.IpStatistics)
  SharedDtor();
}

void IpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IpStatistics_descriptor_;
}

const IpStatistics& IpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

IpStatistics* IpStatistics::default_instance_ = NULL;

IpStatistics* IpStatistics::New(::google::protobuf::Arena* arena) const {
  IpStatistics* n = new IpStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IpStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.IpStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IpStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IpStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(forwarding_, indiscards_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(indelivers_, reasmfails_);
  }
  ZR_(fragoks_, fragcreates_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.IpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 Forwarding = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &forwarding_)));
          set_has_forwarding();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_DefaultTTL;
        break;
      }

      // optional int64 DefaultTTL = 2;
      case 2: {
        if (tag == 16) {
         parse_DefaultTTL:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &defaultttl_)));
          set_has_defaultttl();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_InReceives;
        break;
      }

      // optional int64 InReceives = 3;
      case 3: {
        if (tag == 24) {
         parse_InReceives:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inreceives_)));
          set_has_inreceives();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_InHdrErrors;
        break;
      }

      // optional int64 InHdrErrors = 4;
      case 4: {
        if (tag == 32) {
         parse_InHdrErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inhdrerrors_)));
          set_has_inhdrerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_InAddrErrors;
        break;
      }

      // optional int64 InAddrErrors = 5;
      case 5: {
        if (tag == 40) {
         parse_InAddrErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inaddrerrors_)));
          set_has_inaddrerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_ForwDatagrams;
        break;
      }

      // optional int64 ForwDatagrams = 6;
      case 6: {
        if (tag == 48) {
         parse_ForwDatagrams:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &forwdatagrams_)));
          set_has_forwdatagrams();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_InUnknownProtos;
        break;
      }

      // optional int64 InUnknownProtos = 7;
      case 7: {
        if (tag == 56) {
         parse_InUnknownProtos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inunknownprotos_)));
          set_has_inunknownprotos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_InDiscards;
        break;
      }

      // optional int64 InDiscards = 8;
      case 8: {
        if (tag == 64) {
         parse_InDiscards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indiscards_)));
          set_has_indiscards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_InDelivers;
        break;
      }

      // optional int64 InDelivers = 9;
      case 9: {
        if (tag == 72) {
         parse_InDelivers:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indelivers_)));
          set_has_indelivers();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_OutRequests;
        break;
      }

      // optional int64 OutRequests = 10;
      case 10: {
        if (tag == 80) {
         parse_OutRequests:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outrequests_)));
          set_has_outrequests();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_OutDiscards;
        break;
      }

      // optional int64 OutDiscards = 11;
      case 11: {
        if (tag == 88) {
         parse_OutDiscards:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outdiscards_)));
          set_has_outdiscards();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_OutNoRoutes;
        break;
      }

      // optional int64 OutNoRoutes = 12;
      case 12: {
        if (tag == 96) {
         parse_OutNoRoutes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outnoroutes_)));
          set_has_outnoroutes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_ReasmTimeout;
        break;
      }

      // optional int64 ReasmTimeout = 13;
      case 13: {
        if (tag == 104) {
         parse_ReasmTimeout:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmtimeout_)));
          set_has_reasmtimeout();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_ReasmReqds;
        break;
      }

      // optional int64 ReasmReqds = 14;
      case 14: {
        if (tag == 112) {
         parse_ReasmReqds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmreqds_)));
          set_has_reasmreqds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_ReasmOKs;
        break;
      }

      // optional int64 ReasmOKs = 15;
      case 15: {
        if (tag == 120) {
         parse_ReasmOKs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmoks_)));
          set_has_reasmoks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_ReasmFails;
        break;
      }

      // optional int64 ReasmFails = 16;
      case 16: {
        if (tag == 128) {
         parse_ReasmFails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &reasmfails_)));
          set_has_reasmfails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_FragOKs;
        break;
      }

      // optional int64 FragOKs = 17;
      case 17: {
        if (tag == 136) {
         parse_FragOKs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fragoks_)));
          set_has_fragoks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_FragFails;
        break;
      }

      // optional int64 FragFails = 18;
      case 18: {
        if (tag == 144) {
         parse_FragFails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fragfails_)));
          set_has_fragfails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_FragCreates;
        break;
      }

      // optional int64 FragCreates = 19;
      case 19: {
        if (tag == 152) {
         parse_FragCreates:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &fragcreates_)));
          set_has_fragcreates();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.IpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.IpStatistics)
  return false;
#undef DO_
}

void IpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.IpStatistics)
  // optional int64 Forwarding = 1;
  if (has_forwarding()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->forwarding(), output);
  }

  // optional int64 DefaultTTL = 2;
  if (has_defaultttl()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->defaultttl(), output);
  }

  // optional int64 InReceives = 3;
  if (has_inreceives()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->inreceives(), output);
  }

  // optional int64 InHdrErrors = 4;
  if (has_inhdrerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->inhdrerrors(), output);
  }

  // optional int64 InAddrErrors = 5;
  if (has_inaddrerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->inaddrerrors(), output);
  }

  // optional int64 ForwDatagrams = 6;
  if (has_forwdatagrams()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->forwdatagrams(), output);
  }

  // optional int64 InUnknownProtos = 7;
  if (has_inunknownprotos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->inunknownprotos(), output);
  }

  // optional int64 InDiscards = 8;
  if (has_indiscards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->indiscards(), output);
  }

  // optional int64 InDelivers = 9;
  if (has_indelivers()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->indelivers(), output);
  }

  // optional int64 OutRequests = 10;
  if (has_outrequests()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->outrequests(), output);
  }

  // optional int64 OutDiscards = 11;
  if (has_outdiscards()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->outdiscards(), output);
  }

  // optional int64 OutNoRoutes = 12;
  if (has_outnoroutes()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->outnoroutes(), output);
  }

  // optional int64 ReasmTimeout = 13;
  if (has_reasmtimeout()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->reasmtimeout(), output);
  }

  // optional int64 ReasmReqds = 14;
  if (has_reasmreqds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->reasmreqds(), output);
  }

  // optional int64 ReasmOKs = 15;
  if (has_reasmoks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(15, this->reasmoks(), output);
  }

  // optional int64 ReasmFails = 16;
  if (has_reasmfails()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(16, this->reasmfails(), output);
  }

  // optional int64 FragOKs = 17;
  if (has_fragoks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(17, this->fragoks(), output);
  }

  // optional int64 FragFails = 18;
  if (has_fragfails()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->fragfails(), output);
  }

  // optional int64 FragCreates = 19;
  if (has_fragcreates()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(19, this->fragcreates(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.IpStatistics)
}

::google::protobuf::uint8* IpStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.IpStatistics)
  // optional int64 Forwarding = 1;
  if (has_forwarding()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->forwarding(), target);
  }

  // optional int64 DefaultTTL = 2;
  if (has_defaultttl()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->defaultttl(), target);
  }

  // optional int64 InReceives = 3;
  if (has_inreceives()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->inreceives(), target);
  }

  // optional int64 InHdrErrors = 4;
  if (has_inhdrerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->inhdrerrors(), target);
  }

  // optional int64 InAddrErrors = 5;
  if (has_inaddrerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->inaddrerrors(), target);
  }

  // optional int64 ForwDatagrams = 6;
  if (has_forwdatagrams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->forwdatagrams(), target);
  }

  // optional int64 InUnknownProtos = 7;
  if (has_inunknownprotos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->inunknownprotos(), target);
  }

  // optional int64 InDiscards = 8;
  if (has_indiscards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->indiscards(), target);
  }

  // optional int64 InDelivers = 9;
  if (has_indelivers()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->indelivers(), target);
  }

  // optional int64 OutRequests = 10;
  if (has_outrequests()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->outrequests(), target);
  }

  // optional int64 OutDiscards = 11;
  if (has_outdiscards()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->outdiscards(), target);
  }

  // optional int64 OutNoRoutes = 12;
  if (has_outnoroutes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(12, this->outnoroutes(), target);
  }

  // optional int64 ReasmTimeout = 13;
  if (has_reasmtimeout()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->reasmtimeout(), target);
  }

  // optional int64 ReasmReqds = 14;
  if (has_reasmreqds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->reasmreqds(), target);
  }

  // optional int64 ReasmOKs = 15;
  if (has_reasmoks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(15, this->reasmoks(), target);
  }

  // optional int64 ReasmFails = 16;
  if (has_reasmfails()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(16, this->reasmfails(), target);
  }

  // optional int64 FragOKs = 17;
  if (has_fragoks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(17, this->fragoks(), target);
  }

  // optional int64 FragFails = 18;
  if (has_fragfails()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(18, this->fragfails(), target);
  }

  // optional int64 FragCreates = 19;
  if (has_fragcreates()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(19, this->fragcreates(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.IpStatistics)
  return target;
}

int IpStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.IpStatistics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int64 Forwarding = 1;
    if (has_forwarding()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->forwarding());
    }

    // optional int64 DefaultTTL = 2;
    if (has_defaultttl()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->defaultttl());
    }

    // optional int64 InReceives = 3;
    if (has_inreceives()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inreceives());
    }

    // optional int64 InHdrErrors = 4;
    if (has_inhdrerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inhdrerrors());
    }

    // optional int64 InAddrErrors = 5;
    if (has_inaddrerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inaddrerrors());
    }

    // optional int64 ForwDatagrams = 6;
    if (has_forwdatagrams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->forwdatagrams());
    }

    // optional int64 InUnknownProtos = 7;
    if (has_inunknownprotos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inunknownprotos());
    }

    // optional int64 InDiscards = 8;
    if (has_indiscards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indiscards());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional int64 InDelivers = 9;
    if (has_indelivers()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indelivers());
    }

    // optional int64 OutRequests = 10;
    if (has_outrequests()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outrequests());
    }

    // optional int64 OutDiscards = 11;
    if (has_outdiscards()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outdiscards());
    }

    // optional int64 OutNoRoutes = 12;
    if (has_outnoroutes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outnoroutes());
    }

    // optional int64 ReasmTimeout = 13;
    if (has_reasmtimeout()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmtimeout());
    }

    // optional int64 ReasmReqds = 14;
    if (has_reasmreqds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmreqds());
    }

    // optional int64 ReasmOKs = 15;
    if (has_reasmoks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmoks());
    }

    // optional int64 ReasmFails = 16;
    if (has_reasmfails()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->reasmfails());
    }

  }
  if (_has_bits_[16 / 32] & 458752u) {
    // optional int64 FragOKs = 17;
    if (has_fragoks()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fragoks());
    }

    // optional int64 FragFails = 18;
    if (has_fragfails()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fragfails());
    }

    // optional int64 FragCreates = 19;
    if (has_fragcreates()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->fragcreates());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.IpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const IpStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IpStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.IpStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.IpStatistics)
    MergeFrom(*source);
  }
}

void IpStatistics::MergeFrom(const IpStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.IpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_forwarding()) {
      set_forwarding(from.forwarding());
    }
    if (from.has_defaultttl()) {
      set_defaultttl(from.defaultttl());
    }
    if (from.has_inreceives()) {
      set_inreceives(from.inreceives());
    }
    if (from.has_inhdrerrors()) {
      set_inhdrerrors(from.inhdrerrors());
    }
    if (from.has_inaddrerrors()) {
      set_inaddrerrors(from.inaddrerrors());
    }
    if (from.has_forwdatagrams()) {
      set_forwdatagrams(from.forwdatagrams());
    }
    if (from.has_inunknownprotos()) {
      set_inunknownprotos(from.inunknownprotos());
    }
    if (from.has_indiscards()) {
      set_indiscards(from.indiscards());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_indelivers()) {
      set_indelivers(from.indelivers());
    }
    if (from.has_outrequests()) {
      set_outrequests(from.outrequests());
    }
    if (from.has_outdiscards()) {
      set_outdiscards(from.outdiscards());
    }
    if (from.has_outnoroutes()) {
      set_outnoroutes(from.outnoroutes());
    }
    if (from.has_reasmtimeout()) {
      set_reasmtimeout(from.reasmtimeout());
    }
    if (from.has_reasmreqds()) {
      set_reasmreqds(from.reasmreqds());
    }
    if (from.has_reasmoks()) {
      set_reasmoks(from.reasmoks());
    }
    if (from.has_reasmfails()) {
      set_reasmfails(from.reasmfails());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_fragoks()) {
      set_fragoks(from.fragoks());
    }
    if (from.has_fragfails()) {
      set_fragfails(from.fragfails());
    }
    if (from.has_fragcreates()) {
      set_fragcreates(from.fragcreates());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.IpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IpStatistics::CopyFrom(const IpStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.IpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IpStatistics::IsInitialized() const {

  return true;
}

void IpStatistics::Swap(IpStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IpStatistics::InternalSwap(IpStatistics* other) {
  std::swap(forwarding_, other->forwarding_);
  std::swap(defaultttl_, other->defaultttl_);
  std::swap(inreceives_, other->inreceives_);
  std::swap(inhdrerrors_, other->inhdrerrors_);
  std::swap(inaddrerrors_, other->inaddrerrors_);
  std::swap(forwdatagrams_, other->forwdatagrams_);
  std::swap(inunknownprotos_, other->inunknownprotos_);
  std::swap(indiscards_, other->indiscards_);
  std::swap(indelivers_, other->indelivers_);
  std::swap(outrequests_, other->outrequests_);
  std::swap(outdiscards_, other->outdiscards_);
  std::swap(outnoroutes_, other->outnoroutes_);
  std::swap(reasmtimeout_, other->reasmtimeout_);
  std::swap(reasmreqds_, other->reasmreqds_);
  std::swap(reasmoks_, other->reasmoks_);
  std::swap(reasmfails_, other->reasmfails_);
  std::swap(fragoks_, other->fragoks_);
  std::swap(fragfails_, other->fragfails_);
  std::swap(fragcreates_, other->fragcreates_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IpStatistics_descriptor_;
  metadata.reflection = IpStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IpStatistics

// optional int64 Forwarding = 1;
bool IpStatistics::has_forwarding() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IpStatistics::set_has_forwarding() {
  _has_bits_[0] |= 0x00000001u;
}
void IpStatistics::clear_has_forwarding() {
  _has_bits_[0] &= ~0x00000001u;
}
void IpStatistics::clear_forwarding() {
  forwarding_ = GOOGLE_LONGLONG(0);
  clear_has_forwarding();
}
 ::google::protobuf::int64 IpStatistics::forwarding() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.Forwarding)
  return forwarding_;
}
 void IpStatistics::set_forwarding(::google::protobuf::int64 value) {
  set_has_forwarding();
  forwarding_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.Forwarding)
}

// optional int64 DefaultTTL = 2;
bool IpStatistics::has_defaultttl() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IpStatistics::set_has_defaultttl() {
  _has_bits_[0] |= 0x00000002u;
}
void IpStatistics::clear_has_defaultttl() {
  _has_bits_[0] &= ~0x00000002u;
}
void IpStatistics::clear_defaultttl() {
  defaultttl_ = GOOGLE_LONGLONG(0);
  clear_has_defaultttl();
}
 ::google::protobuf::int64 IpStatistics::defaultttl() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.DefaultTTL)
  return defaultttl_;
}
 void IpStatistics::set_defaultttl(::google::protobuf::int64 value) {
  set_has_defaultttl();
  defaultttl_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.DefaultTTL)
}

// optional int64 InReceives = 3;
bool IpStatistics::has_inreceives() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IpStatistics::set_has_inreceives() {
  _has_bits_[0] |= 0x00000004u;
}
void IpStatistics::clear_has_inreceives() {
  _has_bits_[0] &= ~0x00000004u;
}
void IpStatistics::clear_inreceives() {
  inreceives_ = GOOGLE_LONGLONG(0);
  clear_has_inreceives();
}
 ::google::protobuf::int64 IpStatistics::inreceives() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InReceives)
  return inreceives_;
}
 void IpStatistics::set_inreceives(::google::protobuf::int64 value) {
  set_has_inreceives();
  inreceives_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InReceives)
}

// optional int64 InHdrErrors = 4;
bool IpStatistics::has_inhdrerrors() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IpStatistics::set_has_inhdrerrors() {
  _has_bits_[0] |= 0x00000008u;
}
void IpStatistics::clear_has_inhdrerrors() {
  _has_bits_[0] &= ~0x00000008u;
}
void IpStatistics::clear_inhdrerrors() {
  inhdrerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inhdrerrors();
}
 ::google::protobuf::int64 IpStatistics::inhdrerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InHdrErrors)
  return inhdrerrors_;
}
 void IpStatistics::set_inhdrerrors(::google::protobuf::int64 value) {
  set_has_inhdrerrors();
  inhdrerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InHdrErrors)
}

// optional int64 InAddrErrors = 5;
bool IpStatistics::has_inaddrerrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void IpStatistics::set_has_inaddrerrors() {
  _has_bits_[0] |= 0x00000010u;
}
void IpStatistics::clear_has_inaddrerrors() {
  _has_bits_[0] &= ~0x00000010u;
}
void IpStatistics::clear_inaddrerrors() {
  inaddrerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrerrors();
}
 ::google::protobuf::int64 IpStatistics::inaddrerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InAddrErrors)
  return inaddrerrors_;
}
 void IpStatistics::set_inaddrerrors(::google::protobuf::int64 value) {
  set_has_inaddrerrors();
  inaddrerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InAddrErrors)
}

// optional int64 ForwDatagrams = 6;
bool IpStatistics::has_forwdatagrams() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void IpStatistics::set_has_forwdatagrams() {
  _has_bits_[0] |= 0x00000020u;
}
void IpStatistics::clear_has_forwdatagrams() {
  _has_bits_[0] &= ~0x00000020u;
}
void IpStatistics::clear_forwdatagrams() {
  forwdatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_forwdatagrams();
}
 ::google::protobuf::int64 IpStatistics::forwdatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ForwDatagrams)
  return forwdatagrams_;
}
 void IpStatistics::set_forwdatagrams(::google::protobuf::int64 value) {
  set_has_forwdatagrams();
  forwdatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ForwDatagrams)
}

// optional int64 InUnknownProtos = 7;
bool IpStatistics::has_inunknownprotos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void IpStatistics::set_has_inunknownprotos() {
  _has_bits_[0] |= 0x00000040u;
}
void IpStatistics::clear_has_inunknownprotos() {
  _has_bits_[0] &= ~0x00000040u;
}
void IpStatistics::clear_inunknownprotos() {
  inunknownprotos_ = GOOGLE_LONGLONG(0);
  clear_has_inunknownprotos();
}
 ::google::protobuf::int64 IpStatistics::inunknownprotos() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InUnknownProtos)
  return inunknownprotos_;
}
 void IpStatistics::set_inunknownprotos(::google::protobuf::int64 value) {
  set_has_inunknownprotos();
  inunknownprotos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InUnknownProtos)
}

// optional int64 InDiscards = 8;
bool IpStatistics::has_indiscards() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void IpStatistics::set_has_indiscards() {
  _has_bits_[0] |= 0x00000080u;
}
void IpStatistics::clear_has_indiscards() {
  _has_bits_[0] &= ~0x00000080u;
}
void IpStatistics::clear_indiscards() {
  indiscards_ = GOOGLE_LONGLONG(0);
  clear_has_indiscards();
}
 ::google::protobuf::int64 IpStatistics::indiscards() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InDiscards)
  return indiscards_;
}
 void IpStatistics::set_indiscards(::google::protobuf::int64 value) {
  set_has_indiscards();
  indiscards_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InDiscards)
}

// optional int64 InDelivers = 9;
bool IpStatistics::has_indelivers() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void IpStatistics::set_has_indelivers() {
  _has_bits_[0] |= 0x00000100u;
}
void IpStatistics::clear_has_indelivers() {
  _has_bits_[0] &= ~0x00000100u;
}
void IpStatistics::clear_indelivers() {
  indelivers_ = GOOGLE_LONGLONG(0);
  clear_has_indelivers();
}
 ::google::protobuf::int64 IpStatistics::indelivers() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.InDelivers)
  return indelivers_;
}
 void IpStatistics::set_indelivers(::google::protobuf::int64 value) {
  set_has_indelivers();
  indelivers_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.InDelivers)
}

// optional int64 OutRequests = 10;
bool IpStatistics::has_outrequests() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void IpStatistics::set_has_outrequests() {
  _has_bits_[0] |= 0x00000200u;
}
void IpStatistics::clear_has_outrequests() {
  _has_bits_[0] &= ~0x00000200u;
}
void IpStatistics::clear_outrequests() {
  outrequests_ = GOOGLE_LONGLONG(0);
  clear_has_outrequests();
}
 ::google::protobuf::int64 IpStatistics::outrequests() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutRequests)
  return outrequests_;
}
 void IpStatistics::set_outrequests(::google::protobuf::int64 value) {
  set_has_outrequests();
  outrequests_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutRequests)
}

// optional int64 OutDiscards = 11;
bool IpStatistics::has_outdiscards() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void IpStatistics::set_has_outdiscards() {
  _has_bits_[0] |= 0x00000400u;
}
void IpStatistics::clear_has_outdiscards() {
  _has_bits_[0] &= ~0x00000400u;
}
void IpStatistics::clear_outdiscards() {
  outdiscards_ = GOOGLE_LONGLONG(0);
  clear_has_outdiscards();
}
 ::google::protobuf::int64 IpStatistics::outdiscards() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutDiscards)
  return outdiscards_;
}
 void IpStatistics::set_outdiscards(::google::protobuf::int64 value) {
  set_has_outdiscards();
  outdiscards_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutDiscards)
}

// optional int64 OutNoRoutes = 12;
bool IpStatistics::has_outnoroutes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void IpStatistics::set_has_outnoroutes() {
  _has_bits_[0] |= 0x00000800u;
}
void IpStatistics::clear_has_outnoroutes() {
  _has_bits_[0] &= ~0x00000800u;
}
void IpStatistics::clear_outnoroutes() {
  outnoroutes_ = GOOGLE_LONGLONG(0);
  clear_has_outnoroutes();
}
 ::google::protobuf::int64 IpStatistics::outnoroutes() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.OutNoRoutes)
  return outnoroutes_;
}
 void IpStatistics::set_outnoroutes(::google::protobuf::int64 value) {
  set_has_outnoroutes();
  outnoroutes_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.OutNoRoutes)
}

// optional int64 ReasmTimeout = 13;
bool IpStatistics::has_reasmtimeout() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void IpStatistics::set_has_reasmtimeout() {
  _has_bits_[0] |= 0x00001000u;
}
void IpStatistics::clear_has_reasmtimeout() {
  _has_bits_[0] &= ~0x00001000u;
}
void IpStatistics::clear_reasmtimeout() {
  reasmtimeout_ = GOOGLE_LONGLONG(0);
  clear_has_reasmtimeout();
}
 ::google::protobuf::int64 IpStatistics::reasmtimeout() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmTimeout)
  return reasmtimeout_;
}
 void IpStatistics::set_reasmtimeout(::google::protobuf::int64 value) {
  set_has_reasmtimeout();
  reasmtimeout_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmTimeout)
}

// optional int64 ReasmReqds = 14;
bool IpStatistics::has_reasmreqds() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void IpStatistics::set_has_reasmreqds() {
  _has_bits_[0] |= 0x00002000u;
}
void IpStatistics::clear_has_reasmreqds() {
  _has_bits_[0] &= ~0x00002000u;
}
void IpStatistics::clear_reasmreqds() {
  reasmreqds_ = GOOGLE_LONGLONG(0);
  clear_has_reasmreqds();
}
 ::google::protobuf::int64 IpStatistics::reasmreqds() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmReqds)
  return reasmreqds_;
}
 void IpStatistics::set_reasmreqds(::google::protobuf::int64 value) {
  set_has_reasmreqds();
  reasmreqds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmReqds)
}

// optional int64 ReasmOKs = 15;
bool IpStatistics::has_reasmoks() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void IpStatistics::set_has_reasmoks() {
  _has_bits_[0] |= 0x00004000u;
}
void IpStatistics::clear_has_reasmoks() {
  _has_bits_[0] &= ~0x00004000u;
}
void IpStatistics::clear_reasmoks() {
  reasmoks_ = GOOGLE_LONGLONG(0);
  clear_has_reasmoks();
}
 ::google::protobuf::int64 IpStatistics::reasmoks() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmOKs)
  return reasmoks_;
}
 void IpStatistics::set_reasmoks(::google::protobuf::int64 value) {
  set_has_reasmoks();
  reasmoks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmOKs)
}

// optional int64 ReasmFails = 16;
bool IpStatistics::has_reasmfails() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void IpStatistics::set_has_reasmfails() {
  _has_bits_[0] |= 0x00008000u;
}
void IpStatistics::clear_has_reasmfails() {
  _has_bits_[0] &= ~0x00008000u;
}
void IpStatistics::clear_reasmfails() {
  reasmfails_ = GOOGLE_LONGLONG(0);
  clear_has_reasmfails();
}
 ::google::protobuf::int64 IpStatistics::reasmfails() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.ReasmFails)
  return reasmfails_;
}
 void IpStatistics::set_reasmfails(::google::protobuf::int64 value) {
  set_has_reasmfails();
  reasmfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.ReasmFails)
}

// optional int64 FragOKs = 17;
bool IpStatistics::has_fragoks() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void IpStatistics::set_has_fragoks() {
  _has_bits_[0] |= 0x00010000u;
}
void IpStatistics::clear_has_fragoks() {
  _has_bits_[0] &= ~0x00010000u;
}
void IpStatistics::clear_fragoks() {
  fragoks_ = GOOGLE_LONGLONG(0);
  clear_has_fragoks();
}
 ::google::protobuf::int64 IpStatistics::fragoks() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragOKs)
  return fragoks_;
}
 void IpStatistics::set_fragoks(::google::protobuf::int64 value) {
  set_has_fragoks();
  fragoks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragOKs)
}

// optional int64 FragFails = 18;
bool IpStatistics::has_fragfails() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void IpStatistics::set_has_fragfails() {
  _has_bits_[0] |= 0x00020000u;
}
void IpStatistics::clear_has_fragfails() {
  _has_bits_[0] &= ~0x00020000u;
}
void IpStatistics::clear_fragfails() {
  fragfails_ = GOOGLE_LONGLONG(0);
  clear_has_fragfails();
}
 ::google::protobuf::int64 IpStatistics::fragfails() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragFails)
  return fragfails_;
}
 void IpStatistics::set_fragfails(::google::protobuf::int64 value) {
  set_has_fragfails();
  fragfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragFails)
}

// optional int64 FragCreates = 19;
bool IpStatistics::has_fragcreates() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void IpStatistics::set_has_fragcreates() {
  _has_bits_[0] |= 0x00040000u;
}
void IpStatistics::clear_has_fragcreates() {
  _has_bits_[0] &= ~0x00040000u;
}
void IpStatistics::clear_fragcreates() {
  fragcreates_ = GOOGLE_LONGLONG(0);
  clear_has_fragcreates();
}
 ::google::protobuf::int64 IpStatistics::fragcreates() const {
  // @@protoc_insertion_point(field_get:mesos.IpStatistics.FragCreates)
  return fragcreates_;
}
 void IpStatistics::set_fragcreates(::google::protobuf::int64 value) {
  set_has_fragcreates();
  fragcreates_ = value;
  // @@protoc_insertion_point(field_set:mesos.IpStatistics.FragCreates)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int IcmpStatistics::kInMsgsFieldNumber;
const int IcmpStatistics::kInErrorsFieldNumber;
const int IcmpStatistics::kInCsumErrorsFieldNumber;
const int IcmpStatistics::kInDestUnreachsFieldNumber;
const int IcmpStatistics::kInTimeExcdsFieldNumber;
const int IcmpStatistics::kInParmProbsFieldNumber;
const int IcmpStatistics::kInSrcQuenchsFieldNumber;
const int IcmpStatistics::kInRedirectsFieldNumber;
const int IcmpStatistics::kInEchosFieldNumber;
const int IcmpStatistics::kInEchoRepsFieldNumber;
const int IcmpStatistics::kInTimestampsFieldNumber;
const int IcmpStatistics::kInTimestampRepsFieldNumber;
const int IcmpStatistics::kInAddrMasksFieldNumber;
const int IcmpStatistics::kInAddrMaskRepsFieldNumber;
const int IcmpStatistics::kOutMsgsFieldNumber;
const int IcmpStatistics::kOutErrorsFieldNumber;
const int IcmpStatistics::kOutDestUnreachsFieldNumber;
const int IcmpStatistics::kOutTimeExcdsFieldNumber;
const int IcmpStatistics::kOutParmProbsFieldNumber;
const int IcmpStatistics::kOutSrcQuenchsFieldNumber;
const int IcmpStatistics::kOutRedirectsFieldNumber;
const int IcmpStatistics::kOutEchosFieldNumber;
const int IcmpStatistics::kOutEchoRepsFieldNumber;
const int IcmpStatistics::kOutTimestampsFieldNumber;
const int IcmpStatistics::kOutTimestampRepsFieldNumber;
const int IcmpStatistics::kOutAddrMasksFieldNumber;
const int IcmpStatistics::kOutAddrMaskRepsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

IcmpStatistics::IcmpStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.IcmpStatistics)
}

void IcmpStatistics::InitAsDefaultInstance() {
}

IcmpStatistics::IcmpStatistics(const IcmpStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.IcmpStatistics)
}

void IcmpStatistics::SharedCtor() {
  _cached_size_ = 0;
  inmsgs_ = GOOGLE_LONGLONG(0);
  inerrors_ = GOOGLE_LONGLONG(0);
  incsumerrors_ = GOOGLE_LONGLONG(0);
  indestunreachs_ = GOOGLE_LONGLONG(0);
  intimeexcds_ = GOOGLE_LONGLONG(0);
  inparmprobs_ = GOOGLE_LONGLONG(0);
  insrcquenchs_ = GOOGLE_LONGLONG(0);
  inredirects_ = GOOGLE_LONGLONG(0);
  inechos_ = GOOGLE_LONGLONG(0);
  inechoreps_ = GOOGLE_LONGLONG(0);
  intimestamps_ = GOOGLE_LONGLONG(0);
  intimestampreps_ = GOOGLE_LONGLONG(0);
  inaddrmasks_ = GOOGLE_LONGLONG(0);
  inaddrmaskreps_ = GOOGLE_LONGLONG(0);
  outmsgs_ = GOOGLE_LONGLONG(0);
  outerrors_ = GOOGLE_LONGLONG(0);
  outdestunreachs_ = GOOGLE_LONGLONG(0);
  outtimeexcds_ = GOOGLE_LONGLONG(0);
  outparmprobs_ = GOOGLE_LONGLONG(0);
  outsrcquenchs_ = GOOGLE_LONGLONG(0);
  outredirects_ = GOOGLE_LONGLONG(0);
  outechos_ = GOOGLE_LONGLONG(0);
  outechoreps_ = GOOGLE_LONGLONG(0);
  outtimestamps_ = GOOGLE_LONGLONG(0);
  outtimestampreps_ = GOOGLE_LONGLONG(0);
  outaddrmasks_ = GOOGLE_LONGLONG(0);
  outaddrmaskreps_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

IcmpStatistics::~IcmpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.IcmpStatistics)
  SharedDtor();
}

void IcmpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void IcmpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* IcmpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return IcmpStatistics_descriptor_;
}

const IcmpStatistics& IcmpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

IcmpStatistics* IcmpStatistics::default_instance_ = NULL;

IcmpStatistics* IcmpStatistics::New(::google::protobuf::Arena* arena) const {
  IcmpStatistics* n = new IcmpStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void IcmpStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.IcmpStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(IcmpStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<IcmpStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(inmsgs_, inredirects_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(inechos_, outerrors_);
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    ZR_(outdestunreachs_, outtimestamps_);
  }
  ZR_(outtimestampreps_, outaddrmaskreps_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool IcmpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.IcmpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 InMsgs = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inmsgs_)));
          set_has_inmsgs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_InErrors;
        break;
      }

      // optional int64 InErrors = 2;
      case 2: {
        if (tag == 16) {
         parse_InErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inerrors_)));
          set_has_inerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_InCsumErrors;
        break;
      }

      // optional int64 InCsumErrors = 3;
      case 3: {
        if (tag == 24) {
         parse_InCsumErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &incsumerrors_)));
          set_has_incsumerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_InDestUnreachs;
        break;
      }

      // optional int64 InDestUnreachs = 4;
      case 4: {
        if (tag == 32) {
         parse_InDestUnreachs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indestunreachs_)));
          set_has_indestunreachs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_InTimeExcds;
        break;
      }

      // optional int64 InTimeExcds = 5;
      case 5: {
        if (tag == 40) {
         parse_InTimeExcds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &intimeexcds_)));
          set_has_intimeexcds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_InParmProbs;
        break;
      }

      // optional int64 InParmProbs = 6;
      case 6: {
        if (tag == 48) {
         parse_InParmProbs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inparmprobs_)));
          set_has_inparmprobs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_InSrcQuenchs;
        break;
      }

      // optional int64 InSrcQuenchs = 7;
      case 7: {
        if (tag == 56) {
         parse_InSrcQuenchs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &insrcquenchs_)));
          set_has_insrcquenchs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_InRedirects;
        break;
      }

      // optional int64 InRedirects = 8;
      case 8: {
        if (tag == 64) {
         parse_InRedirects:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inredirects_)));
          set_has_inredirects();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_InEchos;
        break;
      }

      // optional int64 InEchos = 9;
      case 9: {
        if (tag == 72) {
         parse_InEchos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inechos_)));
          set_has_inechos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_InEchoReps;
        break;
      }

      // optional int64 InEchoReps = 10;
      case 10: {
        if (tag == 80) {
         parse_InEchoReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inechoreps_)));
          set_has_inechoreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_InTimestamps;
        break;
      }

      // optional int64 InTimestamps = 11;
      case 11: {
        if (tag == 88) {
         parse_InTimestamps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &intimestamps_)));
          set_has_intimestamps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_InTimestampReps;
        break;
      }

      // optional int64 InTimestampReps = 12;
      case 12: {
        if (tag == 96) {
         parse_InTimestampReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &intimestampreps_)));
          set_has_intimestampreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_InAddrMasks;
        break;
      }

      // optional int64 InAddrMasks = 13;
      case 13: {
        if (tag == 104) {
         parse_InAddrMasks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inaddrmasks_)));
          set_has_inaddrmasks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_InAddrMaskReps;
        break;
      }

      // optional int64 InAddrMaskReps = 14;
      case 14: {
        if (tag == 112) {
         parse_InAddrMaskReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inaddrmaskreps_)));
          set_has_inaddrmaskreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_OutMsgs;
        break;
      }

      // optional int64 OutMsgs = 15;
      case 15: {
        if (tag == 120) {
         parse_OutMsgs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outmsgs_)));
          set_has_outmsgs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_OutErrors;
        break;
      }

      // optional int64 OutErrors = 16;
      case 16: {
        if (tag == 128) {
         parse_OutErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outerrors_)));
          set_has_outerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_OutDestUnreachs;
        break;
      }

      // optional int64 OutDestUnreachs = 17;
      case 17: {
        if (tag == 136) {
         parse_OutDestUnreachs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outdestunreachs_)));
          set_has_outdestunreachs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_OutTimeExcds;
        break;
      }

      // optional int64 OutTimeExcds = 18;
      case 18: {
        if (tag == 144) {
         parse_OutTimeExcds:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outtimeexcds_)));
          set_has_outtimeexcds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_OutParmProbs;
        break;
      }

      // optional int64 OutParmProbs = 19;
      case 19: {
        if (tag == 152) {
         parse_OutParmProbs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outparmprobs_)));
          set_has_outparmprobs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_OutSrcQuenchs;
        break;
      }

      // optional int64 OutSrcQuenchs = 20;
      case 20: {
        if (tag == 160) {
         parse_OutSrcQuenchs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outsrcquenchs_)));
          set_has_outsrcquenchs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_OutRedirects;
        break;
      }

      // optional int64 OutRedirects = 21;
      case 21: {
        if (tag == 168) {
         parse_OutRedirects:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outredirects_)));
          set_has_outredirects();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_OutEchos;
        break;
      }

      // optional int64 OutEchos = 22;
      case 22: {
        if (tag == 176) {
         parse_OutEchos:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outechos_)));
          set_has_outechos();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_OutEchoReps;
        break;
      }

      // optional int64 OutEchoReps = 23;
      case 23: {
        if (tag == 184) {
         parse_OutEchoReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outechoreps_)));
          set_has_outechoreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_OutTimestamps;
        break;
      }

      // optional int64 OutTimestamps = 24;
      case 24: {
        if (tag == 192) {
         parse_OutTimestamps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outtimestamps_)));
          set_has_outtimestamps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_OutTimestampReps;
        break;
      }

      // optional int64 OutTimestampReps = 25;
      case 25: {
        if (tag == 200) {
         parse_OutTimestampReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outtimestampreps_)));
          set_has_outtimestampreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_OutAddrMasks;
        break;
      }

      // optional int64 OutAddrMasks = 26;
      case 26: {
        if (tag == 208) {
         parse_OutAddrMasks:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outaddrmasks_)));
          set_has_outaddrmasks();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_OutAddrMaskReps;
        break;
      }

      // optional int64 OutAddrMaskReps = 27;
      case 27: {
        if (tag == 216) {
         parse_OutAddrMaskReps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outaddrmaskreps_)));
          set_has_outaddrmaskreps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.IcmpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.IcmpStatistics)
  return false;
#undef DO_
}

void IcmpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.IcmpStatistics)
  // optional int64 InMsgs = 1;
  if (has_inmsgs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->inmsgs(), output);
  }

  // optional int64 InErrors = 2;
  if (has_inerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->inerrors(), output);
  }

  // optional int64 InCsumErrors = 3;
  if (has_incsumerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->incsumerrors(), output);
  }

  // optional int64 InDestUnreachs = 4;
  if (has_indestunreachs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->indestunreachs(), output);
  }

  // optional int64 InTimeExcds = 5;
  if (has_intimeexcds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->intimeexcds(), output);
  }

  // optional int64 InParmProbs = 6;
  if (has_inparmprobs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->inparmprobs(), output);
  }

  // optional int64 InSrcQuenchs = 7;
  if (has_insrcquenchs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->insrcquenchs(), output);
  }

  // optional int64 InRedirects = 8;
  if (has_inredirects()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->inredirects(), output);
  }

  // optional int64 InEchos = 9;
  if (has_inechos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->inechos(), output);
  }

  // optional int64 InEchoReps = 10;
  if (has_inechoreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->inechoreps(), output);
  }

  // optional int64 InTimestamps = 11;
  if (has_intimestamps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->intimestamps(), output);
  }

  // optional int64 InTimestampReps = 12;
  if (has_intimestampreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->intimestampreps(), output);
  }

  // optional int64 InAddrMasks = 13;
  if (has_inaddrmasks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->inaddrmasks(), output);
  }

  // optional int64 InAddrMaskReps = 14;
  if (has_inaddrmaskreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->inaddrmaskreps(), output);
  }

  // optional int64 OutMsgs = 15;
  if (has_outmsgs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(15, this->outmsgs(), output);
  }

  // optional int64 OutErrors = 16;
  if (has_outerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(16, this->outerrors(), output);
  }

  // optional int64 OutDestUnreachs = 17;
  if (has_outdestunreachs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(17, this->outdestunreachs(), output);
  }

  // optional int64 OutTimeExcds = 18;
  if (has_outtimeexcds()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(18, this->outtimeexcds(), output);
  }

  // optional int64 OutParmProbs = 19;
  if (has_outparmprobs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(19, this->outparmprobs(), output);
  }

  // optional int64 OutSrcQuenchs = 20;
  if (has_outsrcquenchs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(20, this->outsrcquenchs(), output);
  }

  // optional int64 OutRedirects = 21;
  if (has_outredirects()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(21, this->outredirects(), output);
  }

  // optional int64 OutEchos = 22;
  if (has_outechos()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(22, this->outechos(), output);
  }

  // optional int64 OutEchoReps = 23;
  if (has_outechoreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(23, this->outechoreps(), output);
  }

  // optional int64 OutTimestamps = 24;
  if (has_outtimestamps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(24, this->outtimestamps(), output);
  }

  // optional int64 OutTimestampReps = 25;
  if (has_outtimestampreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(25, this->outtimestampreps(), output);
  }

  // optional int64 OutAddrMasks = 26;
  if (has_outaddrmasks()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(26, this->outaddrmasks(), output);
  }

  // optional int64 OutAddrMaskReps = 27;
  if (has_outaddrmaskreps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(27, this->outaddrmaskreps(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.IcmpStatistics)
}

::google::protobuf::uint8* IcmpStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.IcmpStatistics)
  // optional int64 InMsgs = 1;
  if (has_inmsgs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->inmsgs(), target);
  }

  // optional int64 InErrors = 2;
  if (has_inerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->inerrors(), target);
  }

  // optional int64 InCsumErrors = 3;
  if (has_incsumerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->incsumerrors(), target);
  }

  // optional int64 InDestUnreachs = 4;
  if (has_indestunreachs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->indestunreachs(), target);
  }

  // optional int64 InTimeExcds = 5;
  if (has_intimeexcds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->intimeexcds(), target);
  }

  // optional int64 InParmProbs = 6;
  if (has_inparmprobs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->inparmprobs(), target);
  }

  // optional int64 InSrcQuenchs = 7;
  if (has_insrcquenchs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->insrcquenchs(), target);
  }

  // optional int64 InRedirects = 8;
  if (has_inredirects()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->inredirects(), target);
  }

  // optional int64 InEchos = 9;
  if (has_inechos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->inechos(), target);
  }

  // optional int64 InEchoReps = 10;
  if (has_inechoreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->inechoreps(), target);
  }

  // optional int64 InTimestamps = 11;
  if (has_intimestamps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->intimestamps(), target);
  }

  // optional int64 InTimestampReps = 12;
  if (has_intimestampreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(12, this->intimestampreps(), target);
  }

  // optional int64 InAddrMasks = 13;
  if (has_inaddrmasks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->inaddrmasks(), target);
  }

  // optional int64 InAddrMaskReps = 14;
  if (has_inaddrmaskreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->inaddrmaskreps(), target);
  }

  // optional int64 OutMsgs = 15;
  if (has_outmsgs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(15, this->outmsgs(), target);
  }

  // optional int64 OutErrors = 16;
  if (has_outerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(16, this->outerrors(), target);
  }

  // optional int64 OutDestUnreachs = 17;
  if (has_outdestunreachs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(17, this->outdestunreachs(), target);
  }

  // optional int64 OutTimeExcds = 18;
  if (has_outtimeexcds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(18, this->outtimeexcds(), target);
  }

  // optional int64 OutParmProbs = 19;
  if (has_outparmprobs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(19, this->outparmprobs(), target);
  }

  // optional int64 OutSrcQuenchs = 20;
  if (has_outsrcquenchs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(20, this->outsrcquenchs(), target);
  }

  // optional int64 OutRedirects = 21;
  if (has_outredirects()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(21, this->outredirects(), target);
  }

  // optional int64 OutEchos = 22;
  if (has_outechos()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(22, this->outechos(), target);
  }

  // optional int64 OutEchoReps = 23;
  if (has_outechoreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(23, this->outechoreps(), target);
  }

  // optional int64 OutTimestamps = 24;
  if (has_outtimestamps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(24, this->outtimestamps(), target);
  }

  // optional int64 OutTimestampReps = 25;
  if (has_outtimestampreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(25, this->outtimestampreps(), target);
  }

  // optional int64 OutAddrMasks = 26;
  if (has_outaddrmasks()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(26, this->outaddrmasks(), target);
  }

  // optional int64 OutAddrMaskReps = 27;
  if (has_outaddrmaskreps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(27, this->outaddrmaskreps(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.IcmpStatistics)
  return target;
}

int IcmpStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.IcmpStatistics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int64 InMsgs = 1;
    if (has_inmsgs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inmsgs());
    }

    // optional int64 InErrors = 2;
    if (has_inerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inerrors());
    }

    // optional int64 InCsumErrors = 3;
    if (has_incsumerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->incsumerrors());
    }

    // optional int64 InDestUnreachs = 4;
    if (has_indestunreachs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indestunreachs());
    }

    // optional int64 InTimeExcds = 5;
    if (has_intimeexcds()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->intimeexcds());
    }

    // optional int64 InParmProbs = 6;
    if (has_inparmprobs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inparmprobs());
    }

    // optional int64 InSrcQuenchs = 7;
    if (has_insrcquenchs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->insrcquenchs());
    }

    // optional int64 InRedirects = 8;
    if (has_inredirects()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inredirects());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional int64 InEchos = 9;
    if (has_inechos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inechos());
    }

    // optional int64 InEchoReps = 10;
    if (has_inechoreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inechoreps());
    }

    // optional int64 InTimestamps = 11;
    if (has_intimestamps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->intimestamps());
    }

    // optional int64 InTimestampReps = 12;
    if (has_intimestampreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->intimestampreps());
    }

    // optional int64 InAddrMasks = 13;
    if (has_inaddrmasks()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inaddrmasks());
    }

    // optional int64 InAddrMaskReps = 14;
    if (has_inaddrmaskreps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inaddrmaskreps());
    }

    // optional int64 OutMsgs = 15;
    if (has_outmsgs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outmsgs());
    }

    // optional int64 OutErrors = 16;
    if (has_outerrors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outerrors());
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional int64 OutDestUnreachs = 17;
    if (has_outdestunreachs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outdestunreachs());
    }

    // optional int64 OutTimeExcds = 18;
    if (has_outtimeexcds()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outtimeexcds());
    }

    // optional int64 OutParmProbs = 19;
    if (has_outparmprobs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outparmprobs());
    }

    // optional int64 OutSrcQuenchs = 20;
    if (has_outsrcquenchs()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outsrcquenchs());
    }

    // optional int64 OutRedirects = 21;
    if (has_outredirects()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outredirects());
    }

    // optional int64 OutEchos = 22;
    if (has_outechos()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outechos());
    }

    // optional int64 OutEchoReps = 23;
    if (has_outechoreps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outechoreps());
    }

    // optional int64 OutTimestamps = 24;
    if (has_outtimestamps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outtimestamps());
    }

  }
  if (_has_bits_[24 / 32] & 117440512u) {
    // optional int64 OutTimestampReps = 25;
    if (has_outtimestampreps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outtimestampreps());
    }

    // optional int64 OutAddrMasks = 26;
    if (has_outaddrmasks()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outaddrmasks());
    }

    // optional int64 OutAddrMaskReps = 27;
    if (has_outaddrmaskreps()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outaddrmaskreps());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void IcmpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.IcmpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const IcmpStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const IcmpStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.IcmpStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.IcmpStatistics)
    MergeFrom(*source);
  }
}

void IcmpStatistics::MergeFrom(const IcmpStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.IcmpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_inmsgs()) {
      set_inmsgs(from.inmsgs());
    }
    if (from.has_inerrors()) {
      set_inerrors(from.inerrors());
    }
    if (from.has_incsumerrors()) {
      set_incsumerrors(from.incsumerrors());
    }
    if (from.has_indestunreachs()) {
      set_indestunreachs(from.indestunreachs());
    }
    if (from.has_intimeexcds()) {
      set_intimeexcds(from.intimeexcds());
    }
    if (from.has_inparmprobs()) {
      set_inparmprobs(from.inparmprobs());
    }
    if (from.has_insrcquenchs()) {
      set_insrcquenchs(from.insrcquenchs());
    }
    if (from.has_inredirects()) {
      set_inredirects(from.inredirects());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_inechos()) {
      set_inechos(from.inechos());
    }
    if (from.has_inechoreps()) {
      set_inechoreps(from.inechoreps());
    }
    if (from.has_intimestamps()) {
      set_intimestamps(from.intimestamps());
    }
    if (from.has_intimestampreps()) {
      set_intimestampreps(from.intimestampreps());
    }
    if (from.has_inaddrmasks()) {
      set_inaddrmasks(from.inaddrmasks());
    }
    if (from.has_inaddrmaskreps()) {
      set_inaddrmaskreps(from.inaddrmaskreps());
    }
    if (from.has_outmsgs()) {
      set_outmsgs(from.outmsgs());
    }
    if (from.has_outerrors()) {
      set_outerrors(from.outerrors());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_outdestunreachs()) {
      set_outdestunreachs(from.outdestunreachs());
    }
    if (from.has_outtimeexcds()) {
      set_outtimeexcds(from.outtimeexcds());
    }
    if (from.has_outparmprobs()) {
      set_outparmprobs(from.outparmprobs());
    }
    if (from.has_outsrcquenchs()) {
      set_outsrcquenchs(from.outsrcquenchs());
    }
    if (from.has_outredirects()) {
      set_outredirects(from.outredirects());
    }
    if (from.has_outechos()) {
      set_outechos(from.outechos());
    }
    if (from.has_outechoreps()) {
      set_outechoreps(from.outechoreps());
    }
    if (from.has_outtimestamps()) {
      set_outtimestamps(from.outtimestamps());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_outtimestampreps()) {
      set_outtimestampreps(from.outtimestampreps());
    }
    if (from.has_outaddrmasks()) {
      set_outaddrmasks(from.outaddrmasks());
    }
    if (from.has_outaddrmaskreps()) {
      set_outaddrmaskreps(from.outaddrmaskreps());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void IcmpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.IcmpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IcmpStatistics::CopyFrom(const IcmpStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.IcmpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IcmpStatistics::IsInitialized() const {

  return true;
}

void IcmpStatistics::Swap(IcmpStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void IcmpStatistics::InternalSwap(IcmpStatistics* other) {
  std::swap(inmsgs_, other->inmsgs_);
  std::swap(inerrors_, other->inerrors_);
  std::swap(incsumerrors_, other->incsumerrors_);
  std::swap(indestunreachs_, other->indestunreachs_);
  std::swap(intimeexcds_, other->intimeexcds_);
  std::swap(inparmprobs_, other->inparmprobs_);
  std::swap(insrcquenchs_, other->insrcquenchs_);
  std::swap(inredirects_, other->inredirects_);
  std::swap(inechos_, other->inechos_);
  std::swap(inechoreps_, other->inechoreps_);
  std::swap(intimestamps_, other->intimestamps_);
  std::swap(intimestampreps_, other->intimestampreps_);
  std::swap(inaddrmasks_, other->inaddrmasks_);
  std::swap(inaddrmaskreps_, other->inaddrmaskreps_);
  std::swap(outmsgs_, other->outmsgs_);
  std::swap(outerrors_, other->outerrors_);
  std::swap(outdestunreachs_, other->outdestunreachs_);
  std::swap(outtimeexcds_, other->outtimeexcds_);
  std::swap(outparmprobs_, other->outparmprobs_);
  std::swap(outsrcquenchs_, other->outsrcquenchs_);
  std::swap(outredirects_, other->outredirects_);
  std::swap(outechos_, other->outechos_);
  std::swap(outechoreps_, other->outechoreps_);
  std::swap(outtimestamps_, other->outtimestamps_);
  std::swap(outtimestampreps_, other->outtimestampreps_);
  std::swap(outaddrmasks_, other->outaddrmasks_);
  std::swap(outaddrmaskreps_, other->outaddrmaskreps_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata IcmpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = IcmpStatistics_descriptor_;
  metadata.reflection = IcmpStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// IcmpStatistics

// optional int64 InMsgs = 1;
bool IcmpStatistics::has_inmsgs() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void IcmpStatistics::set_has_inmsgs() {
  _has_bits_[0] |= 0x00000001u;
}
void IcmpStatistics::clear_has_inmsgs() {
  _has_bits_[0] &= ~0x00000001u;
}
void IcmpStatistics::clear_inmsgs() {
  inmsgs_ = GOOGLE_LONGLONG(0);
  clear_has_inmsgs();
}
 ::google::protobuf::int64 IcmpStatistics::inmsgs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InMsgs)
  return inmsgs_;
}
 void IcmpStatistics::set_inmsgs(::google::protobuf::int64 value) {
  set_has_inmsgs();
  inmsgs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InMsgs)
}

// optional int64 InErrors = 2;
bool IcmpStatistics::has_inerrors() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void IcmpStatistics::set_has_inerrors() {
  _has_bits_[0] |= 0x00000002u;
}
void IcmpStatistics::clear_has_inerrors() {
  _has_bits_[0] &= ~0x00000002u;
}
void IcmpStatistics::clear_inerrors() {
  inerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inerrors();
}
 ::google::protobuf::int64 IcmpStatistics::inerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InErrors)
  return inerrors_;
}
 void IcmpStatistics::set_inerrors(::google::protobuf::int64 value) {
  set_has_inerrors();
  inerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InErrors)
}

// optional int64 InCsumErrors = 3;
bool IcmpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void IcmpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00000004u;
}
void IcmpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00000004u;
}
void IcmpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
 ::google::protobuf::int64 IcmpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InCsumErrors)
  return incsumerrors_;
}
 void IcmpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InCsumErrors)
}

// optional int64 InDestUnreachs = 4;
bool IcmpStatistics::has_indestunreachs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void IcmpStatistics::set_has_indestunreachs() {
  _has_bits_[0] |= 0x00000008u;
}
void IcmpStatistics::clear_has_indestunreachs() {
  _has_bits_[0] &= ~0x00000008u;
}
void IcmpStatistics::clear_indestunreachs() {
  indestunreachs_ = GOOGLE_LONGLONG(0);
  clear_has_indestunreachs();
}
 ::google::protobuf::int64 IcmpStatistics::indestunreachs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InDestUnreachs)
  return indestunreachs_;
}
 void IcmpStatistics::set_indestunreachs(::google::protobuf::int64 value) {
  set_has_indestunreachs();
  indestunreachs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InDestUnreachs)
}

// optional int64 InTimeExcds = 5;
bool IcmpStatistics::has_intimeexcds() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void IcmpStatistics::set_has_intimeexcds() {
  _has_bits_[0] |= 0x00000010u;
}
void IcmpStatistics::clear_has_intimeexcds() {
  _has_bits_[0] &= ~0x00000010u;
}
void IcmpStatistics::clear_intimeexcds() {
  intimeexcds_ = GOOGLE_LONGLONG(0);
  clear_has_intimeexcds();
}
 ::google::protobuf::int64 IcmpStatistics::intimeexcds() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimeExcds)
  return intimeexcds_;
}
 void IcmpStatistics::set_intimeexcds(::google::protobuf::int64 value) {
  set_has_intimeexcds();
  intimeexcds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimeExcds)
}

// optional int64 InParmProbs = 6;
bool IcmpStatistics::has_inparmprobs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void IcmpStatistics::set_has_inparmprobs() {
  _has_bits_[0] |= 0x00000020u;
}
void IcmpStatistics::clear_has_inparmprobs() {
  _has_bits_[0] &= ~0x00000020u;
}
void IcmpStatistics::clear_inparmprobs() {
  inparmprobs_ = GOOGLE_LONGLONG(0);
  clear_has_inparmprobs();
}
 ::google::protobuf::int64 IcmpStatistics::inparmprobs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InParmProbs)
  return inparmprobs_;
}
 void IcmpStatistics::set_inparmprobs(::google::protobuf::int64 value) {
  set_has_inparmprobs();
  inparmprobs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InParmProbs)
}

// optional int64 InSrcQuenchs = 7;
bool IcmpStatistics::has_insrcquenchs() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void IcmpStatistics::set_has_insrcquenchs() {
  _has_bits_[0] |= 0x00000040u;
}
void IcmpStatistics::clear_has_insrcquenchs() {
  _has_bits_[0] &= ~0x00000040u;
}
void IcmpStatistics::clear_insrcquenchs() {
  insrcquenchs_ = GOOGLE_LONGLONG(0);
  clear_has_insrcquenchs();
}
 ::google::protobuf::int64 IcmpStatistics::insrcquenchs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InSrcQuenchs)
  return insrcquenchs_;
}
 void IcmpStatistics::set_insrcquenchs(::google::protobuf::int64 value) {
  set_has_insrcquenchs();
  insrcquenchs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InSrcQuenchs)
}

// optional int64 InRedirects = 8;
bool IcmpStatistics::has_inredirects() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void IcmpStatistics::set_has_inredirects() {
  _has_bits_[0] |= 0x00000080u;
}
void IcmpStatistics::clear_has_inredirects() {
  _has_bits_[0] &= ~0x00000080u;
}
void IcmpStatistics::clear_inredirects() {
  inredirects_ = GOOGLE_LONGLONG(0);
  clear_has_inredirects();
}
 ::google::protobuf::int64 IcmpStatistics::inredirects() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InRedirects)
  return inredirects_;
}
 void IcmpStatistics::set_inredirects(::google::protobuf::int64 value) {
  set_has_inredirects();
  inredirects_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InRedirects)
}

// optional int64 InEchos = 9;
bool IcmpStatistics::has_inechos() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void IcmpStatistics::set_has_inechos() {
  _has_bits_[0] |= 0x00000100u;
}
void IcmpStatistics::clear_has_inechos() {
  _has_bits_[0] &= ~0x00000100u;
}
void IcmpStatistics::clear_inechos() {
  inechos_ = GOOGLE_LONGLONG(0);
  clear_has_inechos();
}
 ::google::protobuf::int64 IcmpStatistics::inechos() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InEchos)
  return inechos_;
}
 void IcmpStatistics::set_inechos(::google::protobuf::int64 value) {
  set_has_inechos();
  inechos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InEchos)
}

// optional int64 InEchoReps = 10;
bool IcmpStatistics::has_inechoreps() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void IcmpStatistics::set_has_inechoreps() {
  _has_bits_[0] |= 0x00000200u;
}
void IcmpStatistics::clear_has_inechoreps() {
  _has_bits_[0] &= ~0x00000200u;
}
void IcmpStatistics::clear_inechoreps() {
  inechoreps_ = GOOGLE_LONGLONG(0);
  clear_has_inechoreps();
}
 ::google::protobuf::int64 IcmpStatistics::inechoreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InEchoReps)
  return inechoreps_;
}
 void IcmpStatistics::set_inechoreps(::google::protobuf::int64 value) {
  set_has_inechoreps();
  inechoreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InEchoReps)
}

// optional int64 InTimestamps = 11;
bool IcmpStatistics::has_intimestamps() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void IcmpStatistics::set_has_intimestamps() {
  _has_bits_[0] |= 0x00000400u;
}
void IcmpStatistics::clear_has_intimestamps() {
  _has_bits_[0] &= ~0x00000400u;
}
void IcmpStatistics::clear_intimestamps() {
  intimestamps_ = GOOGLE_LONGLONG(0);
  clear_has_intimestamps();
}
 ::google::protobuf::int64 IcmpStatistics::intimestamps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimestamps)
  return intimestamps_;
}
 void IcmpStatistics::set_intimestamps(::google::protobuf::int64 value) {
  set_has_intimestamps();
  intimestamps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimestamps)
}

// optional int64 InTimestampReps = 12;
bool IcmpStatistics::has_intimestampreps() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void IcmpStatistics::set_has_intimestampreps() {
  _has_bits_[0] |= 0x00000800u;
}
void IcmpStatistics::clear_has_intimestampreps() {
  _has_bits_[0] &= ~0x00000800u;
}
void IcmpStatistics::clear_intimestampreps() {
  intimestampreps_ = GOOGLE_LONGLONG(0);
  clear_has_intimestampreps();
}
 ::google::protobuf::int64 IcmpStatistics::intimestampreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InTimestampReps)
  return intimestampreps_;
}
 void IcmpStatistics::set_intimestampreps(::google::protobuf::int64 value) {
  set_has_intimestampreps();
  intimestampreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InTimestampReps)
}

// optional int64 InAddrMasks = 13;
bool IcmpStatistics::has_inaddrmasks() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void IcmpStatistics::set_has_inaddrmasks() {
  _has_bits_[0] |= 0x00001000u;
}
void IcmpStatistics::clear_has_inaddrmasks() {
  _has_bits_[0] &= ~0x00001000u;
}
void IcmpStatistics::clear_inaddrmasks() {
  inaddrmasks_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrmasks();
}
 ::google::protobuf::int64 IcmpStatistics::inaddrmasks() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InAddrMasks)
  return inaddrmasks_;
}
 void IcmpStatistics::set_inaddrmasks(::google::protobuf::int64 value) {
  set_has_inaddrmasks();
  inaddrmasks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InAddrMasks)
}

// optional int64 InAddrMaskReps = 14;
bool IcmpStatistics::has_inaddrmaskreps() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void IcmpStatistics::set_has_inaddrmaskreps() {
  _has_bits_[0] |= 0x00002000u;
}
void IcmpStatistics::clear_has_inaddrmaskreps() {
  _has_bits_[0] &= ~0x00002000u;
}
void IcmpStatistics::clear_inaddrmaskreps() {
  inaddrmaskreps_ = GOOGLE_LONGLONG(0);
  clear_has_inaddrmaskreps();
}
 ::google::protobuf::int64 IcmpStatistics::inaddrmaskreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.InAddrMaskReps)
  return inaddrmaskreps_;
}
 void IcmpStatistics::set_inaddrmaskreps(::google::protobuf::int64 value) {
  set_has_inaddrmaskreps();
  inaddrmaskreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.InAddrMaskReps)
}

// optional int64 OutMsgs = 15;
bool IcmpStatistics::has_outmsgs() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void IcmpStatistics::set_has_outmsgs() {
  _has_bits_[0] |= 0x00004000u;
}
void IcmpStatistics::clear_has_outmsgs() {
  _has_bits_[0] &= ~0x00004000u;
}
void IcmpStatistics::clear_outmsgs() {
  outmsgs_ = GOOGLE_LONGLONG(0);
  clear_has_outmsgs();
}
 ::google::protobuf::int64 IcmpStatistics::outmsgs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutMsgs)
  return outmsgs_;
}
 void IcmpStatistics::set_outmsgs(::google::protobuf::int64 value) {
  set_has_outmsgs();
  outmsgs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutMsgs)
}

// optional int64 OutErrors = 16;
bool IcmpStatistics::has_outerrors() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void IcmpStatistics::set_has_outerrors() {
  _has_bits_[0] |= 0x00008000u;
}
void IcmpStatistics::clear_has_outerrors() {
  _has_bits_[0] &= ~0x00008000u;
}
void IcmpStatistics::clear_outerrors() {
  outerrors_ = GOOGLE_LONGLONG(0);
  clear_has_outerrors();
}
 ::google::protobuf::int64 IcmpStatistics::outerrors() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutErrors)
  return outerrors_;
}
 void IcmpStatistics::set_outerrors(::google::protobuf::int64 value) {
  set_has_outerrors();
  outerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutErrors)
}

// optional int64 OutDestUnreachs = 17;
bool IcmpStatistics::has_outdestunreachs() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void IcmpStatistics::set_has_outdestunreachs() {
  _has_bits_[0] |= 0x00010000u;
}
void IcmpStatistics::clear_has_outdestunreachs() {
  _has_bits_[0] &= ~0x00010000u;
}
void IcmpStatistics::clear_outdestunreachs() {
  outdestunreachs_ = GOOGLE_LONGLONG(0);
  clear_has_outdestunreachs();
}
 ::google::protobuf::int64 IcmpStatistics::outdestunreachs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutDestUnreachs)
  return outdestunreachs_;
}
 void IcmpStatistics::set_outdestunreachs(::google::protobuf::int64 value) {
  set_has_outdestunreachs();
  outdestunreachs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutDestUnreachs)
}

// optional int64 OutTimeExcds = 18;
bool IcmpStatistics::has_outtimeexcds() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void IcmpStatistics::set_has_outtimeexcds() {
  _has_bits_[0] |= 0x00020000u;
}
void IcmpStatistics::clear_has_outtimeexcds() {
  _has_bits_[0] &= ~0x00020000u;
}
void IcmpStatistics::clear_outtimeexcds() {
  outtimeexcds_ = GOOGLE_LONGLONG(0);
  clear_has_outtimeexcds();
}
 ::google::protobuf::int64 IcmpStatistics::outtimeexcds() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimeExcds)
  return outtimeexcds_;
}
 void IcmpStatistics::set_outtimeexcds(::google::protobuf::int64 value) {
  set_has_outtimeexcds();
  outtimeexcds_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimeExcds)
}

// optional int64 OutParmProbs = 19;
bool IcmpStatistics::has_outparmprobs() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void IcmpStatistics::set_has_outparmprobs() {
  _has_bits_[0] |= 0x00040000u;
}
void IcmpStatistics::clear_has_outparmprobs() {
  _has_bits_[0] &= ~0x00040000u;
}
void IcmpStatistics::clear_outparmprobs() {
  outparmprobs_ = GOOGLE_LONGLONG(0);
  clear_has_outparmprobs();
}
 ::google::protobuf::int64 IcmpStatistics::outparmprobs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutParmProbs)
  return outparmprobs_;
}
 void IcmpStatistics::set_outparmprobs(::google::protobuf::int64 value) {
  set_has_outparmprobs();
  outparmprobs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutParmProbs)
}

// optional int64 OutSrcQuenchs = 20;
bool IcmpStatistics::has_outsrcquenchs() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void IcmpStatistics::set_has_outsrcquenchs() {
  _has_bits_[0] |= 0x00080000u;
}
void IcmpStatistics::clear_has_outsrcquenchs() {
  _has_bits_[0] &= ~0x00080000u;
}
void IcmpStatistics::clear_outsrcquenchs() {
  outsrcquenchs_ = GOOGLE_LONGLONG(0);
  clear_has_outsrcquenchs();
}
 ::google::protobuf::int64 IcmpStatistics::outsrcquenchs() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutSrcQuenchs)
  return outsrcquenchs_;
}
 void IcmpStatistics::set_outsrcquenchs(::google::protobuf::int64 value) {
  set_has_outsrcquenchs();
  outsrcquenchs_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutSrcQuenchs)
}

// optional int64 OutRedirects = 21;
bool IcmpStatistics::has_outredirects() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void IcmpStatistics::set_has_outredirects() {
  _has_bits_[0] |= 0x00100000u;
}
void IcmpStatistics::clear_has_outredirects() {
  _has_bits_[0] &= ~0x00100000u;
}
void IcmpStatistics::clear_outredirects() {
  outredirects_ = GOOGLE_LONGLONG(0);
  clear_has_outredirects();
}
 ::google::protobuf::int64 IcmpStatistics::outredirects() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutRedirects)
  return outredirects_;
}
 void IcmpStatistics::set_outredirects(::google::protobuf::int64 value) {
  set_has_outredirects();
  outredirects_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutRedirects)
}

// optional int64 OutEchos = 22;
bool IcmpStatistics::has_outechos() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void IcmpStatistics::set_has_outechos() {
  _has_bits_[0] |= 0x00200000u;
}
void IcmpStatistics::clear_has_outechos() {
  _has_bits_[0] &= ~0x00200000u;
}
void IcmpStatistics::clear_outechos() {
  outechos_ = GOOGLE_LONGLONG(0);
  clear_has_outechos();
}
 ::google::protobuf::int64 IcmpStatistics::outechos() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutEchos)
  return outechos_;
}
 void IcmpStatistics::set_outechos(::google::protobuf::int64 value) {
  set_has_outechos();
  outechos_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutEchos)
}

// optional int64 OutEchoReps = 23;
bool IcmpStatistics::has_outechoreps() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void IcmpStatistics::set_has_outechoreps() {
  _has_bits_[0] |= 0x00400000u;
}
void IcmpStatistics::clear_has_outechoreps() {
  _has_bits_[0] &= ~0x00400000u;
}
void IcmpStatistics::clear_outechoreps() {
  outechoreps_ = GOOGLE_LONGLONG(0);
  clear_has_outechoreps();
}
 ::google::protobuf::int64 IcmpStatistics::outechoreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutEchoReps)
  return outechoreps_;
}
 void IcmpStatistics::set_outechoreps(::google::protobuf::int64 value) {
  set_has_outechoreps();
  outechoreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutEchoReps)
}

// optional int64 OutTimestamps = 24;
bool IcmpStatistics::has_outtimestamps() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void IcmpStatistics::set_has_outtimestamps() {
  _has_bits_[0] |= 0x00800000u;
}
void IcmpStatistics::clear_has_outtimestamps() {
  _has_bits_[0] &= ~0x00800000u;
}
void IcmpStatistics::clear_outtimestamps() {
  outtimestamps_ = GOOGLE_LONGLONG(0);
  clear_has_outtimestamps();
}
 ::google::protobuf::int64 IcmpStatistics::outtimestamps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimestamps)
  return outtimestamps_;
}
 void IcmpStatistics::set_outtimestamps(::google::protobuf::int64 value) {
  set_has_outtimestamps();
  outtimestamps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimestamps)
}

// optional int64 OutTimestampReps = 25;
bool IcmpStatistics::has_outtimestampreps() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void IcmpStatistics::set_has_outtimestampreps() {
  _has_bits_[0] |= 0x01000000u;
}
void IcmpStatistics::clear_has_outtimestampreps() {
  _has_bits_[0] &= ~0x01000000u;
}
void IcmpStatistics::clear_outtimestampreps() {
  outtimestampreps_ = GOOGLE_LONGLONG(0);
  clear_has_outtimestampreps();
}
 ::google::protobuf::int64 IcmpStatistics::outtimestampreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutTimestampReps)
  return outtimestampreps_;
}
 void IcmpStatistics::set_outtimestampreps(::google::protobuf::int64 value) {
  set_has_outtimestampreps();
  outtimestampreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutTimestampReps)
}

// optional int64 OutAddrMasks = 26;
bool IcmpStatistics::has_outaddrmasks() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void IcmpStatistics::set_has_outaddrmasks() {
  _has_bits_[0] |= 0x02000000u;
}
void IcmpStatistics::clear_has_outaddrmasks() {
  _has_bits_[0] &= ~0x02000000u;
}
void IcmpStatistics::clear_outaddrmasks() {
  outaddrmasks_ = GOOGLE_LONGLONG(0);
  clear_has_outaddrmasks();
}
 ::google::protobuf::int64 IcmpStatistics::outaddrmasks() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutAddrMasks)
  return outaddrmasks_;
}
 void IcmpStatistics::set_outaddrmasks(::google::protobuf::int64 value) {
  set_has_outaddrmasks();
  outaddrmasks_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutAddrMasks)
}

// optional int64 OutAddrMaskReps = 27;
bool IcmpStatistics::has_outaddrmaskreps() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void IcmpStatistics::set_has_outaddrmaskreps() {
  _has_bits_[0] |= 0x04000000u;
}
void IcmpStatistics::clear_has_outaddrmaskreps() {
  _has_bits_[0] &= ~0x04000000u;
}
void IcmpStatistics::clear_outaddrmaskreps() {
  outaddrmaskreps_ = GOOGLE_LONGLONG(0);
  clear_has_outaddrmaskreps();
}
 ::google::protobuf::int64 IcmpStatistics::outaddrmaskreps() const {
  // @@protoc_insertion_point(field_get:mesos.IcmpStatistics.OutAddrMaskReps)
  return outaddrmaskreps_;
}
 void IcmpStatistics::set_outaddrmaskreps(::google::protobuf::int64 value) {
  set_has_outaddrmaskreps();
  outaddrmaskreps_ = value;
  // @@protoc_insertion_point(field_set:mesos.IcmpStatistics.OutAddrMaskReps)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TcpStatistics::kRtoAlgorithmFieldNumber;
const int TcpStatistics::kRtoMinFieldNumber;
const int TcpStatistics::kRtoMaxFieldNumber;
const int TcpStatistics::kMaxConnFieldNumber;
const int TcpStatistics::kActiveOpensFieldNumber;
const int TcpStatistics::kPassiveOpensFieldNumber;
const int TcpStatistics::kAttemptFailsFieldNumber;
const int TcpStatistics::kEstabResetsFieldNumber;
const int TcpStatistics::kCurrEstabFieldNumber;
const int TcpStatistics::kInSegsFieldNumber;
const int TcpStatistics::kOutSegsFieldNumber;
const int TcpStatistics::kRetransSegsFieldNumber;
const int TcpStatistics::kInErrsFieldNumber;
const int TcpStatistics::kOutRstsFieldNumber;
const int TcpStatistics::kInCsumErrorsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TcpStatistics::TcpStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TcpStatistics)
}

void TcpStatistics::InitAsDefaultInstance() {
}

TcpStatistics::TcpStatistics(const TcpStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TcpStatistics)
}

void TcpStatistics::SharedCtor() {
  _cached_size_ = 0;
  rtoalgorithm_ = GOOGLE_LONGLONG(0);
  rtomin_ = GOOGLE_LONGLONG(0);
  rtomax_ = GOOGLE_LONGLONG(0);
  maxconn_ = GOOGLE_LONGLONG(0);
  activeopens_ = GOOGLE_LONGLONG(0);
  passiveopens_ = GOOGLE_LONGLONG(0);
  attemptfails_ = GOOGLE_LONGLONG(0);
  estabresets_ = GOOGLE_LONGLONG(0);
  currestab_ = GOOGLE_LONGLONG(0);
  insegs_ = GOOGLE_LONGLONG(0);
  outsegs_ = GOOGLE_LONGLONG(0);
  retranssegs_ = GOOGLE_LONGLONG(0);
  inerrs_ = GOOGLE_LONGLONG(0);
  outrsts_ = GOOGLE_LONGLONG(0);
  incsumerrors_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TcpStatistics::~TcpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.TcpStatistics)
  SharedDtor();
}

void TcpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TcpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TcpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TcpStatistics_descriptor_;
}

const TcpStatistics& TcpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TcpStatistics* TcpStatistics::default_instance_ = NULL;

TcpStatistics* TcpStatistics::New(::google::protobuf::Arena* arena) const {
  TcpStatistics* n = new TcpStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TcpStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TcpStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TcpStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TcpStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(rtoalgorithm_, estabresets_);
  }
  if (_has_bits_[8 / 32] & 32512u) {
    ZR_(currestab_, incsumerrors_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TcpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TcpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 RtoAlgorithm = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rtoalgorithm_)));
          set_has_rtoalgorithm();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_RtoMin;
        break;
      }

      // optional int64 RtoMin = 2;
      case 2: {
        if (tag == 16) {
         parse_RtoMin:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rtomin_)));
          set_has_rtomin();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_RtoMax;
        break;
      }

      // optional int64 RtoMax = 3;
      case 3: {
        if (tag == 24) {
         parse_RtoMax:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rtomax_)));
          set_has_rtomax();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_MaxConn;
        break;
      }

      // optional int64 MaxConn = 4;
      case 4: {
        if (tag == 32) {
         parse_MaxConn:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &maxconn_)));
          set_has_maxconn();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ActiveOpens;
        break;
      }

      // optional int64 ActiveOpens = 5;
      case 5: {
        if (tag == 40) {
         parse_ActiveOpens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &activeopens_)));
          set_has_activeopens();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_PassiveOpens;
        break;
      }

      // optional int64 PassiveOpens = 6;
      case 6: {
        if (tag == 48) {
         parse_PassiveOpens:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &passiveopens_)));
          set_has_passiveopens();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_AttemptFails;
        break;
      }

      // optional int64 AttemptFails = 7;
      case 7: {
        if (tag == 56) {
         parse_AttemptFails:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &attemptfails_)));
          set_has_attemptfails();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_EstabResets;
        break;
      }

      // optional int64 EstabResets = 8;
      case 8: {
        if (tag == 64) {
         parse_EstabResets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &estabresets_)));
          set_has_estabresets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_CurrEstab;
        break;
      }

      // optional int64 CurrEstab = 9;
      case 9: {
        if (tag == 72) {
         parse_CurrEstab:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &currestab_)));
          set_has_currestab();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_InSegs;
        break;
      }

      // optional int64 InSegs = 10;
      case 10: {
        if (tag == 80) {
         parse_InSegs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &insegs_)));
          set_has_insegs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_OutSegs;
        break;
      }

      // optional int64 OutSegs = 11;
      case 11: {
        if (tag == 88) {
         parse_OutSegs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outsegs_)));
          set_has_outsegs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_RetransSegs;
        break;
      }

      // optional int64 RetransSegs = 12;
      case 12: {
        if (tag == 96) {
         parse_RetransSegs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &retranssegs_)));
          set_has_retranssegs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(104)) goto parse_InErrs;
        break;
      }

      // optional int64 InErrs = 13;
      case 13: {
        if (tag == 104) {
         parse_InErrs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inerrs_)));
          set_has_inerrs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_OutRsts;
        break;
      }

      // optional int64 OutRsts = 14;
      case 14: {
        if (tag == 112) {
         parse_OutRsts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outrsts_)));
          set_has_outrsts();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_InCsumErrors;
        break;
      }

      // optional int64 InCsumErrors = 15;
      case 15: {
        if (tag == 120) {
         parse_InCsumErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &incsumerrors_)));
          set_has_incsumerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TcpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TcpStatistics)
  return false;
#undef DO_
}

void TcpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TcpStatistics)
  // optional int64 RtoAlgorithm = 1;
  if (has_rtoalgorithm()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->rtoalgorithm(), output);
  }

  // optional int64 RtoMin = 2;
  if (has_rtomin()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->rtomin(), output);
  }

  // optional int64 RtoMax = 3;
  if (has_rtomax()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->rtomax(), output);
  }

  // optional int64 MaxConn = 4;
  if (has_maxconn()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->maxconn(), output);
  }

  // optional int64 ActiveOpens = 5;
  if (has_activeopens()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->activeopens(), output);
  }

  // optional int64 PassiveOpens = 6;
  if (has_passiveopens()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->passiveopens(), output);
  }

  // optional int64 AttemptFails = 7;
  if (has_attemptfails()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->attemptfails(), output);
  }

  // optional int64 EstabResets = 8;
  if (has_estabresets()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->estabresets(), output);
  }

  // optional int64 CurrEstab = 9;
  if (has_currestab()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->currestab(), output);
  }

  // optional int64 InSegs = 10;
  if (has_insegs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(10, this->insegs(), output);
  }

  // optional int64 OutSegs = 11;
  if (has_outsegs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(11, this->outsegs(), output);
  }

  // optional int64 RetransSegs = 12;
  if (has_retranssegs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(12, this->retranssegs(), output);
  }

  // optional int64 InErrs = 13;
  if (has_inerrs()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(13, this->inerrs(), output);
  }

  // optional int64 OutRsts = 14;
  if (has_outrsts()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(14, this->outrsts(), output);
  }

  // optional int64 InCsumErrors = 15;
  if (has_incsumerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(15, this->incsumerrors(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TcpStatistics)
}

::google::protobuf::uint8* TcpStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TcpStatistics)
  // optional int64 RtoAlgorithm = 1;
  if (has_rtoalgorithm()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->rtoalgorithm(), target);
  }

  // optional int64 RtoMin = 2;
  if (has_rtomin()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->rtomin(), target);
  }

  // optional int64 RtoMax = 3;
  if (has_rtomax()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->rtomax(), target);
  }

  // optional int64 MaxConn = 4;
  if (has_maxconn()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->maxconn(), target);
  }

  // optional int64 ActiveOpens = 5;
  if (has_activeopens()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->activeopens(), target);
  }

  // optional int64 PassiveOpens = 6;
  if (has_passiveopens()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->passiveopens(), target);
  }

  // optional int64 AttemptFails = 7;
  if (has_attemptfails()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->attemptfails(), target);
  }

  // optional int64 EstabResets = 8;
  if (has_estabresets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->estabresets(), target);
  }

  // optional int64 CurrEstab = 9;
  if (has_currestab()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->currestab(), target);
  }

  // optional int64 InSegs = 10;
  if (has_insegs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(10, this->insegs(), target);
  }

  // optional int64 OutSegs = 11;
  if (has_outsegs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(11, this->outsegs(), target);
  }

  // optional int64 RetransSegs = 12;
  if (has_retranssegs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(12, this->retranssegs(), target);
  }

  // optional int64 InErrs = 13;
  if (has_inerrs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(13, this->inerrs(), target);
  }

  // optional int64 OutRsts = 14;
  if (has_outrsts()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(14, this->outrsts(), target);
  }

  // optional int64 InCsumErrors = 15;
  if (has_incsumerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(15, this->incsumerrors(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TcpStatistics)
  return target;
}

int TcpStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TcpStatistics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int64 RtoAlgorithm = 1;
    if (has_rtoalgorithm()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rtoalgorithm());
    }

    // optional int64 RtoMin = 2;
    if (has_rtomin()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rtomin());
    }

    // optional int64 RtoMax = 3;
    if (has_rtomax()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rtomax());
    }

    // optional int64 MaxConn = 4;
    if (has_maxconn()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->maxconn());
    }

    // optional int64 ActiveOpens = 5;
    if (has_activeopens()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->activeopens());
    }

    // optional int64 PassiveOpens = 6;
    if (has_passiveopens()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->passiveopens());
    }

    // optional int64 AttemptFails = 7;
    if (has_attemptfails()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->attemptfails());
    }

    // optional int64 EstabResets = 8;
    if (has_estabresets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->estabresets());
    }

  }
  if (_has_bits_[8 / 32] & 32512u) {
    // optional int64 CurrEstab = 9;
    if (has_currestab()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->currestab());
    }

    // optional int64 InSegs = 10;
    if (has_insegs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->insegs());
    }

    // optional int64 OutSegs = 11;
    if (has_outsegs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outsegs());
    }

    // optional int64 RetransSegs = 12;
    if (has_retranssegs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->retranssegs());
    }

    // optional int64 InErrs = 13;
    if (has_inerrs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inerrs());
    }

    // optional int64 OutRsts = 14;
    if (has_outrsts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outrsts());
    }

    // optional int64 InCsumErrors = 15;
    if (has_incsumerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->incsumerrors());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TcpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TcpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TcpStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TcpStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TcpStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TcpStatistics)
    MergeFrom(*source);
  }
}

void TcpStatistics::MergeFrom(const TcpStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TcpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rtoalgorithm()) {
      set_rtoalgorithm(from.rtoalgorithm());
    }
    if (from.has_rtomin()) {
      set_rtomin(from.rtomin());
    }
    if (from.has_rtomax()) {
      set_rtomax(from.rtomax());
    }
    if (from.has_maxconn()) {
      set_maxconn(from.maxconn());
    }
    if (from.has_activeopens()) {
      set_activeopens(from.activeopens());
    }
    if (from.has_passiveopens()) {
      set_passiveopens(from.passiveopens());
    }
    if (from.has_attemptfails()) {
      set_attemptfails(from.attemptfails());
    }
    if (from.has_estabresets()) {
      set_estabresets(from.estabresets());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_currestab()) {
      set_currestab(from.currestab());
    }
    if (from.has_insegs()) {
      set_insegs(from.insegs());
    }
    if (from.has_outsegs()) {
      set_outsegs(from.outsegs());
    }
    if (from.has_retranssegs()) {
      set_retranssegs(from.retranssegs());
    }
    if (from.has_inerrs()) {
      set_inerrs(from.inerrs());
    }
    if (from.has_outrsts()) {
      set_outrsts(from.outrsts());
    }
    if (from.has_incsumerrors()) {
      set_incsumerrors(from.incsumerrors());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TcpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TcpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TcpStatistics::CopyFrom(const TcpStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TcpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TcpStatistics::IsInitialized() const {

  return true;
}

void TcpStatistics::Swap(TcpStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TcpStatistics::InternalSwap(TcpStatistics* other) {
  std::swap(rtoalgorithm_, other->rtoalgorithm_);
  std::swap(rtomin_, other->rtomin_);
  std::swap(rtomax_, other->rtomax_);
  std::swap(maxconn_, other->maxconn_);
  std::swap(activeopens_, other->activeopens_);
  std::swap(passiveopens_, other->passiveopens_);
  std::swap(attemptfails_, other->attemptfails_);
  std::swap(estabresets_, other->estabresets_);
  std::swap(currestab_, other->currestab_);
  std::swap(insegs_, other->insegs_);
  std::swap(outsegs_, other->outsegs_);
  std::swap(retranssegs_, other->retranssegs_);
  std::swap(inerrs_, other->inerrs_);
  std::swap(outrsts_, other->outrsts_);
  std::swap(incsumerrors_, other->incsumerrors_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TcpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TcpStatistics_descriptor_;
  metadata.reflection = TcpStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TcpStatistics

// optional int64 RtoAlgorithm = 1;
bool TcpStatistics::has_rtoalgorithm() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TcpStatistics::set_has_rtoalgorithm() {
  _has_bits_[0] |= 0x00000001u;
}
void TcpStatistics::clear_has_rtoalgorithm() {
  _has_bits_[0] &= ~0x00000001u;
}
void TcpStatistics::clear_rtoalgorithm() {
  rtoalgorithm_ = GOOGLE_LONGLONG(0);
  clear_has_rtoalgorithm();
}
 ::google::protobuf::int64 TcpStatistics::rtoalgorithm() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoAlgorithm)
  return rtoalgorithm_;
}
 void TcpStatistics::set_rtoalgorithm(::google::protobuf::int64 value) {
  set_has_rtoalgorithm();
  rtoalgorithm_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoAlgorithm)
}

// optional int64 RtoMin = 2;
bool TcpStatistics::has_rtomin() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TcpStatistics::set_has_rtomin() {
  _has_bits_[0] |= 0x00000002u;
}
void TcpStatistics::clear_has_rtomin() {
  _has_bits_[0] &= ~0x00000002u;
}
void TcpStatistics::clear_rtomin() {
  rtomin_ = GOOGLE_LONGLONG(0);
  clear_has_rtomin();
}
 ::google::protobuf::int64 TcpStatistics::rtomin() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoMin)
  return rtomin_;
}
 void TcpStatistics::set_rtomin(::google::protobuf::int64 value) {
  set_has_rtomin();
  rtomin_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoMin)
}

// optional int64 RtoMax = 3;
bool TcpStatistics::has_rtomax() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TcpStatistics::set_has_rtomax() {
  _has_bits_[0] |= 0x00000004u;
}
void TcpStatistics::clear_has_rtomax() {
  _has_bits_[0] &= ~0x00000004u;
}
void TcpStatistics::clear_rtomax() {
  rtomax_ = GOOGLE_LONGLONG(0);
  clear_has_rtomax();
}
 ::google::protobuf::int64 TcpStatistics::rtomax() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RtoMax)
  return rtomax_;
}
 void TcpStatistics::set_rtomax(::google::protobuf::int64 value) {
  set_has_rtomax();
  rtomax_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RtoMax)
}

// optional int64 MaxConn = 4;
bool TcpStatistics::has_maxconn() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TcpStatistics::set_has_maxconn() {
  _has_bits_[0] |= 0x00000008u;
}
void TcpStatistics::clear_has_maxconn() {
  _has_bits_[0] &= ~0x00000008u;
}
void TcpStatistics::clear_maxconn() {
  maxconn_ = GOOGLE_LONGLONG(0);
  clear_has_maxconn();
}
 ::google::protobuf::int64 TcpStatistics::maxconn() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.MaxConn)
  return maxconn_;
}
 void TcpStatistics::set_maxconn(::google::protobuf::int64 value) {
  set_has_maxconn();
  maxconn_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.MaxConn)
}

// optional int64 ActiveOpens = 5;
bool TcpStatistics::has_activeopens() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TcpStatistics::set_has_activeopens() {
  _has_bits_[0] |= 0x00000010u;
}
void TcpStatistics::clear_has_activeopens() {
  _has_bits_[0] &= ~0x00000010u;
}
void TcpStatistics::clear_activeopens() {
  activeopens_ = GOOGLE_LONGLONG(0);
  clear_has_activeopens();
}
 ::google::protobuf::int64 TcpStatistics::activeopens() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.ActiveOpens)
  return activeopens_;
}
 void TcpStatistics::set_activeopens(::google::protobuf::int64 value) {
  set_has_activeopens();
  activeopens_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.ActiveOpens)
}

// optional int64 PassiveOpens = 6;
bool TcpStatistics::has_passiveopens() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TcpStatistics::set_has_passiveopens() {
  _has_bits_[0] |= 0x00000020u;
}
void TcpStatistics::clear_has_passiveopens() {
  _has_bits_[0] &= ~0x00000020u;
}
void TcpStatistics::clear_passiveopens() {
  passiveopens_ = GOOGLE_LONGLONG(0);
  clear_has_passiveopens();
}
 ::google::protobuf::int64 TcpStatistics::passiveopens() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.PassiveOpens)
  return passiveopens_;
}
 void TcpStatistics::set_passiveopens(::google::protobuf::int64 value) {
  set_has_passiveopens();
  passiveopens_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.PassiveOpens)
}

// optional int64 AttemptFails = 7;
bool TcpStatistics::has_attemptfails() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TcpStatistics::set_has_attemptfails() {
  _has_bits_[0] |= 0x00000040u;
}
void TcpStatistics::clear_has_attemptfails() {
  _has_bits_[0] &= ~0x00000040u;
}
void TcpStatistics::clear_attemptfails() {
  attemptfails_ = GOOGLE_LONGLONG(0);
  clear_has_attemptfails();
}
 ::google::protobuf::int64 TcpStatistics::attemptfails() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.AttemptFails)
  return attemptfails_;
}
 void TcpStatistics::set_attemptfails(::google::protobuf::int64 value) {
  set_has_attemptfails();
  attemptfails_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.AttemptFails)
}

// optional int64 EstabResets = 8;
bool TcpStatistics::has_estabresets() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TcpStatistics::set_has_estabresets() {
  _has_bits_[0] |= 0x00000080u;
}
void TcpStatistics::clear_has_estabresets() {
  _has_bits_[0] &= ~0x00000080u;
}
void TcpStatistics::clear_estabresets() {
  estabresets_ = GOOGLE_LONGLONG(0);
  clear_has_estabresets();
}
 ::google::protobuf::int64 TcpStatistics::estabresets() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.EstabResets)
  return estabresets_;
}
 void TcpStatistics::set_estabresets(::google::protobuf::int64 value) {
  set_has_estabresets();
  estabresets_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.EstabResets)
}

// optional int64 CurrEstab = 9;
bool TcpStatistics::has_currestab() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TcpStatistics::set_has_currestab() {
  _has_bits_[0] |= 0x00000100u;
}
void TcpStatistics::clear_has_currestab() {
  _has_bits_[0] &= ~0x00000100u;
}
void TcpStatistics::clear_currestab() {
  currestab_ = GOOGLE_LONGLONG(0);
  clear_has_currestab();
}
 ::google::protobuf::int64 TcpStatistics::currestab() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.CurrEstab)
  return currestab_;
}
 void TcpStatistics::set_currestab(::google::protobuf::int64 value) {
  set_has_currestab();
  currestab_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.CurrEstab)
}

// optional int64 InSegs = 10;
bool TcpStatistics::has_insegs() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TcpStatistics::set_has_insegs() {
  _has_bits_[0] |= 0x00000200u;
}
void TcpStatistics::clear_has_insegs() {
  _has_bits_[0] &= ~0x00000200u;
}
void TcpStatistics::clear_insegs() {
  insegs_ = GOOGLE_LONGLONG(0);
  clear_has_insegs();
}
 ::google::protobuf::int64 TcpStatistics::insegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InSegs)
  return insegs_;
}
 void TcpStatistics::set_insegs(::google::protobuf::int64 value) {
  set_has_insegs();
  insegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InSegs)
}

// optional int64 OutSegs = 11;
bool TcpStatistics::has_outsegs() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void TcpStatistics::set_has_outsegs() {
  _has_bits_[0] |= 0x00000400u;
}
void TcpStatistics::clear_has_outsegs() {
  _has_bits_[0] &= ~0x00000400u;
}
void TcpStatistics::clear_outsegs() {
  outsegs_ = GOOGLE_LONGLONG(0);
  clear_has_outsegs();
}
 ::google::protobuf::int64 TcpStatistics::outsegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.OutSegs)
  return outsegs_;
}
 void TcpStatistics::set_outsegs(::google::protobuf::int64 value) {
  set_has_outsegs();
  outsegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.OutSegs)
}

// optional int64 RetransSegs = 12;
bool TcpStatistics::has_retranssegs() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void TcpStatistics::set_has_retranssegs() {
  _has_bits_[0] |= 0x00000800u;
}
void TcpStatistics::clear_has_retranssegs() {
  _has_bits_[0] &= ~0x00000800u;
}
void TcpStatistics::clear_retranssegs() {
  retranssegs_ = GOOGLE_LONGLONG(0);
  clear_has_retranssegs();
}
 ::google::protobuf::int64 TcpStatistics::retranssegs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.RetransSegs)
  return retranssegs_;
}
 void TcpStatistics::set_retranssegs(::google::protobuf::int64 value) {
  set_has_retranssegs();
  retranssegs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.RetransSegs)
}

// optional int64 InErrs = 13;
bool TcpStatistics::has_inerrs() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void TcpStatistics::set_has_inerrs() {
  _has_bits_[0] |= 0x00001000u;
}
void TcpStatistics::clear_has_inerrs() {
  _has_bits_[0] &= ~0x00001000u;
}
void TcpStatistics::clear_inerrs() {
  inerrs_ = GOOGLE_LONGLONG(0);
  clear_has_inerrs();
}
 ::google::protobuf::int64 TcpStatistics::inerrs() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InErrs)
  return inerrs_;
}
 void TcpStatistics::set_inerrs(::google::protobuf::int64 value) {
  set_has_inerrs();
  inerrs_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InErrs)
}

// optional int64 OutRsts = 14;
bool TcpStatistics::has_outrsts() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void TcpStatistics::set_has_outrsts() {
  _has_bits_[0] |= 0x00002000u;
}
void TcpStatistics::clear_has_outrsts() {
  _has_bits_[0] &= ~0x00002000u;
}
void TcpStatistics::clear_outrsts() {
  outrsts_ = GOOGLE_LONGLONG(0);
  clear_has_outrsts();
}
 ::google::protobuf::int64 TcpStatistics::outrsts() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.OutRsts)
  return outrsts_;
}
 void TcpStatistics::set_outrsts(::google::protobuf::int64 value) {
  set_has_outrsts();
  outrsts_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.OutRsts)
}

// optional int64 InCsumErrors = 15;
bool TcpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void TcpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00004000u;
}
void TcpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00004000u;
}
void TcpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
 ::google::protobuf::int64 TcpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.TcpStatistics.InCsumErrors)
  return incsumerrors_;
}
 void TcpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.TcpStatistics.InCsumErrors)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int UdpStatistics::kInDatagramsFieldNumber;
const int UdpStatistics::kNoPortsFieldNumber;
const int UdpStatistics::kInErrorsFieldNumber;
const int UdpStatistics::kOutDatagramsFieldNumber;
const int UdpStatistics::kRcvbufErrorsFieldNumber;
const int UdpStatistics::kSndbufErrorsFieldNumber;
const int UdpStatistics::kInCsumErrorsFieldNumber;
const int UdpStatistics::kIgnoredMultiFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

UdpStatistics::UdpStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.UdpStatistics)
}

void UdpStatistics::InitAsDefaultInstance() {
}

UdpStatistics::UdpStatistics(const UdpStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.UdpStatistics)
}

void UdpStatistics::SharedCtor() {
  _cached_size_ = 0;
  indatagrams_ = GOOGLE_LONGLONG(0);
  noports_ = GOOGLE_LONGLONG(0);
  inerrors_ = GOOGLE_LONGLONG(0);
  outdatagrams_ = GOOGLE_LONGLONG(0);
  rcvbuferrors_ = GOOGLE_LONGLONG(0);
  sndbuferrors_ = GOOGLE_LONGLONG(0);
  incsumerrors_ = GOOGLE_LONGLONG(0);
  ignoredmulti_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

UdpStatistics::~UdpStatistics() {
  // @@protoc_insertion_point(destructor:mesos.UdpStatistics)
  SharedDtor();
}

void UdpStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void UdpStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* UdpStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return UdpStatistics_descriptor_;
}

const UdpStatistics& UdpStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

UdpStatistics* UdpStatistics::default_instance_ = NULL;

UdpStatistics* UdpStatistics::New(::google::protobuf::Arena* arena) const {
  UdpStatistics* n = new UdpStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void UdpStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.UdpStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(UdpStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<UdpStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(indatagrams_, ignoredmulti_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool UdpStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.UdpStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 InDatagrams = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &indatagrams_)));
          set_has_indatagrams();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_NoPorts;
        break;
      }

      // optional int64 NoPorts = 2;
      case 2: {
        if (tag == 16) {
         parse_NoPorts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &noports_)));
          set_has_noports();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_InErrors;
        break;
      }

      // optional int64 InErrors = 3;
      case 3: {
        if (tag == 24) {
         parse_InErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &inerrors_)));
          set_has_inerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_OutDatagrams;
        break;
      }

      // optional int64 OutDatagrams = 4;
      case 4: {
        if (tag == 32) {
         parse_OutDatagrams:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &outdatagrams_)));
          set_has_outdatagrams();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_RcvbufErrors;
        break;
      }

      // optional int64 RcvbufErrors = 5;
      case 5: {
        if (tag == 40) {
         parse_RcvbufErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &rcvbuferrors_)));
          set_has_rcvbuferrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_SndbufErrors;
        break;
      }

      // optional int64 SndbufErrors = 6;
      case 6: {
        if (tag == 48) {
         parse_SndbufErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &sndbuferrors_)));
          set_has_sndbuferrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_InCsumErrors;
        break;
      }

      // optional int64 InCsumErrors = 7;
      case 7: {
        if (tag == 56) {
         parse_InCsumErrors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &incsumerrors_)));
          set_has_incsumerrors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_IgnoredMulti;
        break;
      }

      // optional int64 IgnoredMulti = 8;
      case 8: {
        if (tag == 64) {
         parse_IgnoredMulti:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &ignoredmulti_)));
          set_has_ignoredmulti();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.UdpStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.UdpStatistics)
  return false;
#undef DO_
}

void UdpStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.UdpStatistics)
  // optional int64 InDatagrams = 1;
  if (has_indatagrams()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->indatagrams(), output);
  }

  // optional int64 NoPorts = 2;
  if (has_noports()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(2, this->noports(), output);
  }

  // optional int64 InErrors = 3;
  if (has_inerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->inerrors(), output);
  }

  // optional int64 OutDatagrams = 4;
  if (has_outdatagrams()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(4, this->outdatagrams(), output);
  }

  // optional int64 RcvbufErrors = 5;
  if (has_rcvbuferrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->rcvbuferrors(), output);
  }

  // optional int64 SndbufErrors = 6;
  if (has_sndbuferrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(6, this->sndbuferrors(), output);
  }

  // optional int64 InCsumErrors = 7;
  if (has_incsumerrors()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(7, this->incsumerrors(), output);
  }

  // optional int64 IgnoredMulti = 8;
  if (has_ignoredmulti()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->ignoredmulti(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.UdpStatistics)
}

::google::protobuf::uint8* UdpStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.UdpStatistics)
  // optional int64 InDatagrams = 1;
  if (has_indatagrams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->indatagrams(), target);
  }

  // optional int64 NoPorts = 2;
  if (has_noports()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(2, this->noports(), target);
  }

  // optional int64 InErrors = 3;
  if (has_inerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->inerrors(), target);
  }

  // optional int64 OutDatagrams = 4;
  if (has_outdatagrams()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(4, this->outdatagrams(), target);
  }

  // optional int64 RcvbufErrors = 5;
  if (has_rcvbuferrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->rcvbuferrors(), target);
  }

  // optional int64 SndbufErrors = 6;
  if (has_sndbuferrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(6, this->sndbuferrors(), target);
  }

  // optional int64 InCsumErrors = 7;
  if (has_incsumerrors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(7, this->incsumerrors(), target);
  }

  // optional int64 IgnoredMulti = 8;
  if (has_ignoredmulti()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->ignoredmulti(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.UdpStatistics)
  return target;
}

int UdpStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.UdpStatistics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 255u) {
    // optional int64 InDatagrams = 1;
    if (has_indatagrams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->indatagrams());
    }

    // optional int64 NoPorts = 2;
    if (has_noports()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->noports());
    }

    // optional int64 InErrors = 3;
    if (has_inerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->inerrors());
    }

    // optional int64 OutDatagrams = 4;
    if (has_outdatagrams()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->outdatagrams());
    }

    // optional int64 RcvbufErrors = 5;
    if (has_rcvbuferrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->rcvbuferrors());
    }

    // optional int64 SndbufErrors = 6;
    if (has_sndbuferrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->sndbuferrors());
    }

    // optional int64 InCsumErrors = 7;
    if (has_incsumerrors()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->incsumerrors());
    }

    // optional int64 IgnoredMulti = 8;
    if (has_ignoredmulti()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->ignoredmulti());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void UdpStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.UdpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const UdpStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const UdpStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.UdpStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.UdpStatistics)
    MergeFrom(*source);
  }
}

void UdpStatistics::MergeFrom(const UdpStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.UdpStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_indatagrams()) {
      set_indatagrams(from.indatagrams());
    }
    if (from.has_noports()) {
      set_noports(from.noports());
    }
    if (from.has_inerrors()) {
      set_inerrors(from.inerrors());
    }
    if (from.has_outdatagrams()) {
      set_outdatagrams(from.outdatagrams());
    }
    if (from.has_rcvbuferrors()) {
      set_rcvbuferrors(from.rcvbuferrors());
    }
    if (from.has_sndbuferrors()) {
      set_sndbuferrors(from.sndbuferrors());
    }
    if (from.has_incsumerrors()) {
      set_incsumerrors(from.incsumerrors());
    }
    if (from.has_ignoredmulti()) {
      set_ignoredmulti(from.ignoredmulti());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void UdpStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.UdpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void UdpStatistics::CopyFrom(const UdpStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.UdpStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool UdpStatistics::IsInitialized() const {

  return true;
}

void UdpStatistics::Swap(UdpStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void UdpStatistics::InternalSwap(UdpStatistics* other) {
  std::swap(indatagrams_, other->indatagrams_);
  std::swap(noports_, other->noports_);
  std::swap(inerrors_, other->inerrors_);
  std::swap(outdatagrams_, other->outdatagrams_);
  std::swap(rcvbuferrors_, other->rcvbuferrors_);
  std::swap(sndbuferrors_, other->sndbuferrors_);
  std::swap(incsumerrors_, other->incsumerrors_);
  std::swap(ignoredmulti_, other->ignoredmulti_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata UdpStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = UdpStatistics_descriptor_;
  metadata.reflection = UdpStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// UdpStatistics

// optional int64 InDatagrams = 1;
bool UdpStatistics::has_indatagrams() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void UdpStatistics::set_has_indatagrams() {
  _has_bits_[0] |= 0x00000001u;
}
void UdpStatistics::clear_has_indatagrams() {
  _has_bits_[0] &= ~0x00000001u;
}
void UdpStatistics::clear_indatagrams() {
  indatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_indatagrams();
}
 ::google::protobuf::int64 UdpStatistics::indatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InDatagrams)
  return indatagrams_;
}
 void UdpStatistics::set_indatagrams(::google::protobuf::int64 value) {
  set_has_indatagrams();
  indatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InDatagrams)
}

// optional int64 NoPorts = 2;
bool UdpStatistics::has_noports() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void UdpStatistics::set_has_noports() {
  _has_bits_[0] |= 0x00000002u;
}
void UdpStatistics::clear_has_noports() {
  _has_bits_[0] &= ~0x00000002u;
}
void UdpStatistics::clear_noports() {
  noports_ = GOOGLE_LONGLONG(0);
  clear_has_noports();
}
 ::google::protobuf::int64 UdpStatistics::noports() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.NoPorts)
  return noports_;
}
 void UdpStatistics::set_noports(::google::protobuf::int64 value) {
  set_has_noports();
  noports_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.NoPorts)
}

// optional int64 InErrors = 3;
bool UdpStatistics::has_inerrors() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void UdpStatistics::set_has_inerrors() {
  _has_bits_[0] |= 0x00000004u;
}
void UdpStatistics::clear_has_inerrors() {
  _has_bits_[0] &= ~0x00000004u;
}
void UdpStatistics::clear_inerrors() {
  inerrors_ = GOOGLE_LONGLONG(0);
  clear_has_inerrors();
}
 ::google::protobuf::int64 UdpStatistics::inerrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InErrors)
  return inerrors_;
}
 void UdpStatistics::set_inerrors(::google::protobuf::int64 value) {
  set_has_inerrors();
  inerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InErrors)
}

// optional int64 OutDatagrams = 4;
bool UdpStatistics::has_outdatagrams() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void UdpStatistics::set_has_outdatagrams() {
  _has_bits_[0] |= 0x00000008u;
}
void UdpStatistics::clear_has_outdatagrams() {
  _has_bits_[0] &= ~0x00000008u;
}
void UdpStatistics::clear_outdatagrams() {
  outdatagrams_ = GOOGLE_LONGLONG(0);
  clear_has_outdatagrams();
}
 ::google::protobuf::int64 UdpStatistics::outdatagrams() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.OutDatagrams)
  return outdatagrams_;
}
 void UdpStatistics::set_outdatagrams(::google::protobuf::int64 value) {
  set_has_outdatagrams();
  outdatagrams_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.OutDatagrams)
}

// optional int64 RcvbufErrors = 5;
bool UdpStatistics::has_rcvbuferrors() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void UdpStatistics::set_has_rcvbuferrors() {
  _has_bits_[0] |= 0x00000010u;
}
void UdpStatistics::clear_has_rcvbuferrors() {
  _has_bits_[0] &= ~0x00000010u;
}
void UdpStatistics::clear_rcvbuferrors() {
  rcvbuferrors_ = GOOGLE_LONGLONG(0);
  clear_has_rcvbuferrors();
}
 ::google::protobuf::int64 UdpStatistics::rcvbuferrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.RcvbufErrors)
  return rcvbuferrors_;
}
 void UdpStatistics::set_rcvbuferrors(::google::protobuf::int64 value) {
  set_has_rcvbuferrors();
  rcvbuferrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.RcvbufErrors)
}

// optional int64 SndbufErrors = 6;
bool UdpStatistics::has_sndbuferrors() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void UdpStatistics::set_has_sndbuferrors() {
  _has_bits_[0] |= 0x00000020u;
}
void UdpStatistics::clear_has_sndbuferrors() {
  _has_bits_[0] &= ~0x00000020u;
}
void UdpStatistics::clear_sndbuferrors() {
  sndbuferrors_ = GOOGLE_LONGLONG(0);
  clear_has_sndbuferrors();
}
 ::google::protobuf::int64 UdpStatistics::sndbuferrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.SndbufErrors)
  return sndbuferrors_;
}
 void UdpStatistics::set_sndbuferrors(::google::protobuf::int64 value) {
  set_has_sndbuferrors();
  sndbuferrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.SndbufErrors)
}

// optional int64 InCsumErrors = 7;
bool UdpStatistics::has_incsumerrors() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void UdpStatistics::set_has_incsumerrors() {
  _has_bits_[0] |= 0x00000040u;
}
void UdpStatistics::clear_has_incsumerrors() {
  _has_bits_[0] &= ~0x00000040u;
}
void UdpStatistics::clear_incsumerrors() {
  incsumerrors_ = GOOGLE_LONGLONG(0);
  clear_has_incsumerrors();
}
 ::google::protobuf::int64 UdpStatistics::incsumerrors() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.InCsumErrors)
  return incsumerrors_;
}
 void UdpStatistics::set_incsumerrors(::google::protobuf::int64 value) {
  set_has_incsumerrors();
  incsumerrors_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.InCsumErrors)
}

// optional int64 IgnoredMulti = 8;
bool UdpStatistics::has_ignoredmulti() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void UdpStatistics::set_has_ignoredmulti() {
  _has_bits_[0] |= 0x00000080u;
}
void UdpStatistics::clear_has_ignoredmulti() {
  _has_bits_[0] &= ~0x00000080u;
}
void UdpStatistics::clear_ignoredmulti() {
  ignoredmulti_ = GOOGLE_LONGLONG(0);
  clear_has_ignoredmulti();
}
 ::google::protobuf::int64 UdpStatistics::ignoredmulti() const {
  // @@protoc_insertion_point(field_get:mesos.UdpStatistics.IgnoredMulti)
  return ignoredmulti_;
}
 void UdpStatistics::set_ignoredmulti(::google::protobuf::int64 value) {
  set_has_ignoredmulti();
  ignoredmulti_ = value;
  // @@protoc_insertion_point(field_set:mesos.UdpStatistics.IgnoredMulti)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SNMPStatistics::kIpStatsFieldNumber;
const int SNMPStatistics::kIcmpStatsFieldNumber;
const int SNMPStatistics::kTcpStatsFieldNumber;
const int SNMPStatistics::kUdpStatsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SNMPStatistics::SNMPStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.SNMPStatistics)
}

void SNMPStatistics::InitAsDefaultInstance() {
  ip_stats_ = const_cast< ::mesos::IpStatistics*>(&::mesos::IpStatistics::default_instance());
  icmp_stats_ = const_cast< ::mesos::IcmpStatistics*>(&::mesos::IcmpStatistics::default_instance());
  tcp_stats_ = const_cast< ::mesos::TcpStatistics*>(&::mesos::TcpStatistics::default_instance());
  udp_stats_ = const_cast< ::mesos::UdpStatistics*>(&::mesos::UdpStatistics::default_instance());
}

SNMPStatistics::SNMPStatistics(const SNMPStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.SNMPStatistics)
}

void SNMPStatistics::SharedCtor() {
  _cached_size_ = 0;
  ip_stats_ = NULL;
  icmp_stats_ = NULL;
  tcp_stats_ = NULL;
  udp_stats_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SNMPStatistics::~SNMPStatistics() {
  // @@protoc_insertion_point(destructor:mesos.SNMPStatistics)
  SharedDtor();
}

void SNMPStatistics::SharedDtor() {
  if (this != default_instance_) {
    delete ip_stats_;
    delete icmp_stats_;
    delete tcp_stats_;
    delete udp_stats_;
  }
}

void SNMPStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SNMPStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SNMPStatistics_descriptor_;
}

const SNMPStatistics& SNMPStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

SNMPStatistics* SNMPStatistics::default_instance_ = NULL;

SNMPStatistics* SNMPStatistics::New(::google::protobuf::Arena* arena) const {
  SNMPStatistics* n = new SNMPStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SNMPStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.SNMPStatistics)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_ip_stats()) {
      if (ip_stats_ != NULL) ip_stats_->::mesos::IpStatistics::Clear();
    }
    if (has_icmp_stats()) {
      if (icmp_stats_ != NULL) icmp_stats_->::mesos::IcmpStatistics::Clear();
    }
    if (has_tcp_stats()) {
      if (tcp_stats_ != NULL) tcp_stats_->::mesos::TcpStatistics::Clear();
    }
    if (has_udp_stats()) {
      if (udp_stats_ != NULL) udp_stats_->::mesos::UdpStatistics::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool SNMPStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.SNMPStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.IpStatistics ip_stats = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ip_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_icmp_stats;
        break;
      }

      // optional .mesos.IcmpStatistics icmp_stats = 2;
      case 2: {
        if (tag == 18) {
         parse_icmp_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_icmp_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_tcp_stats;
        break;
      }

      // optional .mesos.TcpStatistics tcp_stats = 3;
      case 3: {
        if (tag == 26) {
         parse_tcp_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tcp_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_udp_stats;
        break;
      }

      // optional .mesos.UdpStatistics udp_stats = 4;
      case 4: {
        if (tag == 34) {
         parse_udp_stats:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_udp_stats()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.SNMPStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.SNMPStatistics)
  return false;
#undef DO_
}

void SNMPStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.SNMPStatistics)
  // optional .mesos.IpStatistics ip_stats = 1;
  if (has_ip_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->ip_stats_, output);
  }

  // optional .mesos.IcmpStatistics icmp_stats = 2;
  if (has_icmp_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->icmp_stats_, output);
  }

  // optional .mesos.TcpStatistics tcp_stats = 3;
  if (has_tcp_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->tcp_stats_, output);
  }

  // optional .mesos.UdpStatistics udp_stats = 4;
  if (has_udp_stats()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->udp_stats_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.SNMPStatistics)
}

::google::protobuf::uint8* SNMPStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.SNMPStatistics)
  // optional .mesos.IpStatistics ip_stats = 1;
  if (has_ip_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->ip_stats_, false, target);
  }

  // optional .mesos.IcmpStatistics icmp_stats = 2;
  if (has_icmp_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->icmp_stats_, false, target);
  }

  // optional .mesos.TcpStatistics tcp_stats = 3;
  if (has_tcp_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->tcp_stats_, false, target);
  }

  // optional .mesos.UdpStatistics udp_stats = 4;
  if (has_udp_stats()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->udp_stats_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.SNMPStatistics)
  return target;
}

int SNMPStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.SNMPStatistics)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 15u) {
    // optional .mesos.IpStatistics ip_stats = 1;
    if (has_ip_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ip_stats_);
    }

    // optional .mesos.IcmpStatistics icmp_stats = 2;
    if (has_icmp_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->icmp_stats_);
    }

    // optional .mesos.TcpStatistics tcp_stats = 3;
    if (has_tcp_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->tcp_stats_);
    }

    // optional .mesos.UdpStatistics udp_stats = 4;
    if (has_udp_stats()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->udp_stats_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SNMPStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.SNMPStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const SNMPStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const SNMPStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.SNMPStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.SNMPStatistics)
    MergeFrom(*source);
  }
}

void SNMPStatistics::MergeFrom(const SNMPStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.SNMPStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ip_stats()) {
      mutable_ip_stats()->::mesos::IpStatistics::MergeFrom(from.ip_stats());
    }
    if (from.has_icmp_stats()) {
      mutable_icmp_stats()->::mesos::IcmpStatistics::MergeFrom(from.icmp_stats());
    }
    if (from.has_tcp_stats()) {
      mutable_tcp_stats()->::mesos::TcpStatistics::MergeFrom(from.tcp_stats());
    }
    if (from.has_udp_stats()) {
      mutable_udp_stats()->::mesos::UdpStatistics::MergeFrom(from.udp_stats());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void SNMPStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.SNMPStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SNMPStatistics::CopyFrom(const SNMPStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.SNMPStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SNMPStatistics::IsInitialized() const {

  return true;
}

void SNMPStatistics::Swap(SNMPStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SNMPStatistics::InternalSwap(SNMPStatistics* other) {
  std::swap(ip_stats_, other->ip_stats_);
  std::swap(icmp_stats_, other->icmp_stats_);
  std::swap(tcp_stats_, other->tcp_stats_);
  std::swap(udp_stats_, other->udp_stats_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SNMPStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SNMPStatistics_descriptor_;
  metadata.reflection = SNMPStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SNMPStatistics

// optional .mesos.IpStatistics ip_stats = 1;
bool SNMPStatistics::has_ip_stats() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void SNMPStatistics::set_has_ip_stats() {
  _has_bits_[0] |= 0x00000001u;
}
void SNMPStatistics::clear_has_ip_stats() {
  _has_bits_[0] &= ~0x00000001u;
}
void SNMPStatistics::clear_ip_stats() {
  if (ip_stats_ != NULL) ip_stats_->::mesos::IpStatistics::Clear();
  clear_has_ip_stats();
}
const ::mesos::IpStatistics& SNMPStatistics::ip_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.ip_stats)
  return ip_stats_ != NULL ? *ip_stats_ : *default_instance_->ip_stats_;
}
::mesos::IpStatistics* SNMPStatistics::mutable_ip_stats() {
  set_has_ip_stats();
  if (ip_stats_ == NULL) {
    ip_stats_ = new ::mesos::IpStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.ip_stats)
  return ip_stats_;
}
::mesos::IpStatistics* SNMPStatistics::release_ip_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.ip_stats)
  clear_has_ip_stats();
  ::mesos::IpStatistics* temp = ip_stats_;
  ip_stats_ = NULL;
  return temp;
}
void SNMPStatistics::set_allocated_ip_stats(::mesos::IpStatistics* ip_stats) {
  delete ip_stats_;
  ip_stats_ = ip_stats;
  if (ip_stats) {
    set_has_ip_stats();
  } else {
    clear_has_ip_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.ip_stats)
}

// optional .mesos.IcmpStatistics icmp_stats = 2;
bool SNMPStatistics::has_icmp_stats() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void SNMPStatistics::set_has_icmp_stats() {
  _has_bits_[0] |= 0x00000002u;
}
void SNMPStatistics::clear_has_icmp_stats() {
  _has_bits_[0] &= ~0x00000002u;
}
void SNMPStatistics::clear_icmp_stats() {
  if (icmp_stats_ != NULL) icmp_stats_->::mesos::IcmpStatistics::Clear();
  clear_has_icmp_stats();
}
const ::mesos::IcmpStatistics& SNMPStatistics::icmp_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.icmp_stats)
  return icmp_stats_ != NULL ? *icmp_stats_ : *default_instance_->icmp_stats_;
}
::mesos::IcmpStatistics* SNMPStatistics::mutable_icmp_stats() {
  set_has_icmp_stats();
  if (icmp_stats_ == NULL) {
    icmp_stats_ = new ::mesos::IcmpStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.icmp_stats)
  return icmp_stats_;
}
::mesos::IcmpStatistics* SNMPStatistics::release_icmp_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.icmp_stats)
  clear_has_icmp_stats();
  ::mesos::IcmpStatistics* temp = icmp_stats_;
  icmp_stats_ = NULL;
  return temp;
}
void SNMPStatistics::set_allocated_icmp_stats(::mesos::IcmpStatistics* icmp_stats) {
  delete icmp_stats_;
  icmp_stats_ = icmp_stats;
  if (icmp_stats) {
    set_has_icmp_stats();
  } else {
    clear_has_icmp_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.icmp_stats)
}

// optional .mesos.TcpStatistics tcp_stats = 3;
bool SNMPStatistics::has_tcp_stats() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void SNMPStatistics::set_has_tcp_stats() {
  _has_bits_[0] |= 0x00000004u;
}
void SNMPStatistics::clear_has_tcp_stats() {
  _has_bits_[0] &= ~0x00000004u;
}
void SNMPStatistics::clear_tcp_stats() {
  if (tcp_stats_ != NULL) tcp_stats_->::mesos::TcpStatistics::Clear();
  clear_has_tcp_stats();
}
const ::mesos::TcpStatistics& SNMPStatistics::tcp_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.tcp_stats)
  return tcp_stats_ != NULL ? *tcp_stats_ : *default_instance_->tcp_stats_;
}
::mesos::TcpStatistics* SNMPStatistics::mutable_tcp_stats() {
  set_has_tcp_stats();
  if (tcp_stats_ == NULL) {
    tcp_stats_ = new ::mesos::TcpStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.tcp_stats)
  return tcp_stats_;
}
::mesos::TcpStatistics* SNMPStatistics::release_tcp_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.tcp_stats)
  clear_has_tcp_stats();
  ::mesos::TcpStatistics* temp = tcp_stats_;
  tcp_stats_ = NULL;
  return temp;
}
void SNMPStatistics::set_allocated_tcp_stats(::mesos::TcpStatistics* tcp_stats) {
  delete tcp_stats_;
  tcp_stats_ = tcp_stats;
  if (tcp_stats) {
    set_has_tcp_stats();
  } else {
    clear_has_tcp_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.tcp_stats)
}

// optional .mesos.UdpStatistics udp_stats = 4;
bool SNMPStatistics::has_udp_stats() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void SNMPStatistics::set_has_udp_stats() {
  _has_bits_[0] |= 0x00000008u;
}
void SNMPStatistics::clear_has_udp_stats() {
  _has_bits_[0] &= ~0x00000008u;
}
void SNMPStatistics::clear_udp_stats() {
  if (udp_stats_ != NULL) udp_stats_->::mesos::UdpStatistics::Clear();
  clear_has_udp_stats();
}
const ::mesos::UdpStatistics& SNMPStatistics::udp_stats() const {
  // @@protoc_insertion_point(field_get:mesos.SNMPStatistics.udp_stats)
  return udp_stats_ != NULL ? *udp_stats_ : *default_instance_->udp_stats_;
}
::mesos::UdpStatistics* SNMPStatistics::mutable_udp_stats() {
  set_has_udp_stats();
  if (udp_stats_ == NULL) {
    udp_stats_ = new ::mesos::UdpStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.SNMPStatistics.udp_stats)
  return udp_stats_;
}
::mesos::UdpStatistics* SNMPStatistics::release_udp_stats() {
  // @@protoc_insertion_point(field_release:mesos.SNMPStatistics.udp_stats)
  clear_has_udp_stats();
  ::mesos::UdpStatistics* temp = udp_stats_;
  udp_stats_ = NULL;
  return temp;
}
void SNMPStatistics::set_allocated_udp_stats(::mesos::UdpStatistics* udp_stats) {
  delete udp_stats_;
  udp_stats_ = udp_stats;
  if (udp_stats) {
    set_has_udp_stats();
  } else {
    clear_has_udp_stats();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.SNMPStatistics.udp_stats)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResourceStatistics::kTimestampFieldNumber;
const int ResourceStatistics::kProcessesFieldNumber;
const int ResourceStatistics::kThreadsFieldNumber;
const int ResourceStatistics::kCpusUserTimeSecsFieldNumber;
const int ResourceStatistics::kCpusSystemTimeSecsFieldNumber;
const int ResourceStatistics::kCpusLimitFieldNumber;
const int ResourceStatistics::kCpusNrPeriodsFieldNumber;
const int ResourceStatistics::kCpusNrThrottledFieldNumber;
const int ResourceStatistics::kCpusThrottledTimeSecsFieldNumber;
const int ResourceStatistics::kMemTotalBytesFieldNumber;
const int ResourceStatistics::kMemTotalMemswBytesFieldNumber;
const int ResourceStatistics::kMemLimitBytesFieldNumber;
const int ResourceStatistics::kMemSoftLimitBytesFieldNumber;
const int ResourceStatistics::kMemFileBytesFieldNumber;
const int ResourceStatistics::kMemAnonBytesFieldNumber;
const int ResourceStatistics::kMemCacheBytesFieldNumber;
const int ResourceStatistics::kMemRssBytesFieldNumber;
const int ResourceStatistics::kMemMappedFileBytesFieldNumber;
const int ResourceStatistics::kMemSwapBytesFieldNumber;
const int ResourceStatistics::kMemUnevictableBytesFieldNumber;
const int ResourceStatistics::kMemLowPressureCounterFieldNumber;
const int ResourceStatistics::kMemMediumPressureCounterFieldNumber;
const int ResourceStatistics::kMemCriticalPressureCounterFieldNumber;
const int ResourceStatistics::kDiskLimitBytesFieldNumber;
const int ResourceStatistics::kDiskUsedBytesFieldNumber;
const int ResourceStatistics::kPerfFieldNumber;
const int ResourceStatistics::kNetRxPacketsFieldNumber;
const int ResourceStatistics::kNetRxBytesFieldNumber;
const int ResourceStatistics::kNetRxErrorsFieldNumber;
const int ResourceStatistics::kNetRxDroppedFieldNumber;
const int ResourceStatistics::kNetTxPacketsFieldNumber;
const int ResourceStatistics::kNetTxBytesFieldNumber;
const int ResourceStatistics::kNetTxErrorsFieldNumber;
const int ResourceStatistics::kNetTxDroppedFieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP50FieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP90FieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP95FieldNumber;
const int ResourceStatistics::kNetTcpRttMicrosecsP99FieldNumber;
const int ResourceStatistics::kNetTcpActiveConnectionsFieldNumber;
const int ResourceStatistics::kNetTcpTimeWaitConnectionsFieldNumber;
const int ResourceStatistics::kNetTrafficControlStatisticsFieldNumber;
const int ResourceStatistics::kNetSnmpStatisticsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResourceStatistics::ResourceStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceStatistics)
}

void ResourceStatistics::InitAsDefaultInstance() {
  perf_ = const_cast< ::mesos::PerfStatistics*>(&::mesos::PerfStatistics::default_instance());
  net_snmp_statistics_ = const_cast< ::mesos::SNMPStatistics*>(&::mesos::SNMPStatistics::default_instance());
}

ResourceStatistics::ResourceStatistics(const ResourceStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceStatistics)
}

void ResourceStatistics::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  processes_ = 0u;
  threads_ = 0u;
  cpus_user_time_secs_ = 0;
  cpus_system_time_secs_ = 0;
  cpus_limit_ = 0;
  cpus_nr_periods_ = 0u;
  cpus_nr_throttled_ = 0u;
  cpus_throttled_time_secs_ = 0;
  mem_total_bytes_ = GOOGLE_ULONGLONG(0);
  mem_total_memsw_bytes_ = GOOGLE_ULONGLONG(0);
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  mem_soft_limit_bytes_ = GOOGLE_ULONGLONG(0);
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  mem_cache_bytes_ = GOOGLE_ULONGLONG(0);
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  mem_swap_bytes_ = GOOGLE_ULONGLONG(0);
  mem_unevictable_bytes_ = GOOGLE_ULONGLONG(0);
  mem_low_pressure_counter_ = GOOGLE_ULONGLONG(0);
  mem_medium_pressure_counter_ = GOOGLE_ULONGLONG(0);
  mem_critical_pressure_counter_ = GOOGLE_ULONGLONG(0);
  disk_limit_bytes_ = GOOGLE_ULONGLONG(0);
  disk_used_bytes_ = GOOGLE_ULONGLONG(0);
  perf_ = NULL;
  net_rx_packets_ = GOOGLE_ULONGLONG(0);
  net_rx_bytes_ = GOOGLE_ULONGLONG(0);
  net_rx_errors_ = GOOGLE_ULONGLONG(0);
  net_rx_dropped_ = GOOGLE_ULONGLONG(0);
  net_tx_packets_ = GOOGLE_ULONGLONG(0);
  net_tx_bytes_ = GOOGLE_ULONGLONG(0);
  net_tx_errors_ = GOOGLE_ULONGLONG(0);
  net_tx_dropped_ = GOOGLE_ULONGLONG(0);
  net_tcp_rtt_microsecs_p50_ = 0;
  net_tcp_rtt_microsecs_p90_ = 0;
  net_tcp_rtt_microsecs_p95_ = 0;
  net_tcp_rtt_microsecs_p99_ = 0;
  net_tcp_active_connections_ = 0;
  net_tcp_time_wait_connections_ = 0;
  net_snmp_statistics_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceStatistics::~ResourceStatistics() {
  // @@protoc_insertion_point(destructor:mesos.ResourceStatistics)
  SharedDtor();
}

void ResourceStatistics::SharedDtor() {
  if (this != default_instance_) {
    delete perf_;
    delete net_snmp_statistics_;
  }
}

void ResourceStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceStatistics_descriptor_;
}

const ResourceStatistics& ResourceStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceStatistics* ResourceStatistics::default_instance_ = NULL;

ResourceStatistics* ResourceStatistics::New(::google::protobuf::Arena* arena) const {
  ResourceStatistics* n = new ResourceStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResourceStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ResourceStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ResourceStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ResourceStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(timestamp_, cpus_nr_throttled_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(cpus_throttled_time_secs_, mem_cache_bytes_);
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    ZR_(mem_rss_bytes_, disk_limit_bytes_);
  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    ZR_(net_rx_packets_, net_tx_bytes_);
    disk_used_bytes_ = GOOGLE_ULONGLONG(0);
    if (has_perf()) {
      if (perf_ != NULL) perf_->::mesos::PerfStatistics::Clear();
    }
  }
  if (_has_bits_[32 / 32] & 255u) {
    ZR_(net_tx_errors_, net_tcp_time_wait_connections_);
  }
  if (has_net_snmp_statistics()) {
    if (net_snmp_statistics_ != NULL) net_snmp_statistics_->::mesos::SNMPStatistics::Clear();
  }

#undef ZR_HELPER_
#undef ZR_

  net_traffic_control_statistics_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResourceStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_cpus_user_time_secs;
        break;
      }

      // optional double cpus_user_time_secs = 2;
      case 2: {
        if (tag == 17) {
         parse_cpus_user_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_user_time_secs_)));
          set_has_cpus_user_time_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_cpus_system_time_secs;
        break;
      }

      // optional double cpus_system_time_secs = 3;
      case 3: {
        if (tag == 25) {
         parse_cpus_system_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_system_time_secs_)));
          set_has_cpus_system_time_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(33)) goto parse_cpus_limit;
        break;
      }

      // optional double cpus_limit = 4;
      case 4: {
        if (tag == 33) {
         parse_cpus_limit:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_limit_)));
          set_has_cpus_limit();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mem_rss_bytes;
        break;
      }

      // optional uint64 mem_rss_bytes = 5;
      case 5: {
        if (tag == 40) {
         parse_mem_rss_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_rss_bytes_)));
          set_has_mem_rss_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_mem_limit_bytes;
        break;
      }

      // optional uint64 mem_limit_bytes = 6;
      case 6: {
        if (tag == 48) {
         parse_mem_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_limit_bytes_)));
          set_has_mem_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_cpus_nr_periods;
        break;
      }

      // optional uint32 cpus_nr_periods = 7;
      case 7: {
        if (tag == 56) {
         parse_cpus_nr_periods:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpus_nr_periods_)));
          set_has_cpus_nr_periods();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_cpus_nr_throttled;
        break;
      }

      // optional uint32 cpus_nr_throttled = 8;
      case 8: {
        if (tag == 64) {
         parse_cpus_nr_throttled:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &cpus_nr_throttled_)));
          set_has_cpus_nr_throttled();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(73)) goto parse_cpus_throttled_time_secs;
        break;
      }

      // optional double cpus_throttled_time_secs = 9;
      case 9: {
        if (tag == 73) {
         parse_cpus_throttled_time_secs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpus_throttled_time_secs_)));
          set_has_cpus_throttled_time_secs();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_mem_file_bytes;
        break;
      }

      // optional uint64 mem_file_bytes = 10;
      case 10: {
        if (tag == 80) {
         parse_mem_file_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_file_bytes_)));
          set_has_mem_file_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_mem_anon_bytes;
        break;
      }

      // optional uint64 mem_anon_bytes = 11;
      case 11: {
        if (tag == 88) {
         parse_mem_anon_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_anon_bytes_)));
          set_has_mem_anon_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_mem_mapped_file_bytes;
        break;
      }

      // optional uint64 mem_mapped_file_bytes = 12;
      case 12: {
        if (tag == 96) {
         parse_mem_mapped_file_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_mapped_file_bytes_)));
          set_has_mem_mapped_file_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_perf;
        break;
      }

      // optional .mesos.PerfStatistics perf = 13;
      case 13: {
        if (tag == 106) {
         parse_perf:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_perf()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(112)) goto parse_net_rx_packets;
        break;
      }

      // optional uint64 net_rx_packets = 14;
      case 14: {
        if (tag == 112) {
         parse_net_rx_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_packets_)));
          set_has_net_rx_packets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_net_rx_bytes;
        break;
      }

      // optional uint64 net_rx_bytes = 15;
      case 15: {
        if (tag == 120) {
         parse_net_rx_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_bytes_)));
          set_has_net_rx_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_net_rx_errors;
        break;
      }

      // optional uint64 net_rx_errors = 16;
      case 16: {
        if (tag == 128) {
         parse_net_rx_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_errors_)));
          set_has_net_rx_errors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_net_rx_dropped;
        break;
      }

      // optional uint64 net_rx_dropped = 17;
      case 17: {
        if (tag == 136) {
         parse_net_rx_dropped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_rx_dropped_)));
          set_has_net_rx_dropped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_net_tx_packets;
        break;
      }

      // optional uint64 net_tx_packets = 18;
      case 18: {
        if (tag == 144) {
         parse_net_tx_packets:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_packets_)));
          set_has_net_tx_packets();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_net_tx_bytes;
        break;
      }

      // optional uint64 net_tx_bytes = 19;
      case 19: {
        if (tag == 152) {
         parse_net_tx_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_bytes_)));
          set_has_net_tx_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_net_tx_errors;
        break;
      }

      // optional uint64 net_tx_errors = 20;
      case 20: {
        if (tag == 160) {
         parse_net_tx_errors:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_errors_)));
          set_has_net_tx_errors();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_net_tx_dropped;
        break;
      }

      // optional uint64 net_tx_dropped = 21;
      case 21: {
        if (tag == 168) {
         parse_net_tx_dropped:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &net_tx_dropped_)));
          set_has_net_tx_dropped();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(177)) goto parse_net_tcp_rtt_microsecs_p50;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p50 = 22;
      case 22: {
        if (tag == 177) {
         parse_net_tcp_rtt_microsecs_p50:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p50_)));
          set_has_net_tcp_rtt_microsecs_p50();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(185)) goto parse_net_tcp_rtt_microsecs_p90;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p90 = 23;
      case 23: {
        if (tag == 185) {
         parse_net_tcp_rtt_microsecs_p90:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p90_)));
          set_has_net_tcp_rtt_microsecs_p90();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(193)) goto parse_net_tcp_rtt_microsecs_p95;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p95 = 24;
      case 24: {
        if (tag == 193) {
         parse_net_tcp_rtt_microsecs_p95:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p95_)));
          set_has_net_tcp_rtt_microsecs_p95();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(201)) goto parse_net_tcp_rtt_microsecs_p99;
        break;
      }

      // optional double net_tcp_rtt_microsecs_p99 = 25;
      case 25: {
        if (tag == 201) {
         parse_net_tcp_rtt_microsecs_p99:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_rtt_microsecs_p99_)));
          set_has_net_tcp_rtt_microsecs_p99();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_disk_limit_bytes;
        break;
      }

      // optional uint64 disk_limit_bytes = 26;
      case 26: {
        if (tag == 208) {
         parse_disk_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &disk_limit_bytes_)));
          set_has_disk_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_disk_used_bytes;
        break;
      }

      // optional uint64 disk_used_bytes = 27;
      case 27: {
        if (tag == 216) {
         parse_disk_used_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &disk_used_bytes_)));
          set_has_disk_used_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(225)) goto parse_net_tcp_active_connections;
        break;
      }

      // optional double net_tcp_active_connections = 28;
      case 28: {
        if (tag == 225) {
         parse_net_tcp_active_connections:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_active_connections_)));
          set_has_net_tcp_active_connections();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(233)) goto parse_net_tcp_time_wait_connections;
        break;
      }

      // optional double net_tcp_time_wait_connections = 29;
      case 29: {
        if (tag == 233) {
         parse_net_tcp_time_wait_connections:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &net_tcp_time_wait_connections_)));
          set_has_net_tcp_time_wait_connections();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_processes;
        break;
      }

      // optional uint32 processes = 30;
      case 30: {
        if (tag == 240) {
         parse_processes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &processes_)));
          set_has_processes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_threads;
        break;
      }

      // optional uint32 threads = 31;
      case 31: {
        if (tag == 248) {
         parse_threads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &threads_)));
          set_has_threads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_mem_low_pressure_counter;
        break;
      }

      // optional uint64 mem_low_pressure_counter = 32;
      case 32: {
        if (tag == 256) {
         parse_mem_low_pressure_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_low_pressure_counter_)));
          set_has_mem_low_pressure_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_mem_medium_pressure_counter;
        break;
      }

      // optional uint64 mem_medium_pressure_counter = 33;
      case 33: {
        if (tag == 264) {
         parse_mem_medium_pressure_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_medium_pressure_counter_)));
          set_has_mem_medium_pressure_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_mem_critical_pressure_counter;
        break;
      }

      // optional uint64 mem_critical_pressure_counter = 34;
      case 34: {
        if (tag == 272) {
         parse_mem_critical_pressure_counter:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_critical_pressure_counter_)));
          set_has_mem_critical_pressure_counter();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_net_traffic_control_statistics;
        break;
      }

      // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
      case 35: {
        if (tag == 282) {
         parse_net_traffic_control_statistics:
          DO_(input->IncrementRecursionDepth());
         parse_loop_net_traffic_control_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_net_traffic_control_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(282)) goto parse_loop_net_traffic_control_statistics;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(288)) goto parse_mem_total_bytes;
        break;
      }

      // optional uint64 mem_total_bytes = 36;
      case 36: {
        if (tag == 288) {
         parse_mem_total_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_total_bytes_)));
          set_has_mem_total_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_mem_total_memsw_bytes;
        break;
      }

      // optional uint64 mem_total_memsw_bytes = 37;
      case 37: {
        if (tag == 296) {
         parse_mem_total_memsw_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_total_memsw_bytes_)));
          set_has_mem_total_memsw_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_mem_soft_limit_bytes;
        break;
      }

      // optional uint64 mem_soft_limit_bytes = 38;
      case 38: {
        if (tag == 304) {
         parse_mem_soft_limit_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_soft_limit_bytes_)));
          set_has_mem_soft_limit_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(312)) goto parse_mem_cache_bytes;
        break;
      }

      // optional uint64 mem_cache_bytes = 39;
      case 39: {
        if (tag == 312) {
         parse_mem_cache_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_cache_bytes_)));
          set_has_mem_cache_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(320)) goto parse_mem_swap_bytes;
        break;
      }

      // optional uint64 mem_swap_bytes = 40;
      case 40: {
        if (tag == 320) {
         parse_mem_swap_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_swap_bytes_)));
          set_has_mem_swap_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_mem_unevictable_bytes;
        break;
      }

      // optional uint64 mem_unevictable_bytes = 41;
      case 41: {
        if (tag == 328) {
         parse_mem_unevictable_bytes:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &mem_unevictable_bytes_)));
          set_has_mem_unevictable_bytes();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(338)) goto parse_net_snmp_statistics;
        break;
      }

      // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
      case 42: {
        if (tag == 338) {
         parse_net_snmp_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_net_snmp_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceStatistics)
  return false;
#undef DO_
}

void ResourceStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->timestamp(), output);
  }

  // optional double cpus_user_time_secs = 2;
  if (has_cpus_user_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->cpus_user_time_secs(), output);
  }

  // optional double cpus_system_time_secs = 3;
  if (has_cpus_system_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->cpus_system_time_secs(), output);
  }

  // optional double cpus_limit = 4;
  if (has_cpus_limit()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(4, this->cpus_limit(), output);
  }

  // optional uint64 mem_rss_bytes = 5;
  if (has_mem_rss_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->mem_rss_bytes(), output);
  }

  // optional uint64 mem_limit_bytes = 6;
  if (has_mem_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->mem_limit_bytes(), output);
  }

  // optional uint32 cpus_nr_periods = 7;
  if (has_cpus_nr_periods()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(7, this->cpus_nr_periods(), output);
  }

  // optional uint32 cpus_nr_throttled = 8;
  if (has_cpus_nr_throttled()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(8, this->cpus_nr_throttled(), output);
  }

  // optional double cpus_throttled_time_secs = 9;
  if (has_cpus_throttled_time_secs()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(9, this->cpus_throttled_time_secs(), output);
  }

  // optional uint64 mem_file_bytes = 10;
  if (has_mem_file_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->mem_file_bytes(), output);
  }

  // optional uint64 mem_anon_bytes = 11;
  if (has_mem_anon_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->mem_anon_bytes(), output);
  }

  // optional uint64 mem_mapped_file_bytes = 12;
  if (has_mem_mapped_file_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->mem_mapped_file_bytes(), output);
  }

  // optional .mesos.PerfStatistics perf = 13;
  if (has_perf()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->perf_, output);
  }

  // optional uint64 net_rx_packets = 14;
  if (has_net_rx_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(14, this->net_rx_packets(), output);
  }

  // optional uint64 net_rx_bytes = 15;
  if (has_net_rx_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->net_rx_bytes(), output);
  }

  // optional uint64 net_rx_errors = 16;
  if (has_net_rx_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->net_rx_errors(), output);
  }

  // optional uint64 net_rx_dropped = 17;
  if (has_net_rx_dropped()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->net_rx_dropped(), output);
  }

  // optional uint64 net_tx_packets = 18;
  if (has_net_tx_packets()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->net_tx_packets(), output);
  }

  // optional uint64 net_tx_bytes = 19;
  if (has_net_tx_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->net_tx_bytes(), output);
  }

  // optional uint64 net_tx_errors = 20;
  if (has_net_tx_errors()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(20, this->net_tx_errors(), output);
  }

  // optional uint64 net_tx_dropped = 21;
  if (has_net_tx_dropped()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->net_tx_dropped(), output);
  }

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  if (has_net_tcp_rtt_microsecs_p50()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(22, this->net_tcp_rtt_microsecs_p50(), output);
  }

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  if (has_net_tcp_rtt_microsecs_p90()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(23, this->net_tcp_rtt_microsecs_p90(), output);
  }

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  if (has_net_tcp_rtt_microsecs_p95()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(24, this->net_tcp_rtt_microsecs_p95(), output);
  }

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  if (has_net_tcp_rtt_microsecs_p99()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(25, this->net_tcp_rtt_microsecs_p99(), output);
  }

  // optional uint64 disk_limit_bytes = 26;
  if (has_disk_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->disk_limit_bytes(), output);
  }

  // optional uint64 disk_used_bytes = 27;
  if (has_disk_used_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(27, this->disk_used_bytes(), output);
  }

  // optional double net_tcp_active_connections = 28;
  if (has_net_tcp_active_connections()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(28, this->net_tcp_active_connections(), output);
  }

  // optional double net_tcp_time_wait_connections = 29;
  if (has_net_tcp_time_wait_connections()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(29, this->net_tcp_time_wait_connections(), output);
  }

  // optional uint32 processes = 30;
  if (has_processes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(30, this->processes(), output);
  }

  // optional uint32 threads = 31;
  if (has_threads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(31, this->threads(), output);
  }

  // optional uint64 mem_low_pressure_counter = 32;
  if (has_mem_low_pressure_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(32, this->mem_low_pressure_counter(), output);
  }

  // optional uint64 mem_medium_pressure_counter = 33;
  if (has_mem_medium_pressure_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(33, this->mem_medium_pressure_counter(), output);
  }

  // optional uint64 mem_critical_pressure_counter = 34;
  if (has_mem_critical_pressure_counter()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(34, this->mem_critical_pressure_counter(), output);
  }

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  for (unsigned int i = 0, n = this->net_traffic_control_statistics_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      35, this->net_traffic_control_statistics(i), output);
  }

  // optional uint64 mem_total_bytes = 36;
  if (has_mem_total_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(36, this->mem_total_bytes(), output);
  }

  // optional uint64 mem_total_memsw_bytes = 37;
  if (has_mem_total_memsw_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(37, this->mem_total_memsw_bytes(), output);
  }

  // optional uint64 mem_soft_limit_bytes = 38;
  if (has_mem_soft_limit_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(38, this->mem_soft_limit_bytes(), output);
  }

  // optional uint64 mem_cache_bytes = 39;
  if (has_mem_cache_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(39, this->mem_cache_bytes(), output);
  }

  // optional uint64 mem_swap_bytes = 40;
  if (has_mem_swap_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(40, this->mem_swap_bytes(), output);
  }

  // optional uint64 mem_unevictable_bytes = 41;
  if (has_mem_unevictable_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(41, this->mem_unevictable_bytes(), output);
  }

  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  if (has_net_snmp_statistics()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      42, *this->net_snmp_statistics_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceStatistics)
}

::google::protobuf::uint8* ResourceStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->timestamp(), target);
  }

  // optional double cpus_user_time_secs = 2;
  if (has_cpus_user_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->cpus_user_time_secs(), target);
  }

  // optional double cpus_system_time_secs = 3;
  if (has_cpus_system_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->cpus_system_time_secs(), target);
  }

  // optional double cpus_limit = 4;
  if (has_cpus_limit()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(4, this->cpus_limit(), target);
  }

  // optional uint64 mem_rss_bytes = 5;
  if (has_mem_rss_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->mem_rss_bytes(), target);
  }

  // optional uint64 mem_limit_bytes = 6;
  if (has_mem_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->mem_limit_bytes(), target);
  }

  // optional uint32 cpus_nr_periods = 7;
  if (has_cpus_nr_periods()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(7, this->cpus_nr_periods(), target);
  }

  // optional uint32 cpus_nr_throttled = 8;
  if (has_cpus_nr_throttled()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(8, this->cpus_nr_throttled(), target);
  }

  // optional double cpus_throttled_time_secs = 9;
  if (has_cpus_throttled_time_secs()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(9, this->cpus_throttled_time_secs(), target);
  }

  // optional uint64 mem_file_bytes = 10;
  if (has_mem_file_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->mem_file_bytes(), target);
  }

  // optional uint64 mem_anon_bytes = 11;
  if (has_mem_anon_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->mem_anon_bytes(), target);
  }

  // optional uint64 mem_mapped_file_bytes = 12;
  if (has_mem_mapped_file_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->mem_mapped_file_bytes(), target);
  }

  // optional .mesos.PerfStatistics perf = 13;
  if (has_perf()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->perf_, false, target);
  }

  // optional uint64 net_rx_packets = 14;
  if (has_net_rx_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(14, this->net_rx_packets(), target);
  }

  // optional uint64 net_rx_bytes = 15;
  if (has_net_rx_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->net_rx_bytes(), target);
  }

  // optional uint64 net_rx_errors = 16;
  if (has_net_rx_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(16, this->net_rx_errors(), target);
  }

  // optional uint64 net_rx_dropped = 17;
  if (has_net_rx_dropped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(17, this->net_rx_dropped(), target);
  }

  // optional uint64 net_tx_packets = 18;
  if (has_net_tx_packets()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(18, this->net_tx_packets(), target);
  }

  // optional uint64 net_tx_bytes = 19;
  if (has_net_tx_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(19, this->net_tx_bytes(), target);
  }

  // optional uint64 net_tx_errors = 20;
  if (has_net_tx_errors()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(20, this->net_tx_errors(), target);
  }

  // optional uint64 net_tx_dropped = 21;
  if (has_net_tx_dropped()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->net_tx_dropped(), target);
  }

  // optional double net_tcp_rtt_microsecs_p50 = 22;
  if (has_net_tcp_rtt_microsecs_p50()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(22, this->net_tcp_rtt_microsecs_p50(), target);
  }

  // optional double net_tcp_rtt_microsecs_p90 = 23;
  if (has_net_tcp_rtt_microsecs_p90()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(23, this->net_tcp_rtt_microsecs_p90(), target);
  }

  // optional double net_tcp_rtt_microsecs_p95 = 24;
  if (has_net_tcp_rtt_microsecs_p95()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(24, this->net_tcp_rtt_microsecs_p95(), target);
  }

  // optional double net_tcp_rtt_microsecs_p99 = 25;
  if (has_net_tcp_rtt_microsecs_p99()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(25, this->net_tcp_rtt_microsecs_p99(), target);
  }

  // optional uint64 disk_limit_bytes = 26;
  if (has_disk_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(26, this->disk_limit_bytes(), target);
  }

  // optional uint64 disk_used_bytes = 27;
  if (has_disk_used_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(27, this->disk_used_bytes(), target);
  }

  // optional double net_tcp_active_connections = 28;
  if (has_net_tcp_active_connections()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(28, this->net_tcp_active_connections(), target);
  }

  // optional double net_tcp_time_wait_connections = 29;
  if (has_net_tcp_time_wait_connections()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(29, this->net_tcp_time_wait_connections(), target);
  }

  // optional uint32 processes = 30;
  if (has_processes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(30, this->processes(), target);
  }

  // optional uint32 threads = 31;
  if (has_threads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(31, this->threads(), target);
  }

  // optional uint64 mem_low_pressure_counter = 32;
  if (has_mem_low_pressure_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(32, this->mem_low_pressure_counter(), target);
  }

  // optional uint64 mem_medium_pressure_counter = 33;
  if (has_mem_medium_pressure_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(33, this->mem_medium_pressure_counter(), target);
  }

  // optional uint64 mem_critical_pressure_counter = 34;
  if (has_mem_critical_pressure_counter()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(34, this->mem_critical_pressure_counter(), target);
  }

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  for (unsigned int i = 0, n = this->net_traffic_control_statistics_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        35, this->net_traffic_control_statistics(i), false, target);
  }

  // optional uint64 mem_total_bytes = 36;
  if (has_mem_total_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(36, this->mem_total_bytes(), target);
  }

  // optional uint64 mem_total_memsw_bytes = 37;
  if (has_mem_total_memsw_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(37, this->mem_total_memsw_bytes(), target);
  }

  // optional uint64 mem_soft_limit_bytes = 38;
  if (has_mem_soft_limit_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(38, this->mem_soft_limit_bytes(), target);
  }

  // optional uint64 mem_cache_bytes = 39;
  if (has_mem_cache_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(39, this->mem_cache_bytes(), target);
  }

  // optional uint64 mem_swap_bytes = 40;
  if (has_mem_swap_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(40, this->mem_swap_bytes(), target);
  }

  // optional uint64 mem_unevictable_bytes = 41;
  if (has_mem_unevictable_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(41, this->mem_unevictable_bytes(), target);
  }

  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  if (has_net_snmp_statistics()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        42, *this->net_snmp_statistics_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceStatistics)
  return target;
}

int ResourceStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ResourceStatistics)
  int total_size = 0;

  // required double timestamp = 1;
  if (has_timestamp()) {
    total_size += 1 + 8;
  }
  if (_has_bits_[1 / 32] & 254u) {
    // optional uint32 processes = 30;
    if (has_processes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->processes());
    }

    // optional uint32 threads = 31;
    if (has_threads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->threads());
    }

    // optional double cpus_user_time_secs = 2;
    if (has_cpus_user_time_secs()) {
      total_size += 1 + 8;
    }

    // optional double cpus_system_time_secs = 3;
    if (has_cpus_system_time_secs()) {
      total_size += 1 + 8;
    }

    // optional double cpus_limit = 4;
    if (has_cpus_limit()) {
      total_size += 1 + 8;
    }

    // optional uint32 cpus_nr_periods = 7;
    if (has_cpus_nr_periods()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cpus_nr_periods());
    }

    // optional uint32 cpus_nr_throttled = 8;
    if (has_cpus_nr_throttled()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->cpus_nr_throttled());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional double cpus_throttled_time_secs = 9;
    if (has_cpus_throttled_time_secs()) {
      total_size += 1 + 8;
    }

    // optional uint64 mem_total_bytes = 36;
    if (has_mem_total_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_total_bytes());
    }

    // optional uint64 mem_total_memsw_bytes = 37;
    if (has_mem_total_memsw_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_total_memsw_bytes());
    }

    // optional uint64 mem_limit_bytes = 6;
    if (has_mem_limit_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_limit_bytes());
    }

    // optional uint64 mem_soft_limit_bytes = 38;
    if (has_mem_soft_limit_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_soft_limit_bytes());
    }

    // optional uint64 mem_file_bytes = 10;
    if (has_mem_file_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_file_bytes());
    }

    // optional uint64 mem_anon_bytes = 11;
    if (has_mem_anon_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_anon_bytes());
    }

    // optional uint64 mem_cache_bytes = 39;
    if (has_mem_cache_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_cache_bytes());
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional uint64 mem_rss_bytes = 5;
    if (has_mem_rss_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_rss_bytes());
    }

    // optional uint64 mem_mapped_file_bytes = 12;
    if (has_mem_mapped_file_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_mapped_file_bytes());
    }

    // optional uint64 mem_swap_bytes = 40;
    if (has_mem_swap_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_swap_bytes());
    }

    // optional uint64 mem_unevictable_bytes = 41;
    if (has_mem_unevictable_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_unevictable_bytes());
    }

    // optional uint64 mem_low_pressure_counter = 32;
    if (has_mem_low_pressure_counter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_low_pressure_counter());
    }

    // optional uint64 mem_medium_pressure_counter = 33;
    if (has_mem_medium_pressure_counter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_medium_pressure_counter());
    }

    // optional uint64 mem_critical_pressure_counter = 34;
    if (has_mem_critical_pressure_counter()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->mem_critical_pressure_counter());
    }

    // optional uint64 disk_limit_bytes = 26;
    if (has_disk_limit_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->disk_limit_bytes());
    }

  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    // optional uint64 disk_used_bytes = 27;
    if (has_disk_used_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->disk_used_bytes());
    }

    // optional .mesos.PerfStatistics perf = 13;
    if (has_perf()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->perf_);
    }

    // optional uint64 net_rx_packets = 14;
    if (has_net_rx_packets()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_packets());
    }

    // optional uint64 net_rx_bytes = 15;
    if (has_net_rx_bytes()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_bytes());
    }

    // optional uint64 net_rx_errors = 16;
    if (has_net_rx_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_errors());
    }

    // optional uint64 net_rx_dropped = 17;
    if (has_net_rx_dropped()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_rx_dropped());
    }

    // optional uint64 net_tx_packets = 18;
    if (has_net_tx_packets()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_packets());
    }

    // optional uint64 net_tx_bytes = 19;
    if (has_net_tx_bytes()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_bytes());
    }

  }
  if (_has_bits_[32 / 32] & 255u) {
    // optional uint64 net_tx_errors = 20;
    if (has_net_tx_errors()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_errors());
    }

    // optional uint64 net_tx_dropped = 21;
    if (has_net_tx_dropped()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->net_tx_dropped());
    }

    // optional double net_tcp_rtt_microsecs_p50 = 22;
    if (has_net_tcp_rtt_microsecs_p50()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_rtt_microsecs_p90 = 23;
    if (has_net_tcp_rtt_microsecs_p90()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_rtt_microsecs_p95 = 24;
    if (has_net_tcp_rtt_microsecs_p95()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_rtt_microsecs_p99 = 25;
    if (has_net_tcp_rtt_microsecs_p99()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_active_connections = 28;
    if (has_net_tcp_active_connections()) {
      total_size += 2 + 8;
    }

    // optional double net_tcp_time_wait_connections = 29;
    if (has_net_tcp_time_wait_connections()) {
      total_size += 2 + 8;
    }

  }
  // optional .mesos.SNMPStatistics net_snmp_statistics = 42;
  if (has_net_snmp_statistics()) {
    total_size += 2 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->net_snmp_statistics_);
  }

  // repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
  total_size += 2 * this->net_traffic_control_statistics_size();
  for (int i = 0; i < this->net_traffic_control_statistics_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->net_traffic_control_statistics(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ResourceStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ResourceStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResourceStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ResourceStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ResourceStatistics)
    MergeFrom(*source);
  }
}

void ResourceStatistics::MergeFrom(const ResourceStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ResourceStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  net_traffic_control_statistics_.MergeFrom(from.net_traffic_control_statistics_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_processes()) {
      set_processes(from.processes());
    }
    if (from.has_threads()) {
      set_threads(from.threads());
    }
    if (from.has_cpus_user_time_secs()) {
      set_cpus_user_time_secs(from.cpus_user_time_secs());
    }
    if (from.has_cpus_system_time_secs()) {
      set_cpus_system_time_secs(from.cpus_system_time_secs());
    }
    if (from.has_cpus_limit()) {
      set_cpus_limit(from.cpus_limit());
    }
    if (from.has_cpus_nr_periods()) {
      set_cpus_nr_periods(from.cpus_nr_periods());
    }
    if (from.has_cpus_nr_throttled()) {
      set_cpus_nr_throttled(from.cpus_nr_throttled());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_cpus_throttled_time_secs()) {
      set_cpus_throttled_time_secs(from.cpus_throttled_time_secs());
    }
    if (from.has_mem_total_bytes()) {
      set_mem_total_bytes(from.mem_total_bytes());
    }
    if (from.has_mem_total_memsw_bytes()) {
      set_mem_total_memsw_bytes(from.mem_total_memsw_bytes());
    }
    if (from.has_mem_limit_bytes()) {
      set_mem_limit_bytes(from.mem_limit_bytes());
    }
    if (from.has_mem_soft_limit_bytes()) {
      set_mem_soft_limit_bytes(from.mem_soft_limit_bytes());
    }
    if (from.has_mem_file_bytes()) {
      set_mem_file_bytes(from.mem_file_bytes());
    }
    if (from.has_mem_anon_bytes()) {
      set_mem_anon_bytes(from.mem_anon_bytes());
    }
    if (from.has_mem_cache_bytes()) {
      set_mem_cache_bytes(from.mem_cache_bytes());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_mem_rss_bytes()) {
      set_mem_rss_bytes(from.mem_rss_bytes());
    }
    if (from.has_mem_mapped_file_bytes()) {
      set_mem_mapped_file_bytes(from.mem_mapped_file_bytes());
    }
    if (from.has_mem_swap_bytes()) {
      set_mem_swap_bytes(from.mem_swap_bytes());
    }
    if (from.has_mem_unevictable_bytes()) {
      set_mem_unevictable_bytes(from.mem_unevictable_bytes());
    }
    if (from.has_mem_low_pressure_counter()) {
      set_mem_low_pressure_counter(from.mem_low_pressure_counter());
    }
    if (from.has_mem_medium_pressure_counter()) {
      set_mem_medium_pressure_counter(from.mem_medium_pressure_counter());
    }
    if (from.has_mem_critical_pressure_counter()) {
      set_mem_critical_pressure_counter(from.mem_critical_pressure_counter());
    }
    if (from.has_disk_limit_bytes()) {
      set_disk_limit_bytes(from.disk_limit_bytes());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_disk_used_bytes()) {
      set_disk_used_bytes(from.disk_used_bytes());
    }
    if (from.has_perf()) {
      mutable_perf()->::mesos::PerfStatistics::MergeFrom(from.perf());
    }
    if (from.has_net_rx_packets()) {
      set_net_rx_packets(from.net_rx_packets());
    }
    if (from.has_net_rx_bytes()) {
      set_net_rx_bytes(from.net_rx_bytes());
    }
    if (from.has_net_rx_errors()) {
      set_net_rx_errors(from.net_rx_errors());
    }
    if (from.has_net_rx_dropped()) {
      set_net_rx_dropped(from.net_rx_dropped());
    }
    if (from.has_net_tx_packets()) {
      set_net_tx_packets(from.net_tx_packets());
    }
    if (from.has_net_tx_bytes()) {
      set_net_tx_bytes(from.net_tx_bytes());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_net_tx_errors()) {
      set_net_tx_errors(from.net_tx_errors());
    }
    if (from.has_net_tx_dropped()) {
      set_net_tx_dropped(from.net_tx_dropped());
    }
    if (from.has_net_tcp_rtt_microsecs_p50()) {
      set_net_tcp_rtt_microsecs_p50(from.net_tcp_rtt_microsecs_p50());
    }
    if (from.has_net_tcp_rtt_microsecs_p90()) {
      set_net_tcp_rtt_microsecs_p90(from.net_tcp_rtt_microsecs_p90());
    }
    if (from.has_net_tcp_rtt_microsecs_p95()) {
      set_net_tcp_rtt_microsecs_p95(from.net_tcp_rtt_microsecs_p95());
    }
    if (from.has_net_tcp_rtt_microsecs_p99()) {
      set_net_tcp_rtt_microsecs_p99(from.net_tcp_rtt_microsecs_p99());
    }
    if (from.has_net_tcp_active_connections()) {
      set_net_tcp_active_connections(from.net_tcp_active_connections());
    }
    if (from.has_net_tcp_time_wait_connections()) {
      set_net_tcp_time_wait_connections(from.net_tcp_time_wait_connections());
    }
  }
  if (from._has_bits_[41 / 32] & (0xffu << (41 % 32))) {
    if (from.has_net_snmp_statistics()) {
      mutable_net_snmp_statistics()->::mesos::SNMPStatistics::MergeFrom(from.net_snmp_statistics());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResourceStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ResourceStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceStatistics::CopyFrom(const ResourceStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ResourceStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceStatistics::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_perf()) {
    if (!this->perf_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->net_traffic_control_statistics())) return false;
  return true;
}

void ResourceStatistics::Swap(ResourceStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResourceStatistics::InternalSwap(ResourceStatistics* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(processes_, other->processes_);
  std::swap(threads_, other->threads_);
  std::swap(cpus_user_time_secs_, other->cpus_user_time_secs_);
  std::swap(cpus_system_time_secs_, other->cpus_system_time_secs_);
  std::swap(cpus_limit_, other->cpus_limit_);
  std::swap(cpus_nr_periods_, other->cpus_nr_periods_);
  std::swap(cpus_nr_throttled_, other->cpus_nr_throttled_);
  std::swap(cpus_throttled_time_secs_, other->cpus_throttled_time_secs_);
  std::swap(mem_total_bytes_, other->mem_total_bytes_);
  std::swap(mem_total_memsw_bytes_, other->mem_total_memsw_bytes_);
  std::swap(mem_limit_bytes_, other->mem_limit_bytes_);
  std::swap(mem_soft_limit_bytes_, other->mem_soft_limit_bytes_);
  std::swap(mem_file_bytes_, other->mem_file_bytes_);
  std::swap(mem_anon_bytes_, other->mem_anon_bytes_);
  std::swap(mem_cache_bytes_, other->mem_cache_bytes_);
  std::swap(mem_rss_bytes_, other->mem_rss_bytes_);
  std::swap(mem_mapped_file_bytes_, other->mem_mapped_file_bytes_);
  std::swap(mem_swap_bytes_, other->mem_swap_bytes_);
  std::swap(mem_unevictable_bytes_, other->mem_unevictable_bytes_);
  std::swap(mem_low_pressure_counter_, other->mem_low_pressure_counter_);
  std::swap(mem_medium_pressure_counter_, other->mem_medium_pressure_counter_);
  std::swap(mem_critical_pressure_counter_, other->mem_critical_pressure_counter_);
  std::swap(disk_limit_bytes_, other->disk_limit_bytes_);
  std::swap(disk_used_bytes_, other->disk_used_bytes_);
  std::swap(perf_, other->perf_);
  std::swap(net_rx_packets_, other->net_rx_packets_);
  std::swap(net_rx_bytes_, other->net_rx_bytes_);
  std::swap(net_rx_errors_, other->net_rx_errors_);
  std::swap(net_rx_dropped_, other->net_rx_dropped_);
  std::swap(net_tx_packets_, other->net_tx_packets_);
  std::swap(net_tx_bytes_, other->net_tx_bytes_);
  std::swap(net_tx_errors_, other->net_tx_errors_);
  std::swap(net_tx_dropped_, other->net_tx_dropped_);
  std::swap(net_tcp_rtt_microsecs_p50_, other->net_tcp_rtt_microsecs_p50_);
  std::swap(net_tcp_rtt_microsecs_p90_, other->net_tcp_rtt_microsecs_p90_);
  std::swap(net_tcp_rtt_microsecs_p95_, other->net_tcp_rtt_microsecs_p95_);
  std::swap(net_tcp_rtt_microsecs_p99_, other->net_tcp_rtt_microsecs_p99_);
  std::swap(net_tcp_active_connections_, other->net_tcp_active_connections_);
  std::swap(net_tcp_time_wait_connections_, other->net_tcp_time_wait_connections_);
  net_traffic_control_statistics_.UnsafeArenaSwap(&other->net_traffic_control_statistics_);
  std::swap(net_snmp_statistics_, other->net_snmp_statistics_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  std::swap(_has_bits_[1], other->_has_bits_[1]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResourceStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceStatistics_descriptor_;
  metadata.reflection = ResourceStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResourceStatistics

// required double timestamp = 1;
bool ResourceStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResourceStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void ResourceStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResourceStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
 double ResourceStatistics::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.timestamp)
  return timestamp_;
}
 void ResourceStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.timestamp)
}

// optional uint32 processes = 30;
bool ResourceStatistics::has_processes() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResourceStatistics::set_has_processes() {
  _has_bits_[0] |= 0x00000002u;
}
void ResourceStatistics::clear_has_processes() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResourceStatistics::clear_processes() {
  processes_ = 0u;
  clear_has_processes();
}
 ::google::protobuf::uint32 ResourceStatistics::processes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.processes)
  return processes_;
}
 void ResourceStatistics::set_processes(::google::protobuf::uint32 value) {
  set_has_processes();
  processes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.processes)
}

// optional uint32 threads = 31;
bool ResourceStatistics::has_threads() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResourceStatistics::set_has_threads() {
  _has_bits_[0] |= 0x00000004u;
}
void ResourceStatistics::clear_has_threads() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResourceStatistics::clear_threads() {
  threads_ = 0u;
  clear_has_threads();
}
 ::google::protobuf::uint32 ResourceStatistics::threads() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.threads)
  return threads_;
}
 void ResourceStatistics::set_threads(::google::protobuf::uint32 value) {
  set_has_threads();
  threads_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.threads)
}

// optional double cpus_user_time_secs = 2;
bool ResourceStatistics::has_cpus_user_time_secs() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResourceStatistics::set_has_cpus_user_time_secs() {
  _has_bits_[0] |= 0x00000008u;
}
void ResourceStatistics::clear_has_cpus_user_time_secs() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResourceStatistics::clear_cpus_user_time_secs() {
  cpus_user_time_secs_ = 0;
  clear_has_cpus_user_time_secs();
}
 double ResourceStatistics::cpus_user_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_user_time_secs)
  return cpus_user_time_secs_;
}
 void ResourceStatistics::set_cpus_user_time_secs(double value) {
  set_has_cpus_user_time_secs();
  cpus_user_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_user_time_secs)
}

// optional double cpus_system_time_secs = 3;
bool ResourceStatistics::has_cpus_system_time_secs() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ResourceStatistics::set_has_cpus_system_time_secs() {
  _has_bits_[0] |= 0x00000010u;
}
void ResourceStatistics::clear_has_cpus_system_time_secs() {
  _has_bits_[0] &= ~0x00000010u;
}
void ResourceStatistics::clear_cpus_system_time_secs() {
  cpus_system_time_secs_ = 0;
  clear_has_cpus_system_time_secs();
}
 double ResourceStatistics::cpus_system_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_system_time_secs)
  return cpus_system_time_secs_;
}
 void ResourceStatistics::set_cpus_system_time_secs(double value) {
  set_has_cpus_system_time_secs();
  cpus_system_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_system_time_secs)
}

// optional double cpus_limit = 4;
bool ResourceStatistics::has_cpus_limit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ResourceStatistics::set_has_cpus_limit() {
  _has_bits_[0] |= 0x00000020u;
}
void ResourceStatistics::clear_has_cpus_limit() {
  _has_bits_[0] &= ~0x00000020u;
}
void ResourceStatistics::clear_cpus_limit() {
  cpus_limit_ = 0;
  clear_has_cpus_limit();
}
 double ResourceStatistics::cpus_limit() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_limit)
  return cpus_limit_;
}
 void ResourceStatistics::set_cpus_limit(double value) {
  set_has_cpus_limit();
  cpus_limit_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_limit)
}

// optional uint32 cpus_nr_periods = 7;
bool ResourceStatistics::has_cpus_nr_periods() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ResourceStatistics::set_has_cpus_nr_periods() {
  _has_bits_[0] |= 0x00000040u;
}
void ResourceStatistics::clear_has_cpus_nr_periods() {
  _has_bits_[0] &= ~0x00000040u;
}
void ResourceStatistics::clear_cpus_nr_periods() {
  cpus_nr_periods_ = 0u;
  clear_has_cpus_nr_periods();
}
 ::google::protobuf::uint32 ResourceStatistics::cpus_nr_periods() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_nr_periods)
  return cpus_nr_periods_;
}
 void ResourceStatistics::set_cpus_nr_periods(::google::protobuf::uint32 value) {
  set_has_cpus_nr_periods();
  cpus_nr_periods_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_nr_periods)
}

// optional uint32 cpus_nr_throttled = 8;
bool ResourceStatistics::has_cpus_nr_throttled() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ResourceStatistics::set_has_cpus_nr_throttled() {
  _has_bits_[0] |= 0x00000080u;
}
void ResourceStatistics::clear_has_cpus_nr_throttled() {
  _has_bits_[0] &= ~0x00000080u;
}
void ResourceStatistics::clear_cpus_nr_throttled() {
  cpus_nr_throttled_ = 0u;
  clear_has_cpus_nr_throttled();
}
 ::google::protobuf::uint32 ResourceStatistics::cpus_nr_throttled() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_nr_throttled)
  return cpus_nr_throttled_;
}
 void ResourceStatistics::set_cpus_nr_throttled(::google::protobuf::uint32 value) {
  set_has_cpus_nr_throttled();
  cpus_nr_throttled_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_nr_throttled)
}

// optional double cpus_throttled_time_secs = 9;
bool ResourceStatistics::has_cpus_throttled_time_secs() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ResourceStatistics::set_has_cpus_throttled_time_secs() {
  _has_bits_[0] |= 0x00000100u;
}
void ResourceStatistics::clear_has_cpus_throttled_time_secs() {
  _has_bits_[0] &= ~0x00000100u;
}
void ResourceStatistics::clear_cpus_throttled_time_secs() {
  cpus_throttled_time_secs_ = 0;
  clear_has_cpus_throttled_time_secs();
}
 double ResourceStatistics::cpus_throttled_time_secs() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.cpus_throttled_time_secs)
  return cpus_throttled_time_secs_;
}
 void ResourceStatistics::set_cpus_throttled_time_secs(double value) {
  set_has_cpus_throttled_time_secs();
  cpus_throttled_time_secs_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.cpus_throttled_time_secs)
}

// optional uint64 mem_total_bytes = 36;
bool ResourceStatistics::has_mem_total_bytes() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void ResourceStatistics::set_has_mem_total_bytes() {
  _has_bits_[0] |= 0x00000200u;
}
void ResourceStatistics::clear_has_mem_total_bytes() {
  _has_bits_[0] &= ~0x00000200u;
}
void ResourceStatistics::clear_mem_total_bytes() {
  mem_total_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_total_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_total_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_total_bytes)
  return mem_total_bytes_;
}
 void ResourceStatistics::set_mem_total_bytes(::google::protobuf::uint64 value) {
  set_has_mem_total_bytes();
  mem_total_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_total_bytes)
}

// optional uint64 mem_total_memsw_bytes = 37;
bool ResourceStatistics::has_mem_total_memsw_bytes() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void ResourceStatistics::set_has_mem_total_memsw_bytes() {
  _has_bits_[0] |= 0x00000400u;
}
void ResourceStatistics::clear_has_mem_total_memsw_bytes() {
  _has_bits_[0] &= ~0x00000400u;
}
void ResourceStatistics::clear_mem_total_memsw_bytes() {
  mem_total_memsw_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_total_memsw_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_total_memsw_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_total_memsw_bytes)
  return mem_total_memsw_bytes_;
}
 void ResourceStatistics::set_mem_total_memsw_bytes(::google::protobuf::uint64 value) {
  set_has_mem_total_memsw_bytes();
  mem_total_memsw_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_total_memsw_bytes)
}

// optional uint64 mem_limit_bytes = 6;
bool ResourceStatistics::has_mem_limit_bytes() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void ResourceStatistics::set_has_mem_limit_bytes() {
  _has_bits_[0] |= 0x00000800u;
}
void ResourceStatistics::clear_has_mem_limit_bytes() {
  _has_bits_[0] &= ~0x00000800u;
}
void ResourceStatistics::clear_mem_limit_bytes() {
  mem_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_limit_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_limit_bytes)
  return mem_limit_bytes_;
}
 void ResourceStatistics::set_mem_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_limit_bytes();
  mem_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_limit_bytes)
}

// optional uint64 mem_soft_limit_bytes = 38;
bool ResourceStatistics::has_mem_soft_limit_bytes() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void ResourceStatistics::set_has_mem_soft_limit_bytes() {
  _has_bits_[0] |= 0x00001000u;
}
void ResourceStatistics::clear_has_mem_soft_limit_bytes() {
  _has_bits_[0] &= ~0x00001000u;
}
void ResourceStatistics::clear_mem_soft_limit_bytes() {
  mem_soft_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_soft_limit_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_soft_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_soft_limit_bytes)
  return mem_soft_limit_bytes_;
}
 void ResourceStatistics::set_mem_soft_limit_bytes(::google::protobuf::uint64 value) {
  set_has_mem_soft_limit_bytes();
  mem_soft_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_soft_limit_bytes)
}

// optional uint64 mem_file_bytes = 10;
bool ResourceStatistics::has_mem_file_bytes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void ResourceStatistics::set_has_mem_file_bytes() {
  _has_bits_[0] |= 0x00002000u;
}
void ResourceStatistics::clear_has_mem_file_bytes() {
  _has_bits_[0] &= ~0x00002000u;
}
void ResourceStatistics::clear_mem_file_bytes() {
  mem_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_file_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_file_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_file_bytes)
  return mem_file_bytes_;
}
 void ResourceStatistics::set_mem_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_file_bytes();
  mem_file_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_file_bytes)
}

// optional uint64 mem_anon_bytes = 11;
bool ResourceStatistics::has_mem_anon_bytes() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void ResourceStatistics::set_has_mem_anon_bytes() {
  _has_bits_[0] |= 0x00004000u;
}
void ResourceStatistics::clear_has_mem_anon_bytes() {
  _has_bits_[0] &= ~0x00004000u;
}
void ResourceStatistics::clear_mem_anon_bytes() {
  mem_anon_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_anon_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_anon_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_anon_bytes)
  return mem_anon_bytes_;
}
 void ResourceStatistics::set_mem_anon_bytes(::google::protobuf::uint64 value) {
  set_has_mem_anon_bytes();
  mem_anon_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_anon_bytes)
}

// optional uint64 mem_cache_bytes = 39;
bool ResourceStatistics::has_mem_cache_bytes() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void ResourceStatistics::set_has_mem_cache_bytes() {
  _has_bits_[0] |= 0x00008000u;
}
void ResourceStatistics::clear_has_mem_cache_bytes() {
  _has_bits_[0] &= ~0x00008000u;
}
void ResourceStatistics::clear_mem_cache_bytes() {
  mem_cache_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_cache_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_cache_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_cache_bytes)
  return mem_cache_bytes_;
}
 void ResourceStatistics::set_mem_cache_bytes(::google::protobuf::uint64 value) {
  set_has_mem_cache_bytes();
  mem_cache_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_cache_bytes)
}

// optional uint64 mem_rss_bytes = 5;
bool ResourceStatistics::has_mem_rss_bytes() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void ResourceStatistics::set_has_mem_rss_bytes() {
  _has_bits_[0] |= 0x00010000u;
}
void ResourceStatistics::clear_has_mem_rss_bytes() {
  _has_bits_[0] &= ~0x00010000u;
}
void ResourceStatistics::clear_mem_rss_bytes() {
  mem_rss_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_rss_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_rss_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_rss_bytes)
  return mem_rss_bytes_;
}
 void ResourceStatistics::set_mem_rss_bytes(::google::protobuf::uint64 value) {
  set_has_mem_rss_bytes();
  mem_rss_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_rss_bytes)
}

// optional uint64 mem_mapped_file_bytes = 12;
bool ResourceStatistics::has_mem_mapped_file_bytes() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void ResourceStatistics::set_has_mem_mapped_file_bytes() {
  _has_bits_[0] |= 0x00020000u;
}
void ResourceStatistics::clear_has_mem_mapped_file_bytes() {
  _has_bits_[0] &= ~0x00020000u;
}
void ResourceStatistics::clear_mem_mapped_file_bytes() {
  mem_mapped_file_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_mapped_file_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_mapped_file_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_mapped_file_bytes)
  return mem_mapped_file_bytes_;
}
 void ResourceStatistics::set_mem_mapped_file_bytes(::google::protobuf::uint64 value) {
  set_has_mem_mapped_file_bytes();
  mem_mapped_file_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_mapped_file_bytes)
}

// optional uint64 mem_swap_bytes = 40;
bool ResourceStatistics::has_mem_swap_bytes() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void ResourceStatistics::set_has_mem_swap_bytes() {
  _has_bits_[0] |= 0x00040000u;
}
void ResourceStatistics::clear_has_mem_swap_bytes() {
  _has_bits_[0] &= ~0x00040000u;
}
void ResourceStatistics::clear_mem_swap_bytes() {
  mem_swap_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_swap_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_swap_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_swap_bytes)
  return mem_swap_bytes_;
}
 void ResourceStatistics::set_mem_swap_bytes(::google::protobuf::uint64 value) {
  set_has_mem_swap_bytes();
  mem_swap_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_swap_bytes)
}

// optional uint64 mem_unevictable_bytes = 41;
bool ResourceStatistics::has_mem_unevictable_bytes() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void ResourceStatistics::set_has_mem_unevictable_bytes() {
  _has_bits_[0] |= 0x00080000u;
}
void ResourceStatistics::clear_has_mem_unevictable_bytes() {
  _has_bits_[0] &= ~0x00080000u;
}
void ResourceStatistics::clear_mem_unevictable_bytes() {
  mem_unevictable_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_unevictable_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_unevictable_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_unevictable_bytes)
  return mem_unevictable_bytes_;
}
 void ResourceStatistics::set_mem_unevictable_bytes(::google::protobuf::uint64 value) {
  set_has_mem_unevictable_bytes();
  mem_unevictable_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_unevictable_bytes)
}

// optional uint64 mem_low_pressure_counter = 32;
bool ResourceStatistics::has_mem_low_pressure_counter() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void ResourceStatistics::set_has_mem_low_pressure_counter() {
  _has_bits_[0] |= 0x00100000u;
}
void ResourceStatistics::clear_has_mem_low_pressure_counter() {
  _has_bits_[0] &= ~0x00100000u;
}
void ResourceStatistics::clear_mem_low_pressure_counter() {
  mem_low_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_low_pressure_counter();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_low_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_low_pressure_counter)
  return mem_low_pressure_counter_;
}
 void ResourceStatistics::set_mem_low_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_low_pressure_counter();
  mem_low_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_low_pressure_counter)
}

// optional uint64 mem_medium_pressure_counter = 33;
bool ResourceStatistics::has_mem_medium_pressure_counter() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void ResourceStatistics::set_has_mem_medium_pressure_counter() {
  _has_bits_[0] |= 0x00200000u;
}
void ResourceStatistics::clear_has_mem_medium_pressure_counter() {
  _has_bits_[0] &= ~0x00200000u;
}
void ResourceStatistics::clear_mem_medium_pressure_counter() {
  mem_medium_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_medium_pressure_counter();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_medium_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_medium_pressure_counter)
  return mem_medium_pressure_counter_;
}
 void ResourceStatistics::set_mem_medium_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_medium_pressure_counter();
  mem_medium_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_medium_pressure_counter)
}

// optional uint64 mem_critical_pressure_counter = 34;
bool ResourceStatistics::has_mem_critical_pressure_counter() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void ResourceStatistics::set_has_mem_critical_pressure_counter() {
  _has_bits_[0] |= 0x00400000u;
}
void ResourceStatistics::clear_has_mem_critical_pressure_counter() {
  _has_bits_[0] &= ~0x00400000u;
}
void ResourceStatistics::clear_mem_critical_pressure_counter() {
  mem_critical_pressure_counter_ = GOOGLE_ULONGLONG(0);
  clear_has_mem_critical_pressure_counter();
}
 ::google::protobuf::uint64 ResourceStatistics::mem_critical_pressure_counter() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.mem_critical_pressure_counter)
  return mem_critical_pressure_counter_;
}
 void ResourceStatistics::set_mem_critical_pressure_counter(::google::protobuf::uint64 value) {
  set_has_mem_critical_pressure_counter();
  mem_critical_pressure_counter_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.mem_critical_pressure_counter)
}

// optional uint64 disk_limit_bytes = 26;
bool ResourceStatistics::has_disk_limit_bytes() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void ResourceStatistics::set_has_disk_limit_bytes() {
  _has_bits_[0] |= 0x00800000u;
}
void ResourceStatistics::clear_has_disk_limit_bytes() {
  _has_bits_[0] &= ~0x00800000u;
}
void ResourceStatistics::clear_disk_limit_bytes() {
  disk_limit_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_limit_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::disk_limit_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_limit_bytes)
  return disk_limit_bytes_;
}
 void ResourceStatistics::set_disk_limit_bytes(::google::protobuf::uint64 value) {
  set_has_disk_limit_bytes();
  disk_limit_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.disk_limit_bytes)
}

// optional uint64 disk_used_bytes = 27;
bool ResourceStatistics::has_disk_used_bytes() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void ResourceStatistics::set_has_disk_used_bytes() {
  _has_bits_[0] |= 0x01000000u;
}
void ResourceStatistics::clear_has_disk_used_bytes() {
  _has_bits_[0] &= ~0x01000000u;
}
void ResourceStatistics::clear_disk_used_bytes() {
  disk_used_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_disk_used_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::disk_used_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.disk_used_bytes)
  return disk_used_bytes_;
}
 void ResourceStatistics::set_disk_used_bytes(::google::protobuf::uint64 value) {
  set_has_disk_used_bytes();
  disk_used_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.disk_used_bytes)
}

// optional .mesos.PerfStatistics perf = 13;
bool ResourceStatistics::has_perf() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void ResourceStatistics::set_has_perf() {
  _has_bits_[0] |= 0x02000000u;
}
void ResourceStatistics::clear_has_perf() {
  _has_bits_[0] &= ~0x02000000u;
}
void ResourceStatistics::clear_perf() {
  if (perf_ != NULL) perf_->::mesos::PerfStatistics::Clear();
  clear_has_perf();
}
const ::mesos::PerfStatistics& ResourceStatistics::perf() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.perf)
  return perf_ != NULL ? *perf_ : *default_instance_->perf_;
}
::mesos::PerfStatistics* ResourceStatistics::mutable_perf() {
  set_has_perf();
  if (perf_ == NULL) {
    perf_ = new ::mesos::PerfStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.perf)
  return perf_;
}
::mesos::PerfStatistics* ResourceStatistics::release_perf() {
  // @@protoc_insertion_point(field_release:mesos.ResourceStatistics.perf)
  clear_has_perf();
  ::mesos::PerfStatistics* temp = perf_;
  perf_ = NULL;
  return temp;
}
void ResourceStatistics::set_allocated_perf(::mesos::PerfStatistics* perf) {
  delete perf_;
  perf_ = perf;
  if (perf) {
    set_has_perf();
  } else {
    clear_has_perf();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.perf)
}

// optional uint64 net_rx_packets = 14;
bool ResourceStatistics::has_net_rx_packets() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void ResourceStatistics::set_has_net_rx_packets() {
  _has_bits_[0] |= 0x04000000u;
}
void ResourceStatistics::clear_has_net_rx_packets() {
  _has_bits_[0] &= ~0x04000000u;
}
void ResourceStatistics::clear_net_rx_packets() {
  net_rx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_packets();
}
 ::google::protobuf::uint64 ResourceStatistics::net_rx_packets() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_packets)
  return net_rx_packets_;
}
 void ResourceStatistics::set_net_rx_packets(::google::protobuf::uint64 value) {
  set_has_net_rx_packets();
  net_rx_packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_packets)
}

// optional uint64 net_rx_bytes = 15;
bool ResourceStatistics::has_net_rx_bytes() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void ResourceStatistics::set_has_net_rx_bytes() {
  _has_bits_[0] |= 0x08000000u;
}
void ResourceStatistics::clear_has_net_rx_bytes() {
  _has_bits_[0] &= ~0x08000000u;
}
void ResourceStatistics::clear_net_rx_bytes() {
  net_rx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::net_rx_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_bytes)
  return net_rx_bytes_;
}
 void ResourceStatistics::set_net_rx_bytes(::google::protobuf::uint64 value) {
  set_has_net_rx_bytes();
  net_rx_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_bytes)
}

// optional uint64 net_rx_errors = 16;
bool ResourceStatistics::has_net_rx_errors() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
void ResourceStatistics::set_has_net_rx_errors() {
  _has_bits_[0] |= 0x10000000u;
}
void ResourceStatistics::clear_has_net_rx_errors() {
  _has_bits_[0] &= ~0x10000000u;
}
void ResourceStatistics::clear_net_rx_errors() {
  net_rx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_errors();
}
 ::google::protobuf::uint64 ResourceStatistics::net_rx_errors() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_errors)
  return net_rx_errors_;
}
 void ResourceStatistics::set_net_rx_errors(::google::protobuf::uint64 value) {
  set_has_net_rx_errors();
  net_rx_errors_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_errors)
}

// optional uint64 net_rx_dropped = 17;
bool ResourceStatistics::has_net_rx_dropped() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
void ResourceStatistics::set_has_net_rx_dropped() {
  _has_bits_[0] |= 0x20000000u;
}
void ResourceStatistics::clear_has_net_rx_dropped() {
  _has_bits_[0] &= ~0x20000000u;
}
void ResourceStatistics::clear_net_rx_dropped() {
  net_rx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_rx_dropped();
}
 ::google::protobuf::uint64 ResourceStatistics::net_rx_dropped() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_rx_dropped)
  return net_rx_dropped_;
}
 void ResourceStatistics::set_net_rx_dropped(::google::protobuf::uint64 value) {
  set_has_net_rx_dropped();
  net_rx_dropped_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_rx_dropped)
}

// optional uint64 net_tx_packets = 18;
bool ResourceStatistics::has_net_tx_packets() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
void ResourceStatistics::set_has_net_tx_packets() {
  _has_bits_[0] |= 0x40000000u;
}
void ResourceStatistics::clear_has_net_tx_packets() {
  _has_bits_[0] &= ~0x40000000u;
}
void ResourceStatistics::clear_net_tx_packets() {
  net_tx_packets_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_packets();
}
 ::google::protobuf::uint64 ResourceStatistics::net_tx_packets() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_packets)
  return net_tx_packets_;
}
 void ResourceStatistics::set_net_tx_packets(::google::protobuf::uint64 value) {
  set_has_net_tx_packets();
  net_tx_packets_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_packets)
}

// optional uint64 net_tx_bytes = 19;
bool ResourceStatistics::has_net_tx_bytes() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
void ResourceStatistics::set_has_net_tx_bytes() {
  _has_bits_[0] |= 0x80000000u;
}
void ResourceStatistics::clear_has_net_tx_bytes() {
  _has_bits_[0] &= ~0x80000000u;
}
void ResourceStatistics::clear_net_tx_bytes() {
  net_tx_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_bytes();
}
 ::google::protobuf::uint64 ResourceStatistics::net_tx_bytes() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_bytes)
  return net_tx_bytes_;
}
 void ResourceStatistics::set_net_tx_bytes(::google::protobuf::uint64 value) {
  set_has_net_tx_bytes();
  net_tx_bytes_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_bytes)
}

// optional uint64 net_tx_errors = 20;
bool ResourceStatistics::has_net_tx_errors() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
void ResourceStatistics::set_has_net_tx_errors() {
  _has_bits_[1] |= 0x00000001u;
}
void ResourceStatistics::clear_has_net_tx_errors() {
  _has_bits_[1] &= ~0x00000001u;
}
void ResourceStatistics::clear_net_tx_errors() {
  net_tx_errors_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_errors();
}
 ::google::protobuf::uint64 ResourceStatistics::net_tx_errors() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_errors)
  return net_tx_errors_;
}
 void ResourceStatistics::set_net_tx_errors(::google::protobuf::uint64 value) {
  set_has_net_tx_errors();
  net_tx_errors_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_errors)
}

// optional uint64 net_tx_dropped = 21;
bool ResourceStatistics::has_net_tx_dropped() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
void ResourceStatistics::set_has_net_tx_dropped() {
  _has_bits_[1] |= 0x00000002u;
}
void ResourceStatistics::clear_has_net_tx_dropped() {
  _has_bits_[1] &= ~0x00000002u;
}
void ResourceStatistics::clear_net_tx_dropped() {
  net_tx_dropped_ = GOOGLE_ULONGLONG(0);
  clear_has_net_tx_dropped();
}
 ::google::protobuf::uint64 ResourceStatistics::net_tx_dropped() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tx_dropped)
  return net_tx_dropped_;
}
 void ResourceStatistics::set_net_tx_dropped(::google::protobuf::uint64 value) {
  set_has_net_tx_dropped();
  net_tx_dropped_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tx_dropped)
}

// optional double net_tcp_rtt_microsecs_p50 = 22;
bool ResourceStatistics::has_net_tcp_rtt_microsecs_p50() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[1] |= 0x00000004u;
}
void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p50() {
  _has_bits_[1] &= ~0x00000004u;
}
void ResourceStatistics::clear_net_tcp_rtt_microsecs_p50() {
  net_tcp_rtt_microsecs_p50_ = 0;
  clear_has_net_tcp_rtt_microsecs_p50();
}
 double ResourceStatistics::net_tcp_rtt_microsecs_p50() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p50)
  return net_tcp_rtt_microsecs_p50_;
}
 void ResourceStatistics::set_net_tcp_rtt_microsecs_p50(double value) {
  set_has_net_tcp_rtt_microsecs_p50();
  net_tcp_rtt_microsecs_p50_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p50)
}

// optional double net_tcp_rtt_microsecs_p90 = 23;
bool ResourceStatistics::has_net_tcp_rtt_microsecs_p90() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[1] |= 0x00000008u;
}
void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p90() {
  _has_bits_[1] &= ~0x00000008u;
}
void ResourceStatistics::clear_net_tcp_rtt_microsecs_p90() {
  net_tcp_rtt_microsecs_p90_ = 0;
  clear_has_net_tcp_rtt_microsecs_p90();
}
 double ResourceStatistics::net_tcp_rtt_microsecs_p90() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p90)
  return net_tcp_rtt_microsecs_p90_;
}
 void ResourceStatistics::set_net_tcp_rtt_microsecs_p90(double value) {
  set_has_net_tcp_rtt_microsecs_p90();
  net_tcp_rtt_microsecs_p90_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p90)
}

// optional double net_tcp_rtt_microsecs_p95 = 24;
bool ResourceStatistics::has_net_tcp_rtt_microsecs_p95() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[1] |= 0x00000010u;
}
void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p95() {
  _has_bits_[1] &= ~0x00000010u;
}
void ResourceStatistics::clear_net_tcp_rtt_microsecs_p95() {
  net_tcp_rtt_microsecs_p95_ = 0;
  clear_has_net_tcp_rtt_microsecs_p95();
}
 double ResourceStatistics::net_tcp_rtt_microsecs_p95() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p95)
  return net_tcp_rtt_microsecs_p95_;
}
 void ResourceStatistics::set_net_tcp_rtt_microsecs_p95(double value) {
  set_has_net_tcp_rtt_microsecs_p95();
  net_tcp_rtt_microsecs_p95_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p95)
}

// optional double net_tcp_rtt_microsecs_p99 = 25;
bool ResourceStatistics::has_net_tcp_rtt_microsecs_p99() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
void ResourceStatistics::set_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[1] |= 0x00000020u;
}
void ResourceStatistics::clear_has_net_tcp_rtt_microsecs_p99() {
  _has_bits_[1] &= ~0x00000020u;
}
void ResourceStatistics::clear_net_tcp_rtt_microsecs_p99() {
  net_tcp_rtt_microsecs_p99_ = 0;
  clear_has_net_tcp_rtt_microsecs_p99();
}
 double ResourceStatistics::net_tcp_rtt_microsecs_p99() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p99)
  return net_tcp_rtt_microsecs_p99_;
}
 void ResourceStatistics::set_net_tcp_rtt_microsecs_p99(double value) {
  set_has_net_tcp_rtt_microsecs_p99();
  net_tcp_rtt_microsecs_p99_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_rtt_microsecs_p99)
}

// optional double net_tcp_active_connections = 28;
bool ResourceStatistics::has_net_tcp_active_connections() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
void ResourceStatistics::set_has_net_tcp_active_connections() {
  _has_bits_[1] |= 0x00000040u;
}
void ResourceStatistics::clear_has_net_tcp_active_connections() {
  _has_bits_[1] &= ~0x00000040u;
}
void ResourceStatistics::clear_net_tcp_active_connections() {
  net_tcp_active_connections_ = 0;
  clear_has_net_tcp_active_connections();
}
 double ResourceStatistics::net_tcp_active_connections() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_active_connections)
  return net_tcp_active_connections_;
}
 void ResourceStatistics::set_net_tcp_active_connections(double value) {
  set_has_net_tcp_active_connections();
  net_tcp_active_connections_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_active_connections)
}

// optional double net_tcp_time_wait_connections = 29;
bool ResourceStatistics::has_net_tcp_time_wait_connections() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
void ResourceStatistics::set_has_net_tcp_time_wait_connections() {
  _has_bits_[1] |= 0x00000080u;
}
void ResourceStatistics::clear_has_net_tcp_time_wait_connections() {
  _has_bits_[1] &= ~0x00000080u;
}
void ResourceStatistics::clear_net_tcp_time_wait_connections() {
  net_tcp_time_wait_connections_ = 0;
  clear_has_net_tcp_time_wait_connections();
}
 double ResourceStatistics::net_tcp_time_wait_connections() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_tcp_time_wait_connections)
  return net_tcp_time_wait_connections_;
}
 void ResourceStatistics::set_net_tcp_time_wait_connections(double value) {
  set_has_net_tcp_time_wait_connections();
  net_tcp_time_wait_connections_ = value;
  // @@protoc_insertion_point(field_set:mesos.ResourceStatistics.net_tcp_time_wait_connections)
}

// repeated .mesos.TrafficControlStatistics net_traffic_control_statistics = 35;
int ResourceStatistics::net_traffic_control_statistics_size() const {
  return net_traffic_control_statistics_.size();
}
void ResourceStatistics::clear_net_traffic_control_statistics() {
  net_traffic_control_statistics_.Clear();
}
const ::mesos::TrafficControlStatistics& ResourceStatistics::net_traffic_control_statistics(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Get(index);
}
::mesos::TrafficControlStatistics* ResourceStatistics::mutable_net_traffic_control_statistics(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Mutable(index);
}
::mesos::TrafficControlStatistics* ResourceStatistics::add_net_traffic_control_statistics() {
  // @@protoc_insertion_point(field_add:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >*
ResourceStatistics::mutable_net_traffic_control_statistics() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceStatistics.net_traffic_control_statistics)
  return &net_traffic_control_statistics_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::TrafficControlStatistics >&
ResourceStatistics::net_traffic_control_statistics() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceStatistics.net_traffic_control_statistics)
  return net_traffic_control_statistics_;
}

// optional .mesos.SNMPStatistics net_snmp_statistics = 42;
bool ResourceStatistics::has_net_snmp_statistics() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
void ResourceStatistics::set_has_net_snmp_statistics() {
  _has_bits_[1] |= 0x00000200u;
}
void ResourceStatistics::clear_has_net_snmp_statistics() {
  _has_bits_[1] &= ~0x00000200u;
}
void ResourceStatistics::clear_net_snmp_statistics() {
  if (net_snmp_statistics_ != NULL) net_snmp_statistics_->::mesos::SNMPStatistics::Clear();
  clear_has_net_snmp_statistics();
}
const ::mesos::SNMPStatistics& ResourceStatistics::net_snmp_statistics() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceStatistics.net_snmp_statistics)
  return net_snmp_statistics_ != NULL ? *net_snmp_statistics_ : *default_instance_->net_snmp_statistics_;
}
::mesos::SNMPStatistics* ResourceStatistics::mutable_net_snmp_statistics() {
  set_has_net_snmp_statistics();
  if (net_snmp_statistics_ == NULL) {
    net_snmp_statistics_ = new ::mesos::SNMPStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceStatistics.net_snmp_statistics)
  return net_snmp_statistics_;
}
::mesos::SNMPStatistics* ResourceStatistics::release_net_snmp_statistics() {
  // @@protoc_insertion_point(field_release:mesos.ResourceStatistics.net_snmp_statistics)
  clear_has_net_snmp_statistics();
  ::mesos::SNMPStatistics* temp = net_snmp_statistics_;
  net_snmp_statistics_ = NULL;
  return temp;
}
void ResourceStatistics::set_allocated_net_snmp_statistics(::mesos::SNMPStatistics* net_snmp_statistics) {
  delete net_snmp_statistics_;
  net_snmp_statistics_ = net_snmp_statistics;
  if (net_snmp_statistics) {
    set_has_net_snmp_statistics();
  } else {
    clear_has_net_snmp_statistics();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceStatistics.net_snmp_statistics)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResourceUsage_Executor_Task::kNameFieldNumber;
const int ResourceUsage_Executor_Task::kIdFieldNumber;
const int ResourceUsage_Executor_Task::kResourcesFieldNumber;
const int ResourceUsage_Executor_Task::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResourceUsage_Executor_Task::ResourceUsage_Executor_Task()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceUsage.Executor.Task)
}

void ResourceUsage_Executor_Task::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

ResourceUsage_Executor_Task::ResourceUsage_Executor_Task(const ResourceUsage_Executor_Task& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceUsage.Executor.Task)
}

void ResourceUsage_Executor_Task::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = NULL;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceUsage_Executor_Task::~ResourceUsage_Executor_Task() {
  // @@protoc_insertion_point(destructor:mesos.ResourceUsage.Executor.Task)
  SharedDtor();
}

void ResourceUsage_Executor_Task::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete id_;
    delete labels_;
  }
}

void ResourceUsage_Executor_Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceUsage_Executor_Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceUsage_Executor_Task_descriptor_;
}

const ResourceUsage_Executor_Task& ResourceUsage_Executor_Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceUsage_Executor_Task* ResourceUsage_Executor_Task::default_instance_ = NULL;

ResourceUsage_Executor_Task* ResourceUsage_Executor_Task::New(::google::protobuf::Arena* arena) const {
  ResourceUsage_Executor_Task* n = new ResourceUsage_Executor_Task;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResourceUsage_Executor_Task::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ResourceUsage.Executor.Task)
  if (_has_bits_[0 / 32] & 11u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::TaskID::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResourceUsage_Executor_Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceUsage.Executor.Task)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ResourceUsage.Executor.Task.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // required .mesos.TaskID id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 3;
      case 3: {
        if (tag == 26) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(34)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 4;
      case 4: {
        if (tag == 34) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceUsage.Executor.Task)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceUsage.Executor.Task)
  return false;
#undef DO_
}

void ResourceUsage_Executor_Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceUsage.Executor.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ResourceUsage.Executor.Task.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.TaskID id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->id_, output);
  }

  // repeated .mesos.Resource resources = 3;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->resources(i), output);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->labels_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceUsage.Executor.Task)
}

::google::protobuf::uint8* ResourceUsage_Executor_Task::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceUsage.Executor.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ResourceUsage.Executor.Task.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID id = 2;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->id_, false, target);
  }

  // repeated .mesos.Resource resources = 3;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->resources(i), false, target);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->labels_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceUsage.Executor.Task)
  return target;
}

int ResourceUsage_Executor_Task::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.ResourceUsage.Executor.Task)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_id()) {
    // required .mesos.TaskID id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }

  return total_size;
}
int ResourceUsage_Executor_Task::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ResourceUsage.Executor.Task)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required .mesos.TaskID id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->labels_);
  }

  // repeated .mesos.Resource resources = 3;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceUsage_Executor_Task::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ResourceUsage.Executor.Task)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ResourceUsage_Executor_Task* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResourceUsage_Executor_Task>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ResourceUsage.Executor.Task)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ResourceUsage.Executor.Task)
    MergeFrom(*source);
  }
}

void ResourceUsage_Executor_Task::MergeFrom(const ResourceUsage_Executor_Task& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ResourceUsage.Executor.Task)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_id()) {
      mutable_id()->::mesos::TaskID::MergeFrom(from.id());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResourceUsage_Executor_Task::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ResourceUsage.Executor.Task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceUsage_Executor_Task::CopyFrom(const ResourceUsage_Executor_Task& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ResourceUsage.Executor.Task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceUsage_Executor_Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void ResourceUsage_Executor_Task::Swap(ResourceUsage_Executor_Task* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResourceUsage_Executor_Task::InternalSwap(ResourceUsage_Executor_Task* other) {
  name_.Swap(&other->name_);
  std::swap(id_, other->id_);
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResourceUsage_Executor_Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceUsage_Executor_Task_descriptor_;
  metadata.reflection = ResourceUsage_Executor_Task_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResourceUsage_Executor::kExecutorInfoFieldNumber;
const int ResourceUsage_Executor::kAllocatedFieldNumber;
const int ResourceUsage_Executor::kStatisticsFieldNumber;
const int ResourceUsage_Executor::kContainerIdFieldNumber;
const int ResourceUsage_Executor::kTasksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResourceUsage_Executor::ResourceUsage_Executor()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceUsage.Executor)
}

void ResourceUsage_Executor::InitAsDefaultInstance() {
  executor_info_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  statistics_ = const_cast< ::mesos::ResourceStatistics*>(&::mesos::ResourceStatistics::default_instance());
  container_id_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
}

ResourceUsage_Executor::ResourceUsage_Executor(const ResourceUsage_Executor& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceUsage.Executor)
}

void ResourceUsage_Executor::SharedCtor() {
  _cached_size_ = 0;
  executor_info_ = NULL;
  statistics_ = NULL;
  container_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceUsage_Executor::~ResourceUsage_Executor() {
  // @@protoc_insertion_point(destructor:mesos.ResourceUsage.Executor)
  SharedDtor();
}

void ResourceUsage_Executor::SharedDtor() {
  if (this != default_instance_) {
    delete executor_info_;
    delete statistics_;
    delete container_id_;
  }
}

void ResourceUsage_Executor::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceUsage_Executor::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceUsage_Executor_descriptor_;
}

const ResourceUsage_Executor& ResourceUsage_Executor::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceUsage_Executor* ResourceUsage_Executor::default_instance_ = NULL;

ResourceUsage_Executor* ResourceUsage_Executor::New(::google::protobuf::Arena* arena) const {
  ResourceUsage_Executor* n = new ResourceUsage_Executor;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResourceUsage_Executor::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ResourceUsage.Executor)
  if (_has_bits_[0 / 32] & 13u) {
    if (has_executor_info()) {
      if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
    }
    if (has_statistics()) {
      if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
    }
    if (has_container_id()) {
      if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
    }
  }
  allocated_.Clear();
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResourceUsage_Executor::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceUsage.Executor)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorInfo executor_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_allocated;
        break;
      }

      // repeated .mesos.Resource allocated = 2;
      case 2: {
        if (tag == 18) {
         parse_allocated:
          DO_(input->IncrementRecursionDepth());
         parse_loop_allocated:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_allocated()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_allocated;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(26)) goto parse_statistics;
        break;
      }

      // optional .mesos.ResourceStatistics statistics = 3;
      case 3: {
        if (tag == 26) {
         parse_statistics:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_statistics()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_container_id;
        break;
      }

      // required .mesos.ContainerID container_id = 4;
      case 4: {
        if (tag == 34) {
         parse_container_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_tasks;
        break;
      }

      // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
      case 5: {
        if (tag == 42) {
         parse_tasks:
          DO_(input->IncrementRecursionDepth());
         parse_loop_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_tasks;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceUsage.Executor)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceUsage.Executor)
  return false;
#undef DO_
}

void ResourceUsage_Executor::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceUsage.Executor)
  // required .mesos.ExecutorInfo executor_info = 1;
  if (has_executor_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->executor_info_, output);
  }

  // repeated .mesos.Resource allocated = 2;
  for (unsigned int i = 0, n = this->allocated_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->allocated(i), output);
  }

  // optional .mesos.ResourceStatistics statistics = 3;
  if (has_statistics()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->statistics_, output);
  }

  // required .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->container_id_, output);
  }

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  for (unsigned int i = 0, n = this->tasks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->tasks(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceUsage.Executor)
}

::google::protobuf::uint8* ResourceUsage_Executor::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceUsage.Executor)
  // required .mesos.ExecutorInfo executor_info = 1;
  if (has_executor_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->executor_info_, false, target);
  }

  // repeated .mesos.Resource allocated = 2;
  for (unsigned int i = 0, n = this->allocated_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->allocated(i), false, target);
  }

  // optional .mesos.ResourceStatistics statistics = 3;
  if (has_statistics()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->statistics_, false, target);
  }

  // required .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->container_id_, false, target);
  }

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  for (unsigned int i = 0, n = this->tasks_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->tasks(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceUsage.Executor)
  return target;
}

int ResourceUsage_Executor::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.ResourceUsage.Executor)
  int total_size = 0;

  if (has_executor_info()) {
    // required .mesos.ExecutorInfo executor_info = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->executor_info_);
  }

  if (has_container_id()) {
    // required .mesos.ContainerID container_id = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->container_id_);
  }

  return total_size;
}
int ResourceUsage_Executor::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ResourceUsage.Executor)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000009) ^ 0x00000009) == 0) {  // All required fields are present.
    // required .mesos.ExecutorInfo executor_info = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->executor_info_);

    // required .mesos.ContainerID container_id = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->container_id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .mesos.ResourceStatistics statistics = 3;
  if (has_statistics()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->statistics_);
  }

  // repeated .mesos.Resource allocated = 2;
  total_size += 1 * this->allocated_size();
  for (int i = 0; i < this->allocated_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->allocated(i));
  }

  // repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceUsage_Executor::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ResourceUsage.Executor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ResourceUsage_Executor* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResourceUsage_Executor>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ResourceUsage.Executor)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ResourceUsage.Executor)
    MergeFrom(*source);
  }
}

void ResourceUsage_Executor::MergeFrom(const ResourceUsage_Executor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ResourceUsage.Executor)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  allocated_.MergeFrom(from.allocated_);
  tasks_.MergeFrom(from.tasks_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor_info()) {
      mutable_executor_info()->::mesos::ExecutorInfo::MergeFrom(from.executor_info());
    }
    if (from.has_statistics()) {
      mutable_statistics()->::mesos::ResourceStatistics::MergeFrom(from.statistics());
    }
    if (from.has_container_id()) {
      mutable_container_id()->::mesos::ContainerID::MergeFrom(from.container_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResourceUsage_Executor::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ResourceUsage.Executor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceUsage_Executor::CopyFrom(const ResourceUsage_Executor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ResourceUsage.Executor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceUsage_Executor::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000009) != 0x00000009) return false;

  if (has_executor_info()) {
    if (!this->executor_info_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->allocated())) return false;
  if (has_statistics()) {
    if (!this->statistics_->IsInitialized()) return false;
  }
  if (has_container_id()) {
    if (!this->container_id_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void ResourceUsage_Executor::Swap(ResourceUsage_Executor* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResourceUsage_Executor::InternalSwap(ResourceUsage_Executor* other) {
  std::swap(executor_info_, other->executor_info_);
  allocated_.UnsafeArenaSwap(&other->allocated_);
  std::swap(statistics_, other->statistics_);
  std::swap(container_id_, other->container_id_);
  tasks_.UnsafeArenaSwap(&other->tasks_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResourceUsage_Executor::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceUsage_Executor_descriptor_;
  metadata.reflection = ResourceUsage_Executor_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ResourceUsage::kExecutorsFieldNumber;
const int ResourceUsage::kTotalFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ResourceUsage::ResourceUsage()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ResourceUsage)
}

void ResourceUsage::InitAsDefaultInstance() {
}

ResourceUsage::ResourceUsage(const ResourceUsage& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ResourceUsage)
}

void ResourceUsage::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResourceUsage::~ResourceUsage() {
  // @@protoc_insertion_point(destructor:mesos.ResourceUsage)
  SharedDtor();
}

void ResourceUsage::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResourceUsage::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResourceUsage::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResourceUsage_descriptor_;
}

const ResourceUsage& ResourceUsage::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ResourceUsage* ResourceUsage::default_instance_ = NULL;

ResourceUsage* ResourceUsage::New(::google::protobuf::Arena* arena) const {
  ResourceUsage* n = new ResourceUsage;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ResourceUsage::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ResourceUsage)
  executors_.Clear();
  total_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ResourceUsage::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ResourceUsage)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.ResourceUsage.Executor executors = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_executors:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_executors()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_executors;
        if (input->ExpectTag(18)) goto parse_loop_total;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mesos.Resource total = 2;
      case 2: {
        if (tag == 18) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_total:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_total()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_total;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ResourceUsage)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ResourceUsage)
  return false;
#undef DO_
}

void ResourceUsage::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ResourceUsage)
  // repeated .mesos.ResourceUsage.Executor executors = 1;
  for (unsigned int i = 0, n = this->executors_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->executors(i), output);
  }

  // repeated .mesos.Resource total = 2;
  for (unsigned int i = 0, n = this->total_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->total(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ResourceUsage)
}

::google::protobuf::uint8* ResourceUsage::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ResourceUsage)
  // repeated .mesos.ResourceUsage.Executor executors = 1;
  for (unsigned int i = 0, n = this->executors_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->executors(i), false, target);
  }

  // repeated .mesos.Resource total = 2;
  for (unsigned int i = 0, n = this->total_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->total(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ResourceUsage)
  return target;
}

int ResourceUsage::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ResourceUsage)
  int total_size = 0;

  // repeated .mesos.ResourceUsage.Executor executors = 1;
  total_size += 1 * this->executors_size();
  for (int i = 0; i < this->executors_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->executors(i));
  }

  // repeated .mesos.Resource total = 2;
  total_size += 1 * this->total_size();
  for (int i = 0; i < this->total_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->total(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResourceUsage::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ResourceUsage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ResourceUsage* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ResourceUsage>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ResourceUsage)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ResourceUsage)
    MergeFrom(*source);
  }
}

void ResourceUsage::MergeFrom(const ResourceUsage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ResourceUsage)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  executors_.MergeFrom(from.executors_);
  total_.MergeFrom(from.total_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ResourceUsage::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ResourceUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResourceUsage::CopyFrom(const ResourceUsage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ResourceUsage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResourceUsage::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->executors())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->total())) return false;
  return true;
}

void ResourceUsage::Swap(ResourceUsage* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ResourceUsage::InternalSwap(ResourceUsage* other) {
  executors_.UnsafeArenaSwap(&other->executors_);
  total_.UnsafeArenaSwap(&other->total_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ResourceUsage::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResourceUsage_descriptor_;
  metadata.reflection = ResourceUsage_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ResourceUsage_Executor_Task

// required string name = 1;
bool ResourceUsage_Executor_Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResourceUsage_Executor_Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void ResourceUsage_Executor_Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResourceUsage_Executor_Task::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& ResourceUsage_Executor_Task::name() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ResourceUsage_Executor_Task::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ResourceUsage.Executor.Task.name)
}
 void ResourceUsage_Executor_Task::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ResourceUsage.Executor.Task.name)
}
 void ResourceUsage_Executor_Task::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ResourceUsage.Executor.Task.name)
}
 ::std::string* ResourceUsage_Executor_Task::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ResourceUsage_Executor_Task::release_name() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.Task.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ResourceUsage_Executor_Task::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.name)
}

// required .mesos.TaskID id = 2;
bool ResourceUsage_Executor_Task::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ResourceUsage_Executor_Task::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
void ResourceUsage_Executor_Task::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void ResourceUsage_Executor_Task::clear_id() {
  if (id_ != NULL) id_->::mesos::TaskID::Clear();
  clear_has_id();
}
const ::mesos::TaskID& ResourceUsage_Executor_Task::id() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::mesos::TaskID* ResourceUsage_Executor_Task::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::mesos::TaskID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.id)
  return id_;
}
::mesos::TaskID* ResourceUsage_Executor_Task::release_id() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.Task.id)
  clear_has_id();
  ::mesos::TaskID* temp = id_;
  id_ = NULL;
  return temp;
}
void ResourceUsage_Executor_Task::set_allocated_id(::mesos::TaskID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.id)
}

// repeated .mesos.Resource resources = 3;
int ResourceUsage_Executor_Task::resources_size() const {
  return resources_.size();
}
void ResourceUsage_Executor_Task::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& ResourceUsage_Executor_Task::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Get(index);
}
::mesos::Resource* ResourceUsage_Executor_Task::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* ResourceUsage_Executor_Task::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.Task.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage_Executor_Task::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.Task.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage_Executor_Task::resources() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.Task.resources)
  return resources_;
}

// optional .mesos.Labels labels = 4;
bool ResourceUsage_Executor_Task::has_labels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResourceUsage_Executor_Task::set_has_labels() {
  _has_bits_[0] |= 0x00000008u;
}
void ResourceUsage_Executor_Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResourceUsage_Executor_Task::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& ResourceUsage_Executor_Task::labels() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.Task.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* ResourceUsage_Executor_Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.Task.labels)
  return labels_;
}
::mesos::Labels* ResourceUsage_Executor_Task::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.Task.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void ResourceUsage_Executor_Task::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.Task.labels)
}

// -------------------------------------------------------------------

// ResourceUsage_Executor

// required .mesos.ExecutorInfo executor_info = 1;
bool ResourceUsage_Executor::has_executor_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ResourceUsage_Executor::set_has_executor_info() {
  _has_bits_[0] |= 0x00000001u;
}
void ResourceUsage_Executor::clear_has_executor_info() {
  _has_bits_[0] &= ~0x00000001u;
}
void ResourceUsage_Executor::clear_executor_info() {
  if (executor_info_ != NULL) executor_info_->::mesos::ExecutorInfo::Clear();
  clear_has_executor_info();
}
const ::mesos::ExecutorInfo& ResourceUsage_Executor::executor_info() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.executor_info)
  return executor_info_ != NULL ? *executor_info_ : *default_instance_->executor_info_;
}
::mesos::ExecutorInfo* ResourceUsage_Executor::mutable_executor_info() {
  set_has_executor_info();
  if (executor_info_ == NULL) {
    executor_info_ = new ::mesos::ExecutorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.executor_info)
  return executor_info_;
}
::mesos::ExecutorInfo* ResourceUsage_Executor::release_executor_info() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.executor_info)
  clear_has_executor_info();
  ::mesos::ExecutorInfo* temp = executor_info_;
  executor_info_ = NULL;
  return temp;
}
void ResourceUsage_Executor::set_allocated_executor_info(::mesos::ExecutorInfo* executor_info) {
  delete executor_info_;
  executor_info_ = executor_info;
  if (executor_info) {
    set_has_executor_info();
  } else {
    clear_has_executor_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.executor_info)
}

// repeated .mesos.Resource allocated = 2;
int ResourceUsage_Executor::allocated_size() const {
  return allocated_.size();
}
void ResourceUsage_Executor::clear_allocated() {
  allocated_.Clear();
}
const ::mesos::Resource& ResourceUsage_Executor::allocated(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Get(index);
}
::mesos::Resource* ResourceUsage_Executor::mutable_allocated(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Mutable(index);
}
::mesos::Resource* ResourceUsage_Executor::add_allocated() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.allocated)
  return allocated_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage_Executor::mutable_allocated() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.allocated)
  return &allocated_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage_Executor::allocated() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.allocated)
  return allocated_;
}

// optional .mesos.ResourceStatistics statistics = 3;
bool ResourceUsage_Executor::has_statistics() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ResourceUsage_Executor::set_has_statistics() {
  _has_bits_[0] |= 0x00000004u;
}
void ResourceUsage_Executor::clear_has_statistics() {
  _has_bits_[0] &= ~0x00000004u;
}
void ResourceUsage_Executor::clear_statistics() {
  if (statistics_ != NULL) statistics_->::mesos::ResourceStatistics::Clear();
  clear_has_statistics();
}
const ::mesos::ResourceStatistics& ResourceUsage_Executor::statistics() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.statistics)
  return statistics_ != NULL ? *statistics_ : *default_instance_->statistics_;
}
::mesos::ResourceStatistics* ResourceUsage_Executor::mutable_statistics() {
  set_has_statistics();
  if (statistics_ == NULL) {
    statistics_ = new ::mesos::ResourceStatistics;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.statistics)
  return statistics_;
}
::mesos::ResourceStatistics* ResourceUsage_Executor::release_statistics() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.statistics)
  clear_has_statistics();
  ::mesos::ResourceStatistics* temp = statistics_;
  statistics_ = NULL;
  return temp;
}
void ResourceUsage_Executor::set_allocated_statistics(::mesos::ResourceStatistics* statistics) {
  delete statistics_;
  statistics_ = statistics;
  if (statistics) {
    set_has_statistics();
  } else {
    clear_has_statistics();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.statistics)
}

// required .mesos.ContainerID container_id = 4;
bool ResourceUsage_Executor::has_container_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ResourceUsage_Executor::set_has_container_id() {
  _has_bits_[0] |= 0x00000008u;
}
void ResourceUsage_Executor::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void ResourceUsage_Executor::clear_container_id() {
  if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
  clear_has_container_id();
}
const ::mesos::ContainerID& ResourceUsage_Executor::container_id() const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.container_id)
  return container_id_ != NULL ? *container_id_ : *default_instance_->container_id_;
}
::mesos::ContainerID* ResourceUsage_Executor::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.container_id)
  return container_id_;
}
::mesos::ContainerID* ResourceUsage_Executor::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.ResourceUsage.Executor.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
void ResourceUsage_Executor::set_allocated_container_id(::mesos::ContainerID* container_id) {
  delete container_id_;
  container_id_ = container_id;
  if (container_id) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ResourceUsage.Executor.container_id)
}

// repeated .mesos.ResourceUsage.Executor.Task tasks = 5;
int ResourceUsage_Executor::tasks_size() const {
  return tasks_.size();
}
void ResourceUsage_Executor::clear_tasks() {
  tasks_.Clear();
}
const ::mesos::ResourceUsage_Executor_Task& ResourceUsage_Executor::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Get(index);
}
::mesos::ResourceUsage_Executor_Task* ResourceUsage_Executor::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Mutable(index);
}
::mesos::ResourceUsage_Executor_Task* ResourceUsage_Executor::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.Executor.tasks)
  return tasks_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >*
ResourceUsage_Executor::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.Executor.tasks)
  return &tasks_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor_Task >&
ResourceUsage_Executor::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.Executor.tasks)
  return tasks_;
}

// -------------------------------------------------------------------

// ResourceUsage

// repeated .mesos.ResourceUsage.Executor executors = 1;
int ResourceUsage::executors_size() const {
  return executors_.size();
}
void ResourceUsage::clear_executors() {
  executors_.Clear();
}
const ::mesos::ResourceUsage_Executor& ResourceUsage::executors(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.executors)
  return executors_.Get(index);
}
::mesos::ResourceUsage_Executor* ResourceUsage::mutable_executors(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.executors)
  return executors_.Mutable(index);
}
::mesos::ResourceUsage_Executor* ResourceUsage::add_executors() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.executors)
  return executors_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >*
ResourceUsage::mutable_executors() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.executors)
  return &executors_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::ResourceUsage_Executor >&
ResourceUsage::executors() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.executors)
  return executors_;
}

// repeated .mesos.Resource total = 2;
int ResourceUsage::total_size() const {
  return total_.size();
}
void ResourceUsage::clear_total() {
  total_.Clear();
}
const ::mesos::Resource& ResourceUsage::total(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ResourceUsage.total)
  return total_.Get(index);
}
::mesos::Resource* ResourceUsage::mutable_total(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ResourceUsage.total)
  return total_.Mutable(index);
}
::mesos::Resource* ResourceUsage::add_total() {
  // @@protoc_insertion_point(field_add:mesos.ResourceUsage.total)
  return total_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
ResourceUsage::mutable_total() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ResourceUsage.total)
  return &total_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
ResourceUsage::total() const {
  // @@protoc_insertion_point(field_list:mesos.ResourceUsage.total)
  return total_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PerfStatistics::kTimestampFieldNumber;
const int PerfStatistics::kDurationFieldNumber;
const int PerfStatistics::kCyclesFieldNumber;
const int PerfStatistics::kStalledCyclesFrontendFieldNumber;
const int PerfStatistics::kStalledCyclesBackendFieldNumber;
const int PerfStatistics::kInstructionsFieldNumber;
const int PerfStatistics::kCacheReferencesFieldNumber;
const int PerfStatistics::kCacheMissesFieldNumber;
const int PerfStatistics::kBranchesFieldNumber;
const int PerfStatistics::kBranchMissesFieldNumber;
const int PerfStatistics::kBusCyclesFieldNumber;
const int PerfStatistics::kRefCyclesFieldNumber;
const int PerfStatistics::kCpuClockFieldNumber;
const int PerfStatistics::kTaskClockFieldNumber;
const int PerfStatistics::kPageFaultsFieldNumber;
const int PerfStatistics::kMinorFaultsFieldNumber;
const int PerfStatistics::kMajorFaultsFieldNumber;
const int PerfStatistics::kContextSwitchesFieldNumber;
const int PerfStatistics::kCpuMigrationsFieldNumber;
const int PerfStatistics::kAlignmentFaultsFieldNumber;
const int PerfStatistics::kEmulationFaultsFieldNumber;
const int PerfStatistics::kL1DcacheLoadsFieldNumber;
const int PerfStatistics::kL1DcacheLoadMissesFieldNumber;
const int PerfStatistics::kL1DcacheStoresFieldNumber;
const int PerfStatistics::kL1DcacheStoreMissesFieldNumber;
const int PerfStatistics::kL1DcachePrefetchesFieldNumber;
const int PerfStatistics::kL1DcachePrefetchMissesFieldNumber;
const int PerfStatistics::kL1IcacheLoadsFieldNumber;
const int PerfStatistics::kL1IcacheLoadMissesFieldNumber;
const int PerfStatistics::kL1IcachePrefetchesFieldNumber;
const int PerfStatistics::kL1IcachePrefetchMissesFieldNumber;
const int PerfStatistics::kLlcLoadsFieldNumber;
const int PerfStatistics::kLlcLoadMissesFieldNumber;
const int PerfStatistics::kLlcStoresFieldNumber;
const int PerfStatistics::kLlcStoreMissesFieldNumber;
const int PerfStatistics::kLlcPrefetchesFieldNumber;
const int PerfStatistics::kLlcPrefetchMissesFieldNumber;
const int PerfStatistics::kDtlbLoadsFieldNumber;
const int PerfStatistics::kDtlbLoadMissesFieldNumber;
const int PerfStatistics::kDtlbStoresFieldNumber;
const int PerfStatistics::kDtlbStoreMissesFieldNumber;
const int PerfStatistics::kDtlbPrefetchesFieldNumber;
const int PerfStatistics::kDtlbPrefetchMissesFieldNumber;
const int PerfStatistics::kItlbLoadsFieldNumber;
const int PerfStatistics::kItlbLoadMissesFieldNumber;
const int PerfStatistics::kBranchLoadsFieldNumber;
const int PerfStatistics::kBranchLoadMissesFieldNumber;
const int PerfStatistics::kNodeLoadsFieldNumber;
const int PerfStatistics::kNodeLoadMissesFieldNumber;
const int PerfStatistics::kNodeStoresFieldNumber;
const int PerfStatistics::kNodeStoreMissesFieldNumber;
const int PerfStatistics::kNodePrefetchesFieldNumber;
const int PerfStatistics::kNodePrefetchMissesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PerfStatistics::PerfStatistics()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.PerfStatistics)
}

void PerfStatistics::InitAsDefaultInstance() {
}

PerfStatistics::PerfStatistics(const PerfStatistics& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.PerfStatistics)
}

void PerfStatistics::SharedCtor() {
  _cached_size_ = 0;
  timestamp_ = 0;
  duration_ = 0;
  cycles_ = GOOGLE_ULONGLONG(0);
  stalled_cycles_frontend_ = GOOGLE_ULONGLONG(0);
  stalled_cycles_backend_ = GOOGLE_ULONGLONG(0);
  instructions_ = GOOGLE_ULONGLONG(0);
  cache_references_ = GOOGLE_ULONGLONG(0);
  cache_misses_ = GOOGLE_ULONGLONG(0);
  branches_ = GOOGLE_ULONGLONG(0);
  branch_misses_ = GOOGLE_ULONGLONG(0);
  bus_cycles_ = GOOGLE_ULONGLONG(0);
  ref_cycles_ = GOOGLE_ULONGLONG(0);
  cpu_clock_ = 0;
  task_clock_ = 0;
  page_faults_ = GOOGLE_ULONGLONG(0);
  minor_faults_ = GOOGLE_ULONGLONG(0);
  major_faults_ = GOOGLE_ULONGLONG(0);
  context_switches_ = GOOGLE_ULONGLONG(0);
  cpu_migrations_ = GOOGLE_ULONGLONG(0);
  alignment_faults_ = GOOGLE_ULONGLONG(0);
  emulation_faults_ = GOOGLE_ULONGLONG(0);
  l1_dcache_loads_ = GOOGLE_ULONGLONG(0);
  l1_dcache_load_misses_ = GOOGLE_ULONGLONG(0);
  l1_dcache_stores_ = GOOGLE_ULONGLONG(0);
  l1_dcache_store_misses_ = GOOGLE_ULONGLONG(0);
  l1_dcache_prefetches_ = GOOGLE_ULONGLONG(0);
  l1_dcache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  l1_icache_loads_ = GOOGLE_ULONGLONG(0);
  l1_icache_load_misses_ = GOOGLE_ULONGLONG(0);
  l1_icache_prefetches_ = GOOGLE_ULONGLONG(0);
  l1_icache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  llc_loads_ = GOOGLE_ULONGLONG(0);
  llc_load_misses_ = GOOGLE_ULONGLONG(0);
  llc_stores_ = GOOGLE_ULONGLONG(0);
  llc_store_misses_ = GOOGLE_ULONGLONG(0);
  llc_prefetches_ = GOOGLE_ULONGLONG(0);
  llc_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  dtlb_loads_ = GOOGLE_ULONGLONG(0);
  dtlb_load_misses_ = GOOGLE_ULONGLONG(0);
  dtlb_stores_ = GOOGLE_ULONGLONG(0);
  dtlb_store_misses_ = GOOGLE_ULONGLONG(0);
  dtlb_prefetches_ = GOOGLE_ULONGLONG(0);
  dtlb_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  itlb_loads_ = GOOGLE_ULONGLONG(0);
  itlb_load_misses_ = GOOGLE_ULONGLONG(0);
  branch_loads_ = GOOGLE_ULONGLONG(0);
  branch_load_misses_ = GOOGLE_ULONGLONG(0);
  node_loads_ = GOOGLE_ULONGLONG(0);
  node_load_misses_ = GOOGLE_ULONGLONG(0);
  node_stores_ = GOOGLE_ULONGLONG(0);
  node_store_misses_ = GOOGLE_ULONGLONG(0);
  node_prefetches_ = GOOGLE_ULONGLONG(0);
  node_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PerfStatistics::~PerfStatistics() {
  // @@protoc_insertion_point(destructor:mesos.PerfStatistics)
  SharedDtor();
}

void PerfStatistics::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PerfStatistics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PerfStatistics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PerfStatistics_descriptor_;
}

const PerfStatistics& PerfStatistics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

PerfStatistics* PerfStatistics::default_instance_ = NULL;

PerfStatistics* PerfStatistics::New(::google::protobuf::Arena* arena) const {
  PerfStatistics* n = new PerfStatistics;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PerfStatistics::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.PerfStatistics)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PerfStatistics, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PerfStatistics*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    ZR_(timestamp_, cache_misses_);
  }
  if (_has_bits_[8 / 32] & 65280u) {
    ZR_(branches_, minor_faults_);
  }
  if (_has_bits_[16 / 32] & 16711680u) {
    ZR_(major_faults_, l1_dcache_stores_);
  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    ZR_(l1_dcache_store_misses_, llc_loads_);
  }
  if (_has_bits_[32 / 32] & 255u) {
    ZR_(llc_load_misses_, dtlb_stores_);
  }
  if (_has_bits_[40 / 32] & 65280u) {
    ZR_(dtlb_store_misses_, node_loads_);
  }
  if (_has_bits_[48 / 32] & 2031616u) {
    ZR_(node_load_misses_, node_prefetch_misses_);
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool PerfStatistics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.PerfStatistics)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(16383);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double timestamp = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_duration;
        break;
      }

      // required double duration = 2;
      case 2: {
        if (tag == 17) {
         parse_duration:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &duration_)));
          set_has_duration();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_cycles;
        break;
      }

      // optional uint64 cycles = 3;
      case 3: {
        if (tag == 24) {
         parse_cycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cycles_)));
          set_has_cycles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_stalled_cycles_frontend;
        break;
      }

      // optional uint64 stalled_cycles_frontend = 4;
      case 4: {
        if (tag == 32) {
         parse_stalled_cycles_frontend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &stalled_cycles_frontend_)));
          set_has_stalled_cycles_frontend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_stalled_cycles_backend;
        break;
      }

      // optional uint64 stalled_cycles_backend = 5;
      case 5: {
        if (tag == 40) {
         parse_stalled_cycles_backend:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &stalled_cycles_backend_)));
          set_has_stalled_cycles_backend();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_instructions;
        break;
      }

      // optional uint64 instructions = 6;
      case 6: {
        if (tag == 48) {
         parse_instructions:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &instructions_)));
          set_has_instructions();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(56)) goto parse_cache_references;
        break;
      }

      // optional uint64 cache_references = 7;
      case 7: {
        if (tag == 56) {
         parse_cache_references:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cache_references_)));
          set_has_cache_references();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_cache_misses;
        break;
      }

      // optional uint64 cache_misses = 8;
      case 8: {
        if (tag == 64) {
         parse_cache_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cache_misses_)));
          set_has_cache_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_branches;
        break;
      }

      // optional uint64 branches = 9;
      case 9: {
        if (tag == 72) {
         parse_branches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branches_)));
          set_has_branches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_branch_misses;
        break;
      }

      // optional uint64 branch_misses = 10;
      case 10: {
        if (tag == 80) {
         parse_branch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branch_misses_)));
          set_has_branch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(88)) goto parse_bus_cycles;
        break;
      }

      // optional uint64 bus_cycles = 11;
      case 11: {
        if (tag == 88) {
         parse_bus_cycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bus_cycles_)));
          set_has_bus_cycles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(96)) goto parse_ref_cycles;
        break;
      }

      // optional uint64 ref_cycles = 12;
      case 12: {
        if (tag == 96) {
         parse_ref_cycles:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &ref_cycles_)));
          set_has_ref_cycles();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(105)) goto parse_cpu_clock;
        break;
      }

      // optional double cpu_clock = 13;
      case 13: {
        if (tag == 105) {
         parse_cpu_clock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &cpu_clock_)));
          set_has_cpu_clock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(113)) goto parse_task_clock;
        break;
      }

      // optional double task_clock = 14;
      case 14: {
        if (tag == 113) {
         parse_task_clock:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &task_clock_)));
          set_has_task_clock();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(120)) goto parse_page_faults;
        break;
      }

      // optional uint64 page_faults = 15;
      case 15: {
        if (tag == 120) {
         parse_page_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &page_faults_)));
          set_has_page_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(128)) goto parse_minor_faults;
        break;
      }

      // optional uint64 minor_faults = 16;
      case 16: {
        if (tag == 128) {
         parse_minor_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &minor_faults_)));
          set_has_minor_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(136)) goto parse_major_faults;
        break;
      }

      // optional uint64 major_faults = 17;
      case 17: {
        if (tag == 136) {
         parse_major_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &major_faults_)));
          set_has_major_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(144)) goto parse_context_switches;
        break;
      }

      // optional uint64 context_switches = 18;
      case 18: {
        if (tag == 144) {
         parse_context_switches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &context_switches_)));
          set_has_context_switches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(152)) goto parse_cpu_migrations;
        break;
      }

      // optional uint64 cpu_migrations = 19;
      case 19: {
        if (tag == 152) {
         parse_cpu_migrations:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &cpu_migrations_)));
          set_has_cpu_migrations();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(160)) goto parse_alignment_faults;
        break;
      }

      // optional uint64 alignment_faults = 20;
      case 20: {
        if (tag == 160) {
         parse_alignment_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &alignment_faults_)));
          set_has_alignment_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(168)) goto parse_emulation_faults;
        break;
      }

      // optional uint64 emulation_faults = 21;
      case 21: {
        if (tag == 168) {
         parse_emulation_faults:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &emulation_faults_)));
          set_has_emulation_faults();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(176)) goto parse_l1_dcache_loads;
        break;
      }

      // optional uint64 l1_dcache_loads = 22;
      case 22: {
        if (tag == 176) {
         parse_l1_dcache_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_loads_)));
          set_has_l1_dcache_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(184)) goto parse_l1_dcache_load_misses;
        break;
      }

      // optional uint64 l1_dcache_load_misses = 23;
      case 23: {
        if (tag == 184) {
         parse_l1_dcache_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_load_misses_)));
          set_has_l1_dcache_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(192)) goto parse_l1_dcache_stores;
        break;
      }

      // optional uint64 l1_dcache_stores = 24;
      case 24: {
        if (tag == 192) {
         parse_l1_dcache_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_stores_)));
          set_has_l1_dcache_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(200)) goto parse_l1_dcache_store_misses;
        break;
      }

      // optional uint64 l1_dcache_store_misses = 25;
      case 25: {
        if (tag == 200) {
         parse_l1_dcache_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_store_misses_)));
          set_has_l1_dcache_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(208)) goto parse_l1_dcache_prefetches;
        break;
      }

      // optional uint64 l1_dcache_prefetches = 26;
      case 26: {
        if (tag == 208) {
         parse_l1_dcache_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_prefetches_)));
          set_has_l1_dcache_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(216)) goto parse_l1_dcache_prefetch_misses;
        break;
      }

      // optional uint64 l1_dcache_prefetch_misses = 27;
      case 27: {
        if (tag == 216) {
         parse_l1_dcache_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_dcache_prefetch_misses_)));
          set_has_l1_dcache_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(224)) goto parse_l1_icache_loads;
        break;
      }

      // optional uint64 l1_icache_loads = 28;
      case 28: {
        if (tag == 224) {
         parse_l1_icache_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_loads_)));
          set_has_l1_icache_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(232)) goto parse_l1_icache_load_misses;
        break;
      }

      // optional uint64 l1_icache_load_misses = 29;
      case 29: {
        if (tag == 232) {
         parse_l1_icache_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_load_misses_)));
          set_has_l1_icache_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(240)) goto parse_l1_icache_prefetches;
        break;
      }

      // optional uint64 l1_icache_prefetches = 30;
      case 30: {
        if (tag == 240) {
         parse_l1_icache_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_prefetches_)));
          set_has_l1_icache_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(248)) goto parse_l1_icache_prefetch_misses;
        break;
      }

      // optional uint64 l1_icache_prefetch_misses = 31;
      case 31: {
        if (tag == 248) {
         parse_l1_icache_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &l1_icache_prefetch_misses_)));
          set_has_l1_icache_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(256)) goto parse_llc_loads;
        break;
      }

      // optional uint64 llc_loads = 32;
      case 32: {
        if (tag == 256) {
         parse_llc_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_loads_)));
          set_has_llc_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(264)) goto parse_llc_load_misses;
        break;
      }

      // optional uint64 llc_load_misses = 33;
      case 33: {
        if (tag == 264) {
         parse_llc_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_load_misses_)));
          set_has_llc_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(272)) goto parse_llc_stores;
        break;
      }

      // optional uint64 llc_stores = 34;
      case 34: {
        if (tag == 272) {
         parse_llc_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_stores_)));
          set_has_llc_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(280)) goto parse_llc_store_misses;
        break;
      }

      // optional uint64 llc_store_misses = 35;
      case 35: {
        if (tag == 280) {
         parse_llc_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_store_misses_)));
          set_has_llc_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(288)) goto parse_llc_prefetches;
        break;
      }

      // optional uint64 llc_prefetches = 36;
      case 36: {
        if (tag == 288) {
         parse_llc_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_prefetches_)));
          set_has_llc_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(296)) goto parse_llc_prefetch_misses;
        break;
      }

      // optional uint64 llc_prefetch_misses = 37;
      case 37: {
        if (tag == 296) {
         parse_llc_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &llc_prefetch_misses_)));
          set_has_llc_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(304)) goto parse_dtlb_loads;
        break;
      }

      // optional uint64 dtlb_loads = 38;
      case 38: {
        if (tag == 304) {
         parse_dtlb_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_loads_)));
          set_has_dtlb_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(312)) goto parse_dtlb_load_misses;
        break;
      }

      // optional uint64 dtlb_load_misses = 39;
      case 39: {
        if (tag == 312) {
         parse_dtlb_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_load_misses_)));
          set_has_dtlb_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(320)) goto parse_dtlb_stores;
        break;
      }

      // optional uint64 dtlb_stores = 40;
      case 40: {
        if (tag == 320) {
         parse_dtlb_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_stores_)));
          set_has_dtlb_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(328)) goto parse_dtlb_store_misses;
        break;
      }

      // optional uint64 dtlb_store_misses = 41;
      case 41: {
        if (tag == 328) {
         parse_dtlb_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_store_misses_)));
          set_has_dtlb_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(336)) goto parse_dtlb_prefetches;
        break;
      }

      // optional uint64 dtlb_prefetches = 42;
      case 42: {
        if (tag == 336) {
         parse_dtlb_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_prefetches_)));
          set_has_dtlb_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(344)) goto parse_dtlb_prefetch_misses;
        break;
      }

      // optional uint64 dtlb_prefetch_misses = 43;
      case 43: {
        if (tag == 344) {
         parse_dtlb_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &dtlb_prefetch_misses_)));
          set_has_dtlb_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(352)) goto parse_itlb_loads;
        break;
      }

      // optional uint64 itlb_loads = 44;
      case 44: {
        if (tag == 352) {
         parse_itlb_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itlb_loads_)));
          set_has_itlb_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(360)) goto parse_itlb_load_misses;
        break;
      }

      // optional uint64 itlb_load_misses = 45;
      case 45: {
        if (tag == 360) {
         parse_itlb_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &itlb_load_misses_)));
          set_has_itlb_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(368)) goto parse_branch_loads;
        break;
      }

      // optional uint64 branch_loads = 46;
      case 46: {
        if (tag == 368) {
         parse_branch_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branch_loads_)));
          set_has_branch_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(376)) goto parse_branch_load_misses;
        break;
      }

      // optional uint64 branch_load_misses = 47;
      case 47: {
        if (tag == 376) {
         parse_branch_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &branch_load_misses_)));
          set_has_branch_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(384)) goto parse_node_loads;
        break;
      }

      // optional uint64 node_loads = 48;
      case 48: {
        if (tag == 384) {
         parse_node_loads:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_loads_)));
          set_has_node_loads();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(392)) goto parse_node_load_misses;
        break;
      }

      // optional uint64 node_load_misses = 49;
      case 49: {
        if (tag == 392) {
         parse_node_load_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_load_misses_)));
          set_has_node_load_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(400)) goto parse_node_stores;
        break;
      }

      // optional uint64 node_stores = 50;
      case 50: {
        if (tag == 400) {
         parse_node_stores:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_stores_)));
          set_has_node_stores();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(408)) goto parse_node_store_misses;
        break;
      }

      // optional uint64 node_store_misses = 51;
      case 51: {
        if (tag == 408) {
         parse_node_store_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_store_misses_)));
          set_has_node_store_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(416)) goto parse_node_prefetches;
        break;
      }

      // optional uint64 node_prefetches = 52;
      case 52: {
        if (tag == 416) {
         parse_node_prefetches:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_prefetches_)));
          set_has_node_prefetches();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(424)) goto parse_node_prefetch_misses;
        break;
      }

      // optional uint64 node_prefetch_misses = 53;
      case 53: {
        if (tag == 424) {
         parse_node_prefetch_misses:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &node_prefetch_misses_)));
          set_has_node_prefetch_misses();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.PerfStatistics)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.PerfStatistics)
  return false;
#undef DO_
}

void PerfStatistics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.PerfStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->timestamp(), output);
  }

  // required double duration = 2;
  if (has_duration()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->duration(), output);
  }

  // optional uint64 cycles = 3;
  if (has_cycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->cycles(), output);
  }

  // optional uint64 stalled_cycles_frontend = 4;
  if (has_stalled_cycles_frontend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(4, this->stalled_cycles_frontend(), output);
  }

  // optional uint64 stalled_cycles_backend = 5;
  if (has_stalled_cycles_backend()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(5, this->stalled_cycles_backend(), output);
  }

  // optional uint64 instructions = 6;
  if (has_instructions()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(6, this->instructions(), output);
  }

  // optional uint64 cache_references = 7;
  if (has_cache_references()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(7, this->cache_references(), output);
  }

  // optional uint64 cache_misses = 8;
  if (has_cache_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(8, this->cache_misses(), output);
  }

  // optional uint64 branches = 9;
  if (has_branches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(9, this->branches(), output);
  }

  // optional uint64 branch_misses = 10;
  if (has_branch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(10, this->branch_misses(), output);
  }

  // optional uint64 bus_cycles = 11;
  if (has_bus_cycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(11, this->bus_cycles(), output);
  }

  // optional uint64 ref_cycles = 12;
  if (has_ref_cycles()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(12, this->ref_cycles(), output);
  }

  // optional double cpu_clock = 13;
  if (has_cpu_clock()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(13, this->cpu_clock(), output);
  }

  // optional double task_clock = 14;
  if (has_task_clock()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(14, this->task_clock(), output);
  }

  // optional uint64 page_faults = 15;
  if (has_page_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(15, this->page_faults(), output);
  }

  // optional uint64 minor_faults = 16;
  if (has_minor_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(16, this->minor_faults(), output);
  }

  // optional uint64 major_faults = 17;
  if (has_major_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(17, this->major_faults(), output);
  }

  // optional uint64 context_switches = 18;
  if (has_context_switches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(18, this->context_switches(), output);
  }

  // optional uint64 cpu_migrations = 19;
  if (has_cpu_migrations()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(19, this->cpu_migrations(), output);
  }

  // optional uint64 alignment_faults = 20;
  if (has_alignment_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(20, this->alignment_faults(), output);
  }

  // optional uint64 emulation_faults = 21;
  if (has_emulation_faults()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(21, this->emulation_faults(), output);
  }

  // optional uint64 l1_dcache_loads = 22;
  if (has_l1_dcache_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(22, this->l1_dcache_loads(), output);
  }

  // optional uint64 l1_dcache_load_misses = 23;
  if (has_l1_dcache_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(23, this->l1_dcache_load_misses(), output);
  }

  // optional uint64 l1_dcache_stores = 24;
  if (has_l1_dcache_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(24, this->l1_dcache_stores(), output);
  }

  // optional uint64 l1_dcache_store_misses = 25;
  if (has_l1_dcache_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(25, this->l1_dcache_store_misses(), output);
  }

  // optional uint64 l1_dcache_prefetches = 26;
  if (has_l1_dcache_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(26, this->l1_dcache_prefetches(), output);
  }

  // optional uint64 l1_dcache_prefetch_misses = 27;
  if (has_l1_dcache_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(27, this->l1_dcache_prefetch_misses(), output);
  }

  // optional uint64 l1_icache_loads = 28;
  if (has_l1_icache_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(28, this->l1_icache_loads(), output);
  }

  // optional uint64 l1_icache_load_misses = 29;
  if (has_l1_icache_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(29, this->l1_icache_load_misses(), output);
  }

  // optional uint64 l1_icache_prefetches = 30;
  if (has_l1_icache_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(30, this->l1_icache_prefetches(), output);
  }

  // optional uint64 l1_icache_prefetch_misses = 31;
  if (has_l1_icache_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(31, this->l1_icache_prefetch_misses(), output);
  }

  // optional uint64 llc_loads = 32;
  if (has_llc_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(32, this->llc_loads(), output);
  }

  // optional uint64 llc_load_misses = 33;
  if (has_llc_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(33, this->llc_load_misses(), output);
  }

  // optional uint64 llc_stores = 34;
  if (has_llc_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(34, this->llc_stores(), output);
  }

  // optional uint64 llc_store_misses = 35;
  if (has_llc_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(35, this->llc_store_misses(), output);
  }

  // optional uint64 llc_prefetches = 36;
  if (has_llc_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(36, this->llc_prefetches(), output);
  }

  // optional uint64 llc_prefetch_misses = 37;
  if (has_llc_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(37, this->llc_prefetch_misses(), output);
  }

  // optional uint64 dtlb_loads = 38;
  if (has_dtlb_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(38, this->dtlb_loads(), output);
  }

  // optional uint64 dtlb_load_misses = 39;
  if (has_dtlb_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(39, this->dtlb_load_misses(), output);
  }

  // optional uint64 dtlb_stores = 40;
  if (has_dtlb_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(40, this->dtlb_stores(), output);
  }

  // optional uint64 dtlb_store_misses = 41;
  if (has_dtlb_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(41, this->dtlb_store_misses(), output);
  }

  // optional uint64 dtlb_prefetches = 42;
  if (has_dtlb_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(42, this->dtlb_prefetches(), output);
  }

  // optional uint64 dtlb_prefetch_misses = 43;
  if (has_dtlb_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(43, this->dtlb_prefetch_misses(), output);
  }

  // optional uint64 itlb_loads = 44;
  if (has_itlb_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(44, this->itlb_loads(), output);
  }

  // optional uint64 itlb_load_misses = 45;
  if (has_itlb_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(45, this->itlb_load_misses(), output);
  }

  // optional uint64 branch_loads = 46;
  if (has_branch_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(46, this->branch_loads(), output);
  }

  // optional uint64 branch_load_misses = 47;
  if (has_branch_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(47, this->branch_load_misses(), output);
  }

  // optional uint64 node_loads = 48;
  if (has_node_loads()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(48, this->node_loads(), output);
  }

  // optional uint64 node_load_misses = 49;
  if (has_node_load_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(49, this->node_load_misses(), output);
  }

  // optional uint64 node_stores = 50;
  if (has_node_stores()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(50, this->node_stores(), output);
  }

  // optional uint64 node_store_misses = 51;
  if (has_node_store_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(51, this->node_store_misses(), output);
  }

  // optional uint64 node_prefetches = 52;
  if (has_node_prefetches()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(52, this->node_prefetches(), output);
  }

  // optional uint64 node_prefetch_misses = 53;
  if (has_node_prefetch_misses()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(53, this->node_prefetch_misses(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.PerfStatistics)
}

::google::protobuf::uint8* PerfStatistics::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.PerfStatistics)
  // required double timestamp = 1;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->timestamp(), target);
  }

  // required double duration = 2;
  if (has_duration()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->duration(), target);
  }

  // optional uint64 cycles = 3;
  if (has_cycles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->cycles(), target);
  }

  // optional uint64 stalled_cycles_frontend = 4;
  if (has_stalled_cycles_frontend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(4, this->stalled_cycles_frontend(), target);
  }

  // optional uint64 stalled_cycles_backend = 5;
  if (has_stalled_cycles_backend()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(5, this->stalled_cycles_backend(), target);
  }

  // optional uint64 instructions = 6;
  if (has_instructions()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(6, this->instructions(), target);
  }

  // optional uint64 cache_references = 7;
  if (has_cache_references()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(7, this->cache_references(), target);
  }

  // optional uint64 cache_misses = 8;
  if (has_cache_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(8, this->cache_misses(), target);
  }

  // optional uint64 branches = 9;
  if (has_branches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(9, this->branches(), target);
  }

  // optional uint64 branch_misses = 10;
  if (has_branch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(10, this->branch_misses(), target);
  }

  // optional uint64 bus_cycles = 11;
  if (has_bus_cycles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(11, this->bus_cycles(), target);
  }

  // optional uint64 ref_cycles = 12;
  if (has_ref_cycles()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(12, this->ref_cycles(), target);
  }

  // optional double cpu_clock = 13;
  if (has_cpu_clock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(13, this->cpu_clock(), target);
  }

  // optional double task_clock = 14;
  if (has_task_clock()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(14, this->task_clock(), target);
  }

  // optional uint64 page_faults = 15;
  if (has_page_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(15, this->page_faults(), target);
  }

  // optional uint64 minor_faults = 16;
  if (has_minor_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(16, this->minor_faults(), target);
  }

  // optional uint64 major_faults = 17;
  if (has_major_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(17, this->major_faults(), target);
  }

  // optional uint64 context_switches = 18;
  if (has_context_switches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(18, this->context_switches(), target);
  }

  // optional uint64 cpu_migrations = 19;
  if (has_cpu_migrations()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(19, this->cpu_migrations(), target);
  }

  // optional uint64 alignment_faults = 20;
  if (has_alignment_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(20, this->alignment_faults(), target);
  }

  // optional uint64 emulation_faults = 21;
  if (has_emulation_faults()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(21, this->emulation_faults(), target);
  }

  // optional uint64 l1_dcache_loads = 22;
  if (has_l1_dcache_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(22, this->l1_dcache_loads(), target);
  }

  // optional uint64 l1_dcache_load_misses = 23;
  if (has_l1_dcache_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(23, this->l1_dcache_load_misses(), target);
  }

  // optional uint64 l1_dcache_stores = 24;
  if (has_l1_dcache_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(24, this->l1_dcache_stores(), target);
  }

  // optional uint64 l1_dcache_store_misses = 25;
  if (has_l1_dcache_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(25, this->l1_dcache_store_misses(), target);
  }

  // optional uint64 l1_dcache_prefetches = 26;
  if (has_l1_dcache_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(26, this->l1_dcache_prefetches(), target);
  }

  // optional uint64 l1_dcache_prefetch_misses = 27;
  if (has_l1_dcache_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(27, this->l1_dcache_prefetch_misses(), target);
  }

  // optional uint64 l1_icache_loads = 28;
  if (has_l1_icache_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(28, this->l1_icache_loads(), target);
  }

  // optional uint64 l1_icache_load_misses = 29;
  if (has_l1_icache_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(29, this->l1_icache_load_misses(), target);
  }

  // optional uint64 l1_icache_prefetches = 30;
  if (has_l1_icache_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(30, this->l1_icache_prefetches(), target);
  }

  // optional uint64 l1_icache_prefetch_misses = 31;
  if (has_l1_icache_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(31, this->l1_icache_prefetch_misses(), target);
  }

  // optional uint64 llc_loads = 32;
  if (has_llc_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(32, this->llc_loads(), target);
  }

  // optional uint64 llc_load_misses = 33;
  if (has_llc_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(33, this->llc_load_misses(), target);
  }

  // optional uint64 llc_stores = 34;
  if (has_llc_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(34, this->llc_stores(), target);
  }

  // optional uint64 llc_store_misses = 35;
  if (has_llc_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(35, this->llc_store_misses(), target);
  }

  // optional uint64 llc_prefetches = 36;
  if (has_llc_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(36, this->llc_prefetches(), target);
  }

  // optional uint64 llc_prefetch_misses = 37;
  if (has_llc_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(37, this->llc_prefetch_misses(), target);
  }

  // optional uint64 dtlb_loads = 38;
  if (has_dtlb_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(38, this->dtlb_loads(), target);
  }

  // optional uint64 dtlb_load_misses = 39;
  if (has_dtlb_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(39, this->dtlb_load_misses(), target);
  }

  // optional uint64 dtlb_stores = 40;
  if (has_dtlb_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(40, this->dtlb_stores(), target);
  }

  // optional uint64 dtlb_store_misses = 41;
  if (has_dtlb_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(41, this->dtlb_store_misses(), target);
  }

  // optional uint64 dtlb_prefetches = 42;
  if (has_dtlb_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(42, this->dtlb_prefetches(), target);
  }

  // optional uint64 dtlb_prefetch_misses = 43;
  if (has_dtlb_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(43, this->dtlb_prefetch_misses(), target);
  }

  // optional uint64 itlb_loads = 44;
  if (has_itlb_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(44, this->itlb_loads(), target);
  }

  // optional uint64 itlb_load_misses = 45;
  if (has_itlb_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(45, this->itlb_load_misses(), target);
  }

  // optional uint64 branch_loads = 46;
  if (has_branch_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(46, this->branch_loads(), target);
  }

  // optional uint64 branch_load_misses = 47;
  if (has_branch_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(47, this->branch_load_misses(), target);
  }

  // optional uint64 node_loads = 48;
  if (has_node_loads()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(48, this->node_loads(), target);
  }

  // optional uint64 node_load_misses = 49;
  if (has_node_load_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(49, this->node_load_misses(), target);
  }

  // optional uint64 node_stores = 50;
  if (has_node_stores()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(50, this->node_stores(), target);
  }

  // optional uint64 node_store_misses = 51;
  if (has_node_store_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(51, this->node_store_misses(), target);
  }

  // optional uint64 node_prefetches = 52;
  if (has_node_prefetches()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(52, this->node_prefetches(), target);
  }

  // optional uint64 node_prefetch_misses = 53;
  if (has_node_prefetch_misses()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(53, this->node_prefetch_misses(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.PerfStatistics)
  return target;
}

int PerfStatistics::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.PerfStatistics)
  int total_size = 0;

  if (has_timestamp()) {
    // required double timestamp = 1;
    total_size += 1 + 8;
  }

  if (has_duration()) {
    // required double duration = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int PerfStatistics::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.PerfStatistics)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required double timestamp = 1;
    total_size += 1 + 8;

    // required double duration = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 252u) {
    // optional uint64 cycles = 3;
    if (has_cycles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cycles());
    }

    // optional uint64 stalled_cycles_frontend = 4;
    if (has_stalled_cycles_frontend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->stalled_cycles_frontend());
    }

    // optional uint64 stalled_cycles_backend = 5;
    if (has_stalled_cycles_backend()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->stalled_cycles_backend());
    }

    // optional uint64 instructions = 6;
    if (has_instructions()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->instructions());
    }

    // optional uint64 cache_references = 7;
    if (has_cache_references()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cache_references());
    }

    // optional uint64 cache_misses = 8;
    if (has_cache_misses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cache_misses());
    }

  }
  if (_has_bits_[8 / 32] & 65280u) {
    // optional uint64 branches = 9;
    if (has_branches()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branches());
    }

    // optional uint64 branch_misses = 10;
    if (has_branch_misses()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branch_misses());
    }

    // optional uint64 bus_cycles = 11;
    if (has_bus_cycles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->bus_cycles());
    }

    // optional uint64 ref_cycles = 12;
    if (has_ref_cycles()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->ref_cycles());
    }

    // optional double cpu_clock = 13;
    if (has_cpu_clock()) {
      total_size += 1 + 8;
    }

    // optional double task_clock = 14;
    if (has_task_clock()) {
      total_size += 1 + 8;
    }

    // optional uint64 page_faults = 15;
    if (has_page_faults()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->page_faults());
    }

    // optional uint64 minor_faults = 16;
    if (has_minor_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->minor_faults());
    }

  }
  if (_has_bits_[16 / 32] & 16711680u) {
    // optional uint64 major_faults = 17;
    if (has_major_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->major_faults());
    }

    // optional uint64 context_switches = 18;
    if (has_context_switches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->context_switches());
    }

    // optional uint64 cpu_migrations = 19;
    if (has_cpu_migrations()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->cpu_migrations());
    }

    // optional uint64 alignment_faults = 20;
    if (has_alignment_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->alignment_faults());
    }

    // optional uint64 emulation_faults = 21;
    if (has_emulation_faults()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->emulation_faults());
    }

    // optional uint64 l1_dcache_loads = 22;
    if (has_l1_dcache_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_loads());
    }

    // optional uint64 l1_dcache_load_misses = 23;
    if (has_l1_dcache_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_load_misses());
    }

    // optional uint64 l1_dcache_stores = 24;
    if (has_l1_dcache_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_stores());
    }

  }
  if (_has_bits_[24 / 32] & 4278190080u) {
    // optional uint64 l1_dcache_store_misses = 25;
    if (has_l1_dcache_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_store_misses());
    }

    // optional uint64 l1_dcache_prefetches = 26;
    if (has_l1_dcache_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_prefetches());
    }

    // optional uint64 l1_dcache_prefetch_misses = 27;
    if (has_l1_dcache_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_dcache_prefetch_misses());
    }

    // optional uint64 l1_icache_loads = 28;
    if (has_l1_icache_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_loads());
    }

    // optional uint64 l1_icache_load_misses = 29;
    if (has_l1_icache_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_load_misses());
    }

    // optional uint64 l1_icache_prefetches = 30;
    if (has_l1_icache_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_prefetches());
    }

    // optional uint64 l1_icache_prefetch_misses = 31;
    if (has_l1_icache_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->l1_icache_prefetch_misses());
    }

    // optional uint64 llc_loads = 32;
    if (has_llc_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_loads());
    }

  }
  if (_has_bits_[32 / 32] & 255u) {
    // optional uint64 llc_load_misses = 33;
    if (has_llc_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_load_misses());
    }

    // optional uint64 llc_stores = 34;
    if (has_llc_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_stores());
    }

    // optional uint64 llc_store_misses = 35;
    if (has_llc_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_store_misses());
    }

    // optional uint64 llc_prefetches = 36;
    if (has_llc_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_prefetches());
    }

    // optional uint64 llc_prefetch_misses = 37;
    if (has_llc_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->llc_prefetch_misses());
    }

    // optional uint64 dtlb_loads = 38;
    if (has_dtlb_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_loads());
    }

    // optional uint64 dtlb_load_misses = 39;
    if (has_dtlb_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_load_misses());
    }

    // optional uint64 dtlb_stores = 40;
    if (has_dtlb_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_stores());
    }

  }
  if (_has_bits_[40 / 32] & 65280u) {
    // optional uint64 dtlb_store_misses = 41;
    if (has_dtlb_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_store_misses());
    }

    // optional uint64 dtlb_prefetches = 42;
    if (has_dtlb_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_prefetches());
    }

    // optional uint64 dtlb_prefetch_misses = 43;
    if (has_dtlb_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->dtlb_prefetch_misses());
    }

    // optional uint64 itlb_loads = 44;
    if (has_itlb_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itlb_loads());
    }

    // optional uint64 itlb_load_misses = 45;
    if (has_itlb_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->itlb_load_misses());
    }

    // optional uint64 branch_loads = 46;
    if (has_branch_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branch_loads());
    }

    // optional uint64 branch_load_misses = 47;
    if (has_branch_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->branch_load_misses());
    }

    // optional uint64 node_loads = 48;
    if (has_node_loads()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_loads());
    }

  }
  if (_has_bits_[48 / 32] & 2031616u) {
    // optional uint64 node_load_misses = 49;
    if (has_node_load_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_load_misses());
    }

    // optional uint64 node_stores = 50;
    if (has_node_stores()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_stores());
    }

    // optional uint64 node_store_misses = 51;
    if (has_node_store_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_store_misses());
    }

    // optional uint64 node_prefetches = 52;
    if (has_node_prefetches()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_prefetches());
    }

    // optional uint64 node_prefetch_misses = 53;
    if (has_node_prefetch_misses()) {
      total_size += 2 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->node_prefetch_misses());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PerfStatistics::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.PerfStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PerfStatistics* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PerfStatistics>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.PerfStatistics)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.PerfStatistics)
    MergeFrom(*source);
  }
}

void PerfStatistics::MergeFrom(const PerfStatistics& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.PerfStatistics)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_duration()) {
      set_duration(from.duration());
    }
    if (from.has_cycles()) {
      set_cycles(from.cycles());
    }
    if (from.has_stalled_cycles_frontend()) {
      set_stalled_cycles_frontend(from.stalled_cycles_frontend());
    }
    if (from.has_stalled_cycles_backend()) {
      set_stalled_cycles_backend(from.stalled_cycles_backend());
    }
    if (from.has_instructions()) {
      set_instructions(from.instructions());
    }
    if (from.has_cache_references()) {
      set_cache_references(from.cache_references());
    }
    if (from.has_cache_misses()) {
      set_cache_misses(from.cache_misses());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_branches()) {
      set_branches(from.branches());
    }
    if (from.has_branch_misses()) {
      set_branch_misses(from.branch_misses());
    }
    if (from.has_bus_cycles()) {
      set_bus_cycles(from.bus_cycles());
    }
    if (from.has_ref_cycles()) {
      set_ref_cycles(from.ref_cycles());
    }
    if (from.has_cpu_clock()) {
      set_cpu_clock(from.cpu_clock());
    }
    if (from.has_task_clock()) {
      set_task_clock(from.task_clock());
    }
    if (from.has_page_faults()) {
      set_page_faults(from.page_faults());
    }
    if (from.has_minor_faults()) {
      set_minor_faults(from.minor_faults());
    }
  }
  if (from._has_bits_[16 / 32] & (0xffu << (16 % 32))) {
    if (from.has_major_faults()) {
      set_major_faults(from.major_faults());
    }
    if (from.has_context_switches()) {
      set_context_switches(from.context_switches());
    }
    if (from.has_cpu_migrations()) {
      set_cpu_migrations(from.cpu_migrations());
    }
    if (from.has_alignment_faults()) {
      set_alignment_faults(from.alignment_faults());
    }
    if (from.has_emulation_faults()) {
      set_emulation_faults(from.emulation_faults());
    }
    if (from.has_l1_dcache_loads()) {
      set_l1_dcache_loads(from.l1_dcache_loads());
    }
    if (from.has_l1_dcache_load_misses()) {
      set_l1_dcache_load_misses(from.l1_dcache_load_misses());
    }
    if (from.has_l1_dcache_stores()) {
      set_l1_dcache_stores(from.l1_dcache_stores());
    }
  }
  if (from._has_bits_[24 / 32] & (0xffu << (24 % 32))) {
    if (from.has_l1_dcache_store_misses()) {
      set_l1_dcache_store_misses(from.l1_dcache_store_misses());
    }
    if (from.has_l1_dcache_prefetches()) {
      set_l1_dcache_prefetches(from.l1_dcache_prefetches());
    }
    if (from.has_l1_dcache_prefetch_misses()) {
      set_l1_dcache_prefetch_misses(from.l1_dcache_prefetch_misses());
    }
    if (from.has_l1_icache_loads()) {
      set_l1_icache_loads(from.l1_icache_loads());
    }
    if (from.has_l1_icache_load_misses()) {
      set_l1_icache_load_misses(from.l1_icache_load_misses());
    }
    if (from.has_l1_icache_prefetches()) {
      set_l1_icache_prefetches(from.l1_icache_prefetches());
    }
    if (from.has_l1_icache_prefetch_misses()) {
      set_l1_icache_prefetch_misses(from.l1_icache_prefetch_misses());
    }
    if (from.has_llc_loads()) {
      set_llc_loads(from.llc_loads());
    }
  }
  if (from._has_bits_[32 / 32] & (0xffu << (32 % 32))) {
    if (from.has_llc_load_misses()) {
      set_llc_load_misses(from.llc_load_misses());
    }
    if (from.has_llc_stores()) {
      set_llc_stores(from.llc_stores());
    }
    if (from.has_llc_store_misses()) {
      set_llc_store_misses(from.llc_store_misses());
    }
    if (from.has_llc_prefetches()) {
      set_llc_prefetches(from.llc_prefetches());
    }
    if (from.has_llc_prefetch_misses()) {
      set_llc_prefetch_misses(from.llc_prefetch_misses());
    }
    if (from.has_dtlb_loads()) {
      set_dtlb_loads(from.dtlb_loads());
    }
    if (from.has_dtlb_load_misses()) {
      set_dtlb_load_misses(from.dtlb_load_misses());
    }
    if (from.has_dtlb_stores()) {
      set_dtlb_stores(from.dtlb_stores());
    }
  }
  if (from._has_bits_[40 / 32] & (0xffu << (40 % 32))) {
    if (from.has_dtlb_store_misses()) {
      set_dtlb_store_misses(from.dtlb_store_misses());
    }
    if (from.has_dtlb_prefetches()) {
      set_dtlb_prefetches(from.dtlb_prefetches());
    }
    if (from.has_dtlb_prefetch_misses()) {
      set_dtlb_prefetch_misses(from.dtlb_prefetch_misses());
    }
    if (from.has_itlb_loads()) {
      set_itlb_loads(from.itlb_loads());
    }
    if (from.has_itlb_load_misses()) {
      set_itlb_load_misses(from.itlb_load_misses());
    }
    if (from.has_branch_loads()) {
      set_branch_loads(from.branch_loads());
    }
    if (from.has_branch_load_misses()) {
      set_branch_load_misses(from.branch_load_misses());
    }
    if (from.has_node_loads()) {
      set_node_loads(from.node_loads());
    }
  }
  if (from._has_bits_[48 / 32] & (0xffu << (48 % 32))) {
    if (from.has_node_load_misses()) {
      set_node_load_misses(from.node_load_misses());
    }
    if (from.has_node_stores()) {
      set_node_stores(from.node_stores());
    }
    if (from.has_node_store_misses()) {
      set_node_store_misses(from.node_store_misses());
    }
    if (from.has_node_prefetches()) {
      set_node_prefetches(from.node_prefetches());
    }
    if (from.has_node_prefetch_misses()) {
      set_node_prefetch_misses(from.node_prefetch_misses());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void PerfStatistics::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.PerfStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PerfStatistics::CopyFrom(const PerfStatistics& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.PerfStatistics)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PerfStatistics::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void PerfStatistics::Swap(PerfStatistics* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PerfStatistics::InternalSwap(PerfStatistics* other) {
  std::swap(timestamp_, other->timestamp_);
  std::swap(duration_, other->duration_);
  std::swap(cycles_, other->cycles_);
  std::swap(stalled_cycles_frontend_, other->stalled_cycles_frontend_);
  std::swap(stalled_cycles_backend_, other->stalled_cycles_backend_);
  std::swap(instructions_, other->instructions_);
  std::swap(cache_references_, other->cache_references_);
  std::swap(cache_misses_, other->cache_misses_);
  std::swap(branches_, other->branches_);
  std::swap(branch_misses_, other->branch_misses_);
  std::swap(bus_cycles_, other->bus_cycles_);
  std::swap(ref_cycles_, other->ref_cycles_);
  std::swap(cpu_clock_, other->cpu_clock_);
  std::swap(task_clock_, other->task_clock_);
  std::swap(page_faults_, other->page_faults_);
  std::swap(minor_faults_, other->minor_faults_);
  std::swap(major_faults_, other->major_faults_);
  std::swap(context_switches_, other->context_switches_);
  std::swap(cpu_migrations_, other->cpu_migrations_);
  std::swap(alignment_faults_, other->alignment_faults_);
  std::swap(emulation_faults_, other->emulation_faults_);
  std::swap(l1_dcache_loads_, other->l1_dcache_loads_);
  std::swap(l1_dcache_load_misses_, other->l1_dcache_load_misses_);
  std::swap(l1_dcache_stores_, other->l1_dcache_stores_);
  std::swap(l1_dcache_store_misses_, other->l1_dcache_store_misses_);
  std::swap(l1_dcache_prefetches_, other->l1_dcache_prefetches_);
  std::swap(l1_dcache_prefetch_misses_, other->l1_dcache_prefetch_misses_);
  std::swap(l1_icache_loads_, other->l1_icache_loads_);
  std::swap(l1_icache_load_misses_, other->l1_icache_load_misses_);
  std::swap(l1_icache_prefetches_, other->l1_icache_prefetches_);
  std::swap(l1_icache_prefetch_misses_, other->l1_icache_prefetch_misses_);
  std::swap(llc_loads_, other->llc_loads_);
  std::swap(llc_load_misses_, other->llc_load_misses_);
  std::swap(llc_stores_, other->llc_stores_);
  std::swap(llc_store_misses_, other->llc_store_misses_);
  std::swap(llc_prefetches_, other->llc_prefetches_);
  std::swap(llc_prefetch_misses_, other->llc_prefetch_misses_);
  std::swap(dtlb_loads_, other->dtlb_loads_);
  std::swap(dtlb_load_misses_, other->dtlb_load_misses_);
  std::swap(dtlb_stores_, other->dtlb_stores_);
  std::swap(dtlb_store_misses_, other->dtlb_store_misses_);
  std::swap(dtlb_prefetches_, other->dtlb_prefetches_);
  std::swap(dtlb_prefetch_misses_, other->dtlb_prefetch_misses_);
  std::swap(itlb_loads_, other->itlb_loads_);
  std::swap(itlb_load_misses_, other->itlb_load_misses_);
  std::swap(branch_loads_, other->branch_loads_);
  std::swap(branch_load_misses_, other->branch_load_misses_);
  std::swap(node_loads_, other->node_loads_);
  std::swap(node_load_misses_, other->node_load_misses_);
  std::swap(node_stores_, other->node_stores_);
  std::swap(node_store_misses_, other->node_store_misses_);
  std::swap(node_prefetches_, other->node_prefetches_);
  std::swap(node_prefetch_misses_, other->node_prefetch_misses_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  std::swap(_has_bits_[1], other->_has_bits_[1]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PerfStatistics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PerfStatistics_descriptor_;
  metadata.reflection = PerfStatistics_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PerfStatistics

// required double timestamp = 1;
bool PerfStatistics::has_timestamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void PerfStatistics::set_has_timestamp() {
  _has_bits_[0] |= 0x00000001u;
}
void PerfStatistics::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000001u;
}
void PerfStatistics::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
 double PerfStatistics::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.timestamp)
  return timestamp_;
}
 void PerfStatistics::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.timestamp)
}

// required double duration = 2;
bool PerfStatistics::has_duration() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void PerfStatistics::set_has_duration() {
  _has_bits_[0] |= 0x00000002u;
}
void PerfStatistics::clear_has_duration() {
  _has_bits_[0] &= ~0x00000002u;
}
void PerfStatistics::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
 double PerfStatistics::duration() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.duration)
  return duration_;
}
 void PerfStatistics::set_duration(double value) {
  set_has_duration();
  duration_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.duration)
}

// optional uint64 cycles = 3;
bool PerfStatistics::has_cycles() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void PerfStatistics::set_has_cycles() {
  _has_bits_[0] |= 0x00000004u;
}
void PerfStatistics::clear_has_cycles() {
  _has_bits_[0] &= ~0x00000004u;
}
void PerfStatistics::clear_cycles() {
  cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_cycles();
}
 ::google::protobuf::uint64 PerfStatistics::cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cycles)
  return cycles_;
}
 void PerfStatistics::set_cycles(::google::protobuf::uint64 value) {
  set_has_cycles();
  cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cycles)
}

// optional uint64 stalled_cycles_frontend = 4;
bool PerfStatistics::has_stalled_cycles_frontend() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void PerfStatistics::set_has_stalled_cycles_frontend() {
  _has_bits_[0] |= 0x00000008u;
}
void PerfStatistics::clear_has_stalled_cycles_frontend() {
  _has_bits_[0] &= ~0x00000008u;
}
void PerfStatistics::clear_stalled_cycles_frontend() {
  stalled_cycles_frontend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_frontend();
}
 ::google::protobuf::uint64 PerfStatistics::stalled_cycles_frontend() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.stalled_cycles_frontend)
  return stalled_cycles_frontend_;
}
 void PerfStatistics::set_stalled_cycles_frontend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_frontend();
  stalled_cycles_frontend_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.stalled_cycles_frontend)
}

// optional uint64 stalled_cycles_backend = 5;
bool PerfStatistics::has_stalled_cycles_backend() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void PerfStatistics::set_has_stalled_cycles_backend() {
  _has_bits_[0] |= 0x00000010u;
}
void PerfStatistics::clear_has_stalled_cycles_backend() {
  _has_bits_[0] &= ~0x00000010u;
}
void PerfStatistics::clear_stalled_cycles_backend() {
  stalled_cycles_backend_ = GOOGLE_ULONGLONG(0);
  clear_has_stalled_cycles_backend();
}
 ::google::protobuf::uint64 PerfStatistics::stalled_cycles_backend() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.stalled_cycles_backend)
  return stalled_cycles_backend_;
}
 void PerfStatistics::set_stalled_cycles_backend(::google::protobuf::uint64 value) {
  set_has_stalled_cycles_backend();
  stalled_cycles_backend_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.stalled_cycles_backend)
}

// optional uint64 instructions = 6;
bool PerfStatistics::has_instructions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void PerfStatistics::set_has_instructions() {
  _has_bits_[0] |= 0x00000020u;
}
void PerfStatistics::clear_has_instructions() {
  _has_bits_[0] &= ~0x00000020u;
}
void PerfStatistics::clear_instructions() {
  instructions_ = GOOGLE_ULONGLONG(0);
  clear_has_instructions();
}
 ::google::protobuf::uint64 PerfStatistics::instructions() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.instructions)
  return instructions_;
}
 void PerfStatistics::set_instructions(::google::protobuf::uint64 value) {
  set_has_instructions();
  instructions_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.instructions)
}

// optional uint64 cache_references = 7;
bool PerfStatistics::has_cache_references() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void PerfStatistics::set_has_cache_references() {
  _has_bits_[0] |= 0x00000040u;
}
void PerfStatistics::clear_has_cache_references() {
  _has_bits_[0] &= ~0x00000040u;
}
void PerfStatistics::clear_cache_references() {
  cache_references_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_references();
}
 ::google::protobuf::uint64 PerfStatistics::cache_references() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cache_references)
  return cache_references_;
}
 void PerfStatistics::set_cache_references(::google::protobuf::uint64 value) {
  set_has_cache_references();
  cache_references_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cache_references)
}

// optional uint64 cache_misses = 8;
bool PerfStatistics::has_cache_misses() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void PerfStatistics::set_has_cache_misses() {
  _has_bits_[0] |= 0x00000080u;
}
void PerfStatistics::clear_has_cache_misses() {
  _has_bits_[0] &= ~0x00000080u;
}
void PerfStatistics::clear_cache_misses() {
  cache_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_cache_misses();
}
 ::google::protobuf::uint64 PerfStatistics::cache_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cache_misses)
  return cache_misses_;
}
 void PerfStatistics::set_cache_misses(::google::protobuf::uint64 value) {
  set_has_cache_misses();
  cache_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cache_misses)
}

// optional uint64 branches = 9;
bool PerfStatistics::has_branches() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void PerfStatistics::set_has_branches() {
  _has_bits_[0] |= 0x00000100u;
}
void PerfStatistics::clear_has_branches() {
  _has_bits_[0] &= ~0x00000100u;
}
void PerfStatistics::clear_branches() {
  branches_ = GOOGLE_ULONGLONG(0);
  clear_has_branches();
}
 ::google::protobuf::uint64 PerfStatistics::branches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branches)
  return branches_;
}
 void PerfStatistics::set_branches(::google::protobuf::uint64 value) {
  set_has_branches();
  branches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branches)
}

// optional uint64 branch_misses = 10;
bool PerfStatistics::has_branch_misses() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void PerfStatistics::set_has_branch_misses() {
  _has_bits_[0] |= 0x00000200u;
}
void PerfStatistics::clear_has_branch_misses() {
  _has_bits_[0] &= ~0x00000200u;
}
void PerfStatistics::clear_branch_misses() {
  branch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_misses();
}
 ::google::protobuf::uint64 PerfStatistics::branch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_misses)
  return branch_misses_;
}
 void PerfStatistics::set_branch_misses(::google::protobuf::uint64 value) {
  set_has_branch_misses();
  branch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_misses)
}

// optional uint64 bus_cycles = 11;
bool PerfStatistics::has_bus_cycles() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void PerfStatistics::set_has_bus_cycles() {
  _has_bits_[0] |= 0x00000400u;
}
void PerfStatistics::clear_has_bus_cycles() {
  _has_bits_[0] &= ~0x00000400u;
}
void PerfStatistics::clear_bus_cycles() {
  bus_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_bus_cycles();
}
 ::google::protobuf::uint64 PerfStatistics::bus_cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.bus_cycles)
  return bus_cycles_;
}
 void PerfStatistics::set_bus_cycles(::google::protobuf::uint64 value) {
  set_has_bus_cycles();
  bus_cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.bus_cycles)
}

// optional uint64 ref_cycles = 12;
bool PerfStatistics::has_ref_cycles() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void PerfStatistics::set_has_ref_cycles() {
  _has_bits_[0] |= 0x00000800u;
}
void PerfStatistics::clear_has_ref_cycles() {
  _has_bits_[0] &= ~0x00000800u;
}
void PerfStatistics::clear_ref_cycles() {
  ref_cycles_ = GOOGLE_ULONGLONG(0);
  clear_has_ref_cycles();
}
 ::google::protobuf::uint64 PerfStatistics::ref_cycles() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.ref_cycles)
  return ref_cycles_;
}
 void PerfStatistics::set_ref_cycles(::google::protobuf::uint64 value) {
  set_has_ref_cycles();
  ref_cycles_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.ref_cycles)
}

// optional double cpu_clock = 13;
bool PerfStatistics::has_cpu_clock() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void PerfStatistics::set_has_cpu_clock() {
  _has_bits_[0] |= 0x00001000u;
}
void PerfStatistics::clear_has_cpu_clock() {
  _has_bits_[0] &= ~0x00001000u;
}
void PerfStatistics::clear_cpu_clock() {
  cpu_clock_ = 0;
  clear_has_cpu_clock();
}
 double PerfStatistics::cpu_clock() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cpu_clock)
  return cpu_clock_;
}
 void PerfStatistics::set_cpu_clock(double value) {
  set_has_cpu_clock();
  cpu_clock_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cpu_clock)
}

// optional double task_clock = 14;
bool PerfStatistics::has_task_clock() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void PerfStatistics::set_has_task_clock() {
  _has_bits_[0] |= 0x00002000u;
}
void PerfStatistics::clear_has_task_clock() {
  _has_bits_[0] &= ~0x00002000u;
}
void PerfStatistics::clear_task_clock() {
  task_clock_ = 0;
  clear_has_task_clock();
}
 double PerfStatistics::task_clock() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.task_clock)
  return task_clock_;
}
 void PerfStatistics::set_task_clock(double value) {
  set_has_task_clock();
  task_clock_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.task_clock)
}

// optional uint64 page_faults = 15;
bool PerfStatistics::has_page_faults() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void PerfStatistics::set_has_page_faults() {
  _has_bits_[0] |= 0x00004000u;
}
void PerfStatistics::clear_has_page_faults() {
  _has_bits_[0] &= ~0x00004000u;
}
void PerfStatistics::clear_page_faults() {
  page_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_page_faults();
}
 ::google::protobuf::uint64 PerfStatistics::page_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.page_faults)
  return page_faults_;
}
 void PerfStatistics::set_page_faults(::google::protobuf::uint64 value) {
  set_has_page_faults();
  page_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.page_faults)
}

// optional uint64 minor_faults = 16;
bool PerfStatistics::has_minor_faults() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
void PerfStatistics::set_has_minor_faults() {
  _has_bits_[0] |= 0x00008000u;
}
void PerfStatistics::clear_has_minor_faults() {
  _has_bits_[0] &= ~0x00008000u;
}
void PerfStatistics::clear_minor_faults() {
  minor_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_minor_faults();
}
 ::google::protobuf::uint64 PerfStatistics::minor_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.minor_faults)
  return minor_faults_;
}
 void PerfStatistics::set_minor_faults(::google::protobuf::uint64 value) {
  set_has_minor_faults();
  minor_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.minor_faults)
}

// optional uint64 major_faults = 17;
bool PerfStatistics::has_major_faults() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
void PerfStatistics::set_has_major_faults() {
  _has_bits_[0] |= 0x00010000u;
}
void PerfStatistics::clear_has_major_faults() {
  _has_bits_[0] &= ~0x00010000u;
}
void PerfStatistics::clear_major_faults() {
  major_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_major_faults();
}
 ::google::protobuf::uint64 PerfStatistics::major_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.major_faults)
  return major_faults_;
}
 void PerfStatistics::set_major_faults(::google::protobuf::uint64 value) {
  set_has_major_faults();
  major_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.major_faults)
}

// optional uint64 context_switches = 18;
bool PerfStatistics::has_context_switches() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
void PerfStatistics::set_has_context_switches() {
  _has_bits_[0] |= 0x00020000u;
}
void PerfStatistics::clear_has_context_switches() {
  _has_bits_[0] &= ~0x00020000u;
}
void PerfStatistics::clear_context_switches() {
  context_switches_ = GOOGLE_ULONGLONG(0);
  clear_has_context_switches();
}
 ::google::protobuf::uint64 PerfStatistics::context_switches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.context_switches)
  return context_switches_;
}
 void PerfStatistics::set_context_switches(::google::protobuf::uint64 value) {
  set_has_context_switches();
  context_switches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.context_switches)
}

// optional uint64 cpu_migrations = 19;
bool PerfStatistics::has_cpu_migrations() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
void PerfStatistics::set_has_cpu_migrations() {
  _has_bits_[0] |= 0x00040000u;
}
void PerfStatistics::clear_has_cpu_migrations() {
  _has_bits_[0] &= ~0x00040000u;
}
void PerfStatistics::clear_cpu_migrations() {
  cpu_migrations_ = GOOGLE_ULONGLONG(0);
  clear_has_cpu_migrations();
}
 ::google::protobuf::uint64 PerfStatistics::cpu_migrations() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.cpu_migrations)
  return cpu_migrations_;
}
 void PerfStatistics::set_cpu_migrations(::google::protobuf::uint64 value) {
  set_has_cpu_migrations();
  cpu_migrations_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.cpu_migrations)
}

// optional uint64 alignment_faults = 20;
bool PerfStatistics::has_alignment_faults() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
void PerfStatistics::set_has_alignment_faults() {
  _has_bits_[0] |= 0x00080000u;
}
void PerfStatistics::clear_has_alignment_faults() {
  _has_bits_[0] &= ~0x00080000u;
}
void PerfStatistics::clear_alignment_faults() {
  alignment_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_alignment_faults();
}
 ::google::protobuf::uint64 PerfStatistics::alignment_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.alignment_faults)
  return alignment_faults_;
}
 void PerfStatistics::set_alignment_faults(::google::protobuf::uint64 value) {
  set_has_alignment_faults();
  alignment_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.alignment_faults)
}

// optional uint64 emulation_faults = 21;
bool PerfStatistics::has_emulation_faults() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
void PerfStatistics::set_has_emulation_faults() {
  _has_bits_[0] |= 0x00100000u;
}
void PerfStatistics::clear_has_emulation_faults() {
  _has_bits_[0] &= ~0x00100000u;
}
void PerfStatistics::clear_emulation_faults() {
  emulation_faults_ = GOOGLE_ULONGLONG(0);
  clear_has_emulation_faults();
}
 ::google::protobuf::uint64 PerfStatistics::emulation_faults() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.emulation_faults)
  return emulation_faults_;
}
 void PerfStatistics::set_emulation_faults(::google::protobuf::uint64 value) {
  set_has_emulation_faults();
  emulation_faults_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.emulation_faults)
}

// optional uint64 l1_dcache_loads = 22;
bool PerfStatistics::has_l1_dcache_loads() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
void PerfStatistics::set_has_l1_dcache_loads() {
  _has_bits_[0] |= 0x00200000u;
}
void PerfStatistics::clear_has_l1_dcache_loads() {
  _has_bits_[0] &= ~0x00200000u;
}
void PerfStatistics::clear_l1_dcache_loads() {
  l1_dcache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_loads();
}
 ::google::protobuf::uint64 PerfStatistics::l1_dcache_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_loads)
  return l1_dcache_loads_;
}
 void PerfStatistics::set_l1_dcache_loads(::google::protobuf::uint64 value) {
  set_has_l1_dcache_loads();
  l1_dcache_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_loads)
}

// optional uint64 l1_dcache_load_misses = 23;
bool PerfStatistics::has_l1_dcache_load_misses() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
void PerfStatistics::set_has_l1_dcache_load_misses() {
  _has_bits_[0] |= 0x00400000u;
}
void PerfStatistics::clear_has_l1_dcache_load_misses() {
  _has_bits_[0] &= ~0x00400000u;
}
void PerfStatistics::clear_l1_dcache_load_misses() {
  l1_dcache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::l1_dcache_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_load_misses)
  return l1_dcache_load_misses_;
}
 void PerfStatistics::set_l1_dcache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_load_misses();
  l1_dcache_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_load_misses)
}

// optional uint64 l1_dcache_stores = 24;
bool PerfStatistics::has_l1_dcache_stores() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
void PerfStatistics::set_has_l1_dcache_stores() {
  _has_bits_[0] |= 0x00800000u;
}
void PerfStatistics::clear_has_l1_dcache_stores() {
  _has_bits_[0] &= ~0x00800000u;
}
void PerfStatistics::clear_l1_dcache_stores() {
  l1_dcache_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_stores();
}
 ::google::protobuf::uint64 PerfStatistics::l1_dcache_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_stores)
  return l1_dcache_stores_;
}
 void PerfStatistics::set_l1_dcache_stores(::google::protobuf::uint64 value) {
  set_has_l1_dcache_stores();
  l1_dcache_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_stores)
}

// optional uint64 l1_dcache_store_misses = 25;
bool PerfStatistics::has_l1_dcache_store_misses() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
void PerfStatistics::set_has_l1_dcache_store_misses() {
  _has_bits_[0] |= 0x01000000u;
}
void PerfStatistics::clear_has_l1_dcache_store_misses() {
  _has_bits_[0] &= ~0x01000000u;
}
void PerfStatistics::clear_l1_dcache_store_misses() {
  l1_dcache_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_store_misses();
}
 ::google::protobuf::uint64 PerfStatistics::l1_dcache_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_store_misses)
  return l1_dcache_store_misses_;
}
 void PerfStatistics::set_l1_dcache_store_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_store_misses();
  l1_dcache_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_store_misses)
}

// optional uint64 l1_dcache_prefetches = 26;
bool PerfStatistics::has_l1_dcache_prefetches() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
void PerfStatistics::set_has_l1_dcache_prefetches() {
  _has_bits_[0] |= 0x02000000u;
}
void PerfStatistics::clear_has_l1_dcache_prefetches() {
  _has_bits_[0] &= ~0x02000000u;
}
void PerfStatistics::clear_l1_dcache_prefetches() {
  l1_dcache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetches();
}
 ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_prefetches)
  return l1_dcache_prefetches_;
}
 void PerfStatistics::set_l1_dcache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetches();
  l1_dcache_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_prefetches)
}

// optional uint64 l1_dcache_prefetch_misses = 27;
bool PerfStatistics::has_l1_dcache_prefetch_misses() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
void PerfStatistics::set_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] |= 0x04000000u;
}
void PerfStatistics::clear_has_l1_dcache_prefetch_misses() {
  _has_bits_[0] &= ~0x04000000u;
}
void PerfStatistics::clear_l1_dcache_prefetch_misses() {
  l1_dcache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_dcache_prefetch_misses();
}
 ::google::protobuf::uint64 PerfStatistics::l1_dcache_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_dcache_prefetch_misses)
  return l1_dcache_prefetch_misses_;
}
 void PerfStatistics::set_l1_dcache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_dcache_prefetch_misses();
  l1_dcache_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_dcache_prefetch_misses)
}

// optional uint64 l1_icache_loads = 28;
bool PerfStatistics::has_l1_icache_loads() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
void PerfStatistics::set_has_l1_icache_loads() {
  _has_bits_[0] |= 0x08000000u;
}
void PerfStatistics::clear_has_l1_icache_loads() {
  _has_bits_[0] &= ~0x08000000u;
}
void PerfStatistics::clear_l1_icache_loads() {
  l1_icache_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_loads();
}
 ::google::protobuf::uint64 PerfStatistics::l1_icache_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_loads)
  return l1_icache_loads_;
}
 void PerfStatistics::set_l1_icache_loads(::google::protobuf::uint64 value) {
  set_has_l1_icache_loads();
  l1_icache_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_loads)
}

// optional uint64 l1_icache_load_misses = 29;
bool PerfStatistics::has_l1_icache_load_misses() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
void PerfStatistics::set_has_l1_icache_load_misses() {
  _has_bits_[0] |= 0x10000000u;
}
void PerfStatistics::clear_has_l1_icache_load_misses() {
  _has_bits_[0] &= ~0x10000000u;
}
void PerfStatistics::clear_l1_icache_load_misses() {
  l1_icache_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::l1_icache_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_load_misses)
  return l1_icache_load_misses_;
}
 void PerfStatistics::set_l1_icache_load_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_load_misses();
  l1_icache_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_load_misses)
}

// optional uint64 l1_icache_prefetches = 30;
bool PerfStatistics::has_l1_icache_prefetches() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
void PerfStatistics::set_has_l1_icache_prefetches() {
  _has_bits_[0] |= 0x20000000u;
}
void PerfStatistics::clear_has_l1_icache_prefetches() {
  _has_bits_[0] &= ~0x20000000u;
}
void PerfStatistics::clear_l1_icache_prefetches() {
  l1_icache_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetches();
}
 ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_prefetches)
  return l1_icache_prefetches_;
}
 void PerfStatistics::set_l1_icache_prefetches(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetches();
  l1_icache_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_prefetches)
}

// optional uint64 l1_icache_prefetch_misses = 31;
bool PerfStatistics::has_l1_icache_prefetch_misses() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
void PerfStatistics::set_has_l1_icache_prefetch_misses() {
  _has_bits_[0] |= 0x40000000u;
}
void PerfStatistics::clear_has_l1_icache_prefetch_misses() {
  _has_bits_[0] &= ~0x40000000u;
}
void PerfStatistics::clear_l1_icache_prefetch_misses() {
  l1_icache_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_l1_icache_prefetch_misses();
}
 ::google::protobuf::uint64 PerfStatistics::l1_icache_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.l1_icache_prefetch_misses)
  return l1_icache_prefetch_misses_;
}
 void PerfStatistics::set_l1_icache_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_l1_icache_prefetch_misses();
  l1_icache_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.l1_icache_prefetch_misses)
}

// optional uint64 llc_loads = 32;
bool PerfStatistics::has_llc_loads() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
void PerfStatistics::set_has_llc_loads() {
  _has_bits_[0] |= 0x80000000u;
}
void PerfStatistics::clear_has_llc_loads() {
  _has_bits_[0] &= ~0x80000000u;
}
void PerfStatistics::clear_llc_loads() {
  llc_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_loads();
}
 ::google::protobuf::uint64 PerfStatistics::llc_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_loads)
  return llc_loads_;
}
 void PerfStatistics::set_llc_loads(::google::protobuf::uint64 value) {
  set_has_llc_loads();
  llc_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_loads)
}

// optional uint64 llc_load_misses = 33;
bool PerfStatistics::has_llc_load_misses() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
void PerfStatistics::set_has_llc_load_misses() {
  _has_bits_[1] |= 0x00000001u;
}
void PerfStatistics::clear_has_llc_load_misses() {
  _has_bits_[1] &= ~0x00000001u;
}
void PerfStatistics::clear_llc_load_misses() {
  llc_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::llc_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_load_misses)
  return llc_load_misses_;
}
 void PerfStatistics::set_llc_load_misses(::google::protobuf::uint64 value) {
  set_has_llc_load_misses();
  llc_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_load_misses)
}

// optional uint64 llc_stores = 34;
bool PerfStatistics::has_llc_stores() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
void PerfStatistics::set_has_llc_stores() {
  _has_bits_[1] |= 0x00000002u;
}
void PerfStatistics::clear_has_llc_stores() {
  _has_bits_[1] &= ~0x00000002u;
}
void PerfStatistics::clear_llc_stores() {
  llc_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_stores();
}
 ::google::protobuf::uint64 PerfStatistics::llc_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_stores)
  return llc_stores_;
}
 void PerfStatistics::set_llc_stores(::google::protobuf::uint64 value) {
  set_has_llc_stores();
  llc_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_stores)
}

// optional uint64 llc_store_misses = 35;
bool PerfStatistics::has_llc_store_misses() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
void PerfStatistics::set_has_llc_store_misses() {
  _has_bits_[1] |= 0x00000004u;
}
void PerfStatistics::clear_has_llc_store_misses() {
  _has_bits_[1] &= ~0x00000004u;
}
void PerfStatistics::clear_llc_store_misses() {
  llc_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_store_misses();
}
 ::google::protobuf::uint64 PerfStatistics::llc_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_store_misses)
  return llc_store_misses_;
}
 void PerfStatistics::set_llc_store_misses(::google::protobuf::uint64 value) {
  set_has_llc_store_misses();
  llc_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_store_misses)
}

// optional uint64 llc_prefetches = 36;
bool PerfStatistics::has_llc_prefetches() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
void PerfStatistics::set_has_llc_prefetches() {
  _has_bits_[1] |= 0x00000008u;
}
void PerfStatistics::clear_has_llc_prefetches() {
  _has_bits_[1] &= ~0x00000008u;
}
void PerfStatistics::clear_llc_prefetches() {
  llc_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetches();
}
 ::google::protobuf::uint64 PerfStatistics::llc_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_prefetches)
  return llc_prefetches_;
}
 void PerfStatistics::set_llc_prefetches(::google::protobuf::uint64 value) {
  set_has_llc_prefetches();
  llc_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_prefetches)
}

// optional uint64 llc_prefetch_misses = 37;
bool PerfStatistics::has_llc_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000010u) != 0;
}
void PerfStatistics::set_has_llc_prefetch_misses() {
  _has_bits_[1] |= 0x00000010u;
}
void PerfStatistics::clear_has_llc_prefetch_misses() {
  _has_bits_[1] &= ~0x00000010u;
}
void PerfStatistics::clear_llc_prefetch_misses() {
  llc_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_llc_prefetch_misses();
}
 ::google::protobuf::uint64 PerfStatistics::llc_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.llc_prefetch_misses)
  return llc_prefetch_misses_;
}
 void PerfStatistics::set_llc_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_llc_prefetch_misses();
  llc_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.llc_prefetch_misses)
}

// optional uint64 dtlb_loads = 38;
bool PerfStatistics::has_dtlb_loads() const {
  return (_has_bits_[1] & 0x00000020u) != 0;
}
void PerfStatistics::set_has_dtlb_loads() {
  _has_bits_[1] |= 0x00000020u;
}
void PerfStatistics::clear_has_dtlb_loads() {
  _has_bits_[1] &= ~0x00000020u;
}
void PerfStatistics::clear_dtlb_loads() {
  dtlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_loads();
}
 ::google::protobuf::uint64 PerfStatistics::dtlb_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_loads)
  return dtlb_loads_;
}
 void PerfStatistics::set_dtlb_loads(::google::protobuf::uint64 value) {
  set_has_dtlb_loads();
  dtlb_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_loads)
}

// optional uint64 dtlb_load_misses = 39;
bool PerfStatistics::has_dtlb_load_misses() const {
  return (_has_bits_[1] & 0x00000040u) != 0;
}
void PerfStatistics::set_has_dtlb_load_misses() {
  _has_bits_[1] |= 0x00000040u;
}
void PerfStatistics::clear_has_dtlb_load_misses() {
  _has_bits_[1] &= ~0x00000040u;
}
void PerfStatistics::clear_dtlb_load_misses() {
  dtlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::dtlb_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_load_misses)
  return dtlb_load_misses_;
}
 void PerfStatistics::set_dtlb_load_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_load_misses();
  dtlb_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_load_misses)
}

// optional uint64 dtlb_stores = 40;
bool PerfStatistics::has_dtlb_stores() const {
  return (_has_bits_[1] & 0x00000080u) != 0;
}
void PerfStatistics::set_has_dtlb_stores() {
  _has_bits_[1] |= 0x00000080u;
}
void PerfStatistics::clear_has_dtlb_stores() {
  _has_bits_[1] &= ~0x00000080u;
}
void PerfStatistics::clear_dtlb_stores() {
  dtlb_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_stores();
}
 ::google::protobuf::uint64 PerfStatistics::dtlb_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_stores)
  return dtlb_stores_;
}
 void PerfStatistics::set_dtlb_stores(::google::protobuf::uint64 value) {
  set_has_dtlb_stores();
  dtlb_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_stores)
}

// optional uint64 dtlb_store_misses = 41;
bool PerfStatistics::has_dtlb_store_misses() const {
  return (_has_bits_[1] & 0x00000100u) != 0;
}
void PerfStatistics::set_has_dtlb_store_misses() {
  _has_bits_[1] |= 0x00000100u;
}
void PerfStatistics::clear_has_dtlb_store_misses() {
  _has_bits_[1] &= ~0x00000100u;
}
void PerfStatistics::clear_dtlb_store_misses() {
  dtlb_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_store_misses();
}
 ::google::protobuf::uint64 PerfStatistics::dtlb_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_store_misses)
  return dtlb_store_misses_;
}
 void PerfStatistics::set_dtlb_store_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_store_misses();
  dtlb_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_store_misses)
}

// optional uint64 dtlb_prefetches = 42;
bool PerfStatistics::has_dtlb_prefetches() const {
  return (_has_bits_[1] & 0x00000200u) != 0;
}
void PerfStatistics::set_has_dtlb_prefetches() {
  _has_bits_[1] |= 0x00000200u;
}
void PerfStatistics::clear_has_dtlb_prefetches() {
  _has_bits_[1] &= ~0x00000200u;
}
void PerfStatistics::clear_dtlb_prefetches() {
  dtlb_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetches();
}
 ::google::protobuf::uint64 PerfStatistics::dtlb_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_prefetches)
  return dtlb_prefetches_;
}
 void PerfStatistics::set_dtlb_prefetches(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetches();
  dtlb_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_prefetches)
}

// optional uint64 dtlb_prefetch_misses = 43;
bool PerfStatistics::has_dtlb_prefetch_misses() const {
  return (_has_bits_[1] & 0x00000400u) != 0;
}
void PerfStatistics::set_has_dtlb_prefetch_misses() {
  _has_bits_[1] |= 0x00000400u;
}
void PerfStatistics::clear_has_dtlb_prefetch_misses() {
  _has_bits_[1] &= ~0x00000400u;
}
void PerfStatistics::clear_dtlb_prefetch_misses() {
  dtlb_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_dtlb_prefetch_misses();
}
 ::google::protobuf::uint64 PerfStatistics::dtlb_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.dtlb_prefetch_misses)
  return dtlb_prefetch_misses_;
}
 void PerfStatistics::set_dtlb_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_dtlb_prefetch_misses();
  dtlb_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.dtlb_prefetch_misses)
}

// optional uint64 itlb_loads = 44;
bool PerfStatistics::has_itlb_loads() const {
  return (_has_bits_[1] & 0x00000800u) != 0;
}
void PerfStatistics::set_has_itlb_loads() {
  _has_bits_[1] |= 0x00000800u;
}
void PerfStatistics::clear_has_itlb_loads() {
  _has_bits_[1] &= ~0x00000800u;
}
void PerfStatistics::clear_itlb_loads() {
  itlb_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_loads();
}
 ::google::protobuf::uint64 PerfStatistics::itlb_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.itlb_loads)
  return itlb_loads_;
}
 void PerfStatistics::set_itlb_loads(::google::protobuf::uint64 value) {
  set_has_itlb_loads();
  itlb_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.itlb_loads)
}

// optional uint64 itlb_load_misses = 45;
bool PerfStatistics::has_itlb_load_misses() const {
  return (_has_bits_[1] & 0x00001000u) != 0;
}
void PerfStatistics::set_has_itlb_load_misses() {
  _has_bits_[1] |= 0x00001000u;
}
void PerfStatistics::clear_has_itlb_load_misses() {
  _has_bits_[1] &= ~0x00001000u;
}
void PerfStatistics::clear_itlb_load_misses() {
  itlb_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_itlb_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::itlb_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.itlb_load_misses)
  return itlb_load_misses_;
}
 void PerfStatistics::set_itlb_load_misses(::google::protobuf::uint64 value) {
  set_has_itlb_load_misses();
  itlb_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.itlb_load_misses)
}

// optional uint64 branch_loads = 46;
bool PerfStatistics::has_branch_loads() const {
  return (_has_bits_[1] & 0x00002000u) != 0;
}
void PerfStatistics::set_has_branch_loads() {
  _has_bits_[1] |= 0x00002000u;
}
void PerfStatistics::clear_has_branch_loads() {
  _has_bits_[1] &= ~0x00002000u;
}
void PerfStatistics::clear_branch_loads() {
  branch_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_loads();
}
 ::google::protobuf::uint64 PerfStatistics::branch_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_loads)
  return branch_loads_;
}
 void PerfStatistics::set_branch_loads(::google::protobuf::uint64 value) {
  set_has_branch_loads();
  branch_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_loads)
}

// optional uint64 branch_load_misses = 47;
bool PerfStatistics::has_branch_load_misses() const {
  return (_has_bits_[1] & 0x00004000u) != 0;
}
void PerfStatistics::set_has_branch_load_misses() {
  _has_bits_[1] |= 0x00004000u;
}
void PerfStatistics::clear_has_branch_load_misses() {
  _has_bits_[1] &= ~0x00004000u;
}
void PerfStatistics::clear_branch_load_misses() {
  branch_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_branch_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::branch_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.branch_load_misses)
  return branch_load_misses_;
}
 void PerfStatistics::set_branch_load_misses(::google::protobuf::uint64 value) {
  set_has_branch_load_misses();
  branch_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.branch_load_misses)
}

// optional uint64 node_loads = 48;
bool PerfStatistics::has_node_loads() const {
  return (_has_bits_[1] & 0x00008000u) != 0;
}
void PerfStatistics::set_has_node_loads() {
  _has_bits_[1] |= 0x00008000u;
}
void PerfStatistics::clear_has_node_loads() {
  _has_bits_[1] &= ~0x00008000u;
}
void PerfStatistics::clear_node_loads() {
  node_loads_ = GOOGLE_ULONGLONG(0);
  clear_has_node_loads();
}
 ::google::protobuf::uint64 PerfStatistics::node_loads() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_loads)
  return node_loads_;
}
 void PerfStatistics::set_node_loads(::google::protobuf::uint64 value) {
  set_has_node_loads();
  node_loads_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_loads)
}

// optional uint64 node_load_misses = 49;
bool PerfStatistics::has_node_load_misses() const {
  return (_has_bits_[1] & 0x00010000u) != 0;
}
void PerfStatistics::set_has_node_load_misses() {
  _has_bits_[1] |= 0x00010000u;
}
void PerfStatistics::clear_has_node_load_misses() {
  _has_bits_[1] &= ~0x00010000u;
}
void PerfStatistics::clear_node_load_misses() {
  node_load_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_load_misses();
}
 ::google::protobuf::uint64 PerfStatistics::node_load_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_load_misses)
  return node_load_misses_;
}
 void PerfStatistics::set_node_load_misses(::google::protobuf::uint64 value) {
  set_has_node_load_misses();
  node_load_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_load_misses)
}

// optional uint64 node_stores = 50;
bool PerfStatistics::has_node_stores() const {
  return (_has_bits_[1] & 0x00020000u) != 0;
}
void PerfStatistics::set_has_node_stores() {
  _has_bits_[1] |= 0x00020000u;
}
void PerfStatistics::clear_has_node_stores() {
  _has_bits_[1] &= ~0x00020000u;
}
void PerfStatistics::clear_node_stores() {
  node_stores_ = GOOGLE_ULONGLONG(0);
  clear_has_node_stores();
}
 ::google::protobuf::uint64 PerfStatistics::node_stores() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_stores)
  return node_stores_;
}
 void PerfStatistics::set_node_stores(::google::protobuf::uint64 value) {
  set_has_node_stores();
  node_stores_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_stores)
}

// optional uint64 node_store_misses = 51;
bool PerfStatistics::has_node_store_misses() const {
  return (_has_bits_[1] & 0x00040000u) != 0;
}
void PerfStatistics::set_has_node_store_misses() {
  _has_bits_[1] |= 0x00040000u;
}
void PerfStatistics::clear_has_node_store_misses() {
  _has_bits_[1] &= ~0x00040000u;
}
void PerfStatistics::clear_node_store_misses() {
  node_store_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_store_misses();
}
 ::google::protobuf::uint64 PerfStatistics::node_store_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_store_misses)
  return node_store_misses_;
}
 void PerfStatistics::set_node_store_misses(::google::protobuf::uint64 value) {
  set_has_node_store_misses();
  node_store_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_store_misses)
}

// optional uint64 node_prefetches = 52;
bool PerfStatistics::has_node_prefetches() const {
  return (_has_bits_[1] & 0x00080000u) != 0;
}
void PerfStatistics::set_has_node_prefetches() {
  _has_bits_[1] |= 0x00080000u;
}
void PerfStatistics::clear_has_node_prefetches() {
  _has_bits_[1] &= ~0x00080000u;
}
void PerfStatistics::clear_node_prefetches() {
  node_prefetches_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetches();
}
 ::google::protobuf::uint64 PerfStatistics::node_prefetches() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_prefetches)
  return node_prefetches_;
}
 void PerfStatistics::set_node_prefetches(::google::protobuf::uint64 value) {
  set_has_node_prefetches();
  node_prefetches_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_prefetches)
}

// optional uint64 node_prefetch_misses = 53;
bool PerfStatistics::has_node_prefetch_misses() const {
  return (_has_bits_[1] & 0x00100000u) != 0;
}
void PerfStatistics::set_has_node_prefetch_misses() {
  _has_bits_[1] |= 0x00100000u;
}
void PerfStatistics::clear_has_node_prefetch_misses() {
  _has_bits_[1] &= ~0x00100000u;
}
void PerfStatistics::clear_node_prefetch_misses() {
  node_prefetch_misses_ = GOOGLE_ULONGLONG(0);
  clear_has_node_prefetch_misses();
}
 ::google::protobuf::uint64 PerfStatistics::node_prefetch_misses() const {
  // @@protoc_insertion_point(field_get:mesos.PerfStatistics.node_prefetch_misses)
  return node_prefetch_misses_;
}
 void PerfStatistics::set_node_prefetch_misses(::google::protobuf::uint64 value) {
  set_has_node_prefetch_misses();
  node_prefetch_misses_ = value;
  // @@protoc_insertion_point(field_set:mesos.PerfStatistics.node_prefetch_misses)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Request::kSlaveIdFieldNumber;
const int Request::kResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Request::Request()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Request)
}

void Request::InitAsDefaultInstance() {
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
}

Request::Request(const Request& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Request)
}

void Request::SharedCtor() {
  _cached_size_ = 0;
  slave_id_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Request::~Request() {
  // @@protoc_insertion_point(destructor:mesos.Request)
  SharedDtor();
}

void Request::SharedDtor() {
  if (this != default_instance_) {
    delete slave_id_;
  }
}

void Request::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Request::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Request_descriptor_;
}

const Request& Request::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Request* Request::default_instance_ = NULL;

Request* Request::New(::google::protobuf::Arena* arena) const {
  Request* n = new Request;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Request::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Request)
  if (has_slave_id()) {
    if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Request::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Request)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.SlaveID slave_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 2;
      case 2: {
        if (tag == 18) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Request)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Request)
  return false;
#undef DO_
}

void Request::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Request)
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->slave_id_, output);
  }

  // repeated .mesos.Resource resources = 2;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->resources(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Request)
}

::google::protobuf::uint8* Request::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Request)
  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->slave_id_, false, target);
  }

  // repeated .mesos.Resource resources = 2;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->resources(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Request)
  return target;
}

int Request::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Request)
  int total_size = 0;

  // optional .mesos.SlaveID slave_id = 1;
  if (has_slave_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);
  }

  // repeated .mesos.Resource resources = 2;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Request::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Request)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Request* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Request>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Request)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Request)
    MergeFrom(*source);
  }
}

void Request::MergeFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Request)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Request::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Request::CopyFrom(const Request& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Request)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Request::IsInitialized() const {

  if (has_slave_id()) {
    if (!this->slave_id_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Request::Swap(Request* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Request::InternalSwap(Request* other) {
  std::swap(slave_id_, other->slave_id_);
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Request::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Request_descriptor_;
  metadata.reflection = Request_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Request

// optional .mesos.SlaveID slave_id = 1;
bool Request::has_slave_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Request::set_has_slave_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Request::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Request::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
const ::mesos::SlaveID& Request::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.Request.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
::mesos::SlaveID* Request::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Request.slave_id)
  return slave_id_;
}
::mesos::SlaveID* Request::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Request.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
void Request::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Request.slave_id)
}

// repeated .mesos.Resource resources = 2;
int Request::resources_size() const {
  return resources_.size();
}
void Request::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& Request::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Request.resources)
  return resources_.Get(index);
}
::mesos::Resource* Request::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Request.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* Request::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Request.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Request::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Request.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Request::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Request.resources)
  return resources_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Offer_Operation_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Type_descriptor_;
}
bool Offer_Operation_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Offer_Operation_Type Offer_Operation::UNKNOWN;
const Offer_Operation_Type Offer_Operation::LAUNCH;
const Offer_Operation_Type Offer_Operation::LAUNCH_GROUP;
const Offer_Operation_Type Offer_Operation::RESERVE;
const Offer_Operation_Type Offer_Operation::UNRESERVE;
const Offer_Operation_Type Offer_Operation::CREATE;
const Offer_Operation_Type Offer_Operation::DESTROY;
const Offer_Operation_Type Offer_Operation::Type_MIN;
const Offer_Operation_Type Offer_Operation::Type_MAX;
const int Offer_Operation::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation_Launch::kTaskInfosFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation_Launch::Offer_Operation_Launch()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Launch)
}

void Offer_Operation_Launch::InitAsDefaultInstance() {
}

Offer_Operation_Launch::Offer_Operation_Launch(const Offer_Operation_Launch& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Launch)
}

void Offer_Operation_Launch::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Launch::~Offer_Operation_Launch() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Launch)
  SharedDtor();
}

void Offer_Operation_Launch::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Launch::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Launch::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Launch_descriptor_;
}

const Offer_Operation_Launch& Offer_Operation_Launch::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Launch* Offer_Operation_Launch::default_instance_ = NULL;

Offer_Operation_Launch* Offer_Operation_Launch::New(::google::protobuf::Arena* arena) const {
  Offer_Operation_Launch* n = new Offer_Operation_Launch;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation_Launch::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation.Launch)
  task_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation_Launch::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Launch)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.TaskInfo task_infos = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_task_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_task_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_task_infos;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Launch)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Launch)
  return false;
#undef DO_
}

void Offer_Operation_Launch::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Launch)
  // repeated .mesos.TaskInfo task_infos = 1;
  for (unsigned int i = 0, n = this->task_infos_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->task_infos(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Launch)
}

::google::protobuf::uint8* Offer_Operation_Launch::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Launch)
  // repeated .mesos.TaskInfo task_infos = 1;
  for (unsigned int i = 0, n = this->task_infos_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->task_infos(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Launch)
  return target;
}

int Offer_Operation_Launch::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation.Launch)
  int total_size = 0;

  // repeated .mesos.TaskInfo task_infos = 1;
  total_size += 1 * this->task_infos_size();
  for (int i = 0; i < this->task_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->task_infos(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Launch::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation.Launch)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation_Launch* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation_Launch>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation.Launch)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation.Launch)
    MergeFrom(*source);
  }
}

void Offer_Operation_Launch::MergeFrom(const Offer_Operation_Launch& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation.Launch)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  task_infos_.MergeFrom(from.task_infos_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation_Launch::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation.Launch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Launch::CopyFrom(const Offer_Operation_Launch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation.Launch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Launch::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->task_infos())) return false;
  return true;
}

void Offer_Operation_Launch::Swap(Offer_Operation_Launch* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation_Launch::InternalSwap(Offer_Operation_Launch* other) {
  task_infos_.UnsafeArenaSwap(&other->task_infos_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation_Launch::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Launch_descriptor_;
  metadata.reflection = Offer_Operation_Launch_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation_LaunchGroup::kExecutorFieldNumber;
const int Offer_Operation_LaunchGroup::kTaskGroupFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation_LaunchGroup::Offer_Operation_LaunchGroup()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.LaunchGroup)
}

void Offer_Operation_LaunchGroup::InitAsDefaultInstance() {
  executor_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  task_group_ = const_cast< ::mesos::TaskGroupInfo*>(&::mesos::TaskGroupInfo::default_instance());
}

Offer_Operation_LaunchGroup::Offer_Operation_LaunchGroup(const Offer_Operation_LaunchGroup& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.LaunchGroup)
}

void Offer_Operation_LaunchGroup::SharedCtor() {
  _cached_size_ = 0;
  executor_ = NULL;
  task_group_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_LaunchGroup::~Offer_Operation_LaunchGroup() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.LaunchGroup)
  SharedDtor();
}

void Offer_Operation_LaunchGroup::SharedDtor() {
  if (this != default_instance_) {
    delete executor_;
    delete task_group_;
  }
}

void Offer_Operation_LaunchGroup::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_LaunchGroup::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_LaunchGroup_descriptor_;
}

const Offer_Operation_LaunchGroup& Offer_Operation_LaunchGroup::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_LaunchGroup* Offer_Operation_LaunchGroup::default_instance_ = NULL;

Offer_Operation_LaunchGroup* Offer_Operation_LaunchGroup::New(::google::protobuf::Arena* arena) const {
  Offer_Operation_LaunchGroup* n = new Offer_Operation_LaunchGroup;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation_LaunchGroup::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation.LaunchGroup)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_executor()) {
      if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
    }
    if (has_task_group()) {
      if (task_group_ != NULL) task_group_->::mesos::TaskGroupInfo::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation_LaunchGroup::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.LaunchGroup)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ExecutorInfo executor = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_group;
        break;
      }

      // required .mesos.TaskGroupInfo task_group = 2;
      case 2: {
        if (tag == 18) {
         parse_task_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_group()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.LaunchGroup)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.LaunchGroup)
  return false;
#undef DO_
}

void Offer_Operation_LaunchGroup::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.LaunchGroup)
  // required .mesos.ExecutorInfo executor = 1;
  if (has_executor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->executor_, output);
  }

  // required .mesos.TaskGroupInfo task_group = 2;
  if (has_task_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->task_group_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.LaunchGroup)
}

::google::protobuf::uint8* Offer_Operation_LaunchGroup::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.LaunchGroup)
  // required .mesos.ExecutorInfo executor = 1;
  if (has_executor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->executor_, false, target);
  }

  // required .mesos.TaskGroupInfo task_group = 2;
  if (has_task_group()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->task_group_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.LaunchGroup)
  return target;
}

int Offer_Operation_LaunchGroup::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Offer.Operation.LaunchGroup)
  int total_size = 0;

  if (has_executor()) {
    // required .mesos.ExecutorInfo executor = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->executor_);
  }

  if (has_task_group()) {
    // required .mesos.TaskGroupInfo task_group = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_group_);
  }

  return total_size;
}
int Offer_Operation_LaunchGroup::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation.LaunchGroup)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mesos.ExecutorInfo executor = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->executor_);

    // required .mesos.TaskGroupInfo task_group = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_group_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_LaunchGroup::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation.LaunchGroup)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation_LaunchGroup* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation_LaunchGroup>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation.LaunchGroup)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation.LaunchGroup)
    MergeFrom(*source);
  }
}

void Offer_Operation_LaunchGroup::MergeFrom(const Offer_Operation_LaunchGroup& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation.LaunchGroup)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_executor()) {
      mutable_executor()->::mesos::ExecutorInfo::MergeFrom(from.executor());
    }
    if (from.has_task_group()) {
      mutable_task_group()->::mesos::TaskGroupInfo::MergeFrom(from.task_group());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation_LaunchGroup::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation.LaunchGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_LaunchGroup::CopyFrom(const Offer_Operation_LaunchGroup& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation.LaunchGroup)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_LaunchGroup::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_executor()) {
    if (!this->executor_->IsInitialized()) return false;
  }
  if (has_task_group()) {
    if (!this->task_group_->IsInitialized()) return false;
  }
  return true;
}

void Offer_Operation_LaunchGroup::Swap(Offer_Operation_LaunchGroup* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation_LaunchGroup::InternalSwap(Offer_Operation_LaunchGroup* other) {
  std::swap(executor_, other->executor_);
  std::swap(task_group_, other->task_group_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation_LaunchGroup::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_LaunchGroup_descriptor_;
  metadata.reflection = Offer_Operation_LaunchGroup_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation_Reserve::kResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation_Reserve::Offer_Operation_Reserve()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Reserve)
}

void Offer_Operation_Reserve::InitAsDefaultInstance() {
}

Offer_Operation_Reserve::Offer_Operation_Reserve(const Offer_Operation_Reserve& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Reserve)
}

void Offer_Operation_Reserve::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Reserve::~Offer_Operation_Reserve() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Reserve)
  SharedDtor();
}

void Offer_Operation_Reserve::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Reserve::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Reserve::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Reserve_descriptor_;
}

const Offer_Operation_Reserve& Offer_Operation_Reserve::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Reserve* Offer_Operation_Reserve::default_instance_ = NULL;

Offer_Operation_Reserve* Offer_Operation_Reserve::New(::google::protobuf::Arena* arena) const {
  Offer_Operation_Reserve* n = new Offer_Operation_Reserve;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation_Reserve::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation.Reserve)
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation_Reserve::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Reserve)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Reserve)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Reserve)
  return false;
#undef DO_
}

void Offer_Operation_Reserve::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Reserve)
  // repeated .mesos.Resource resources = 1;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Reserve)
}

::google::protobuf::uint8* Offer_Operation_Reserve::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Reserve)
  // repeated .mesos.Resource resources = 1;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->resources(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Reserve)
  return target;
}

int Offer_Operation_Reserve::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation.Reserve)
  int total_size = 0;

  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Reserve::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation.Reserve)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation_Reserve* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation_Reserve>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation.Reserve)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation.Reserve)
    MergeFrom(*source);
  }
}

void Offer_Operation_Reserve::MergeFrom(const Offer_Operation_Reserve& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation.Reserve)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation_Reserve::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation.Reserve)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Reserve::CopyFrom(const Offer_Operation_Reserve& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation.Reserve)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Reserve::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Offer_Operation_Reserve::Swap(Offer_Operation_Reserve* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation_Reserve::InternalSwap(Offer_Operation_Reserve* other) {
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation_Reserve::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Reserve_descriptor_;
  metadata.reflection = Offer_Operation_Reserve_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation_Unreserve::kResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation_Unreserve::Offer_Operation_Unreserve()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Unreserve)
}

void Offer_Operation_Unreserve::InitAsDefaultInstance() {
}

Offer_Operation_Unreserve::Offer_Operation_Unreserve(const Offer_Operation_Unreserve& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Unreserve)
}

void Offer_Operation_Unreserve::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Unreserve::~Offer_Operation_Unreserve() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Unreserve)
  SharedDtor();
}

void Offer_Operation_Unreserve::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Unreserve::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Unreserve::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Unreserve_descriptor_;
}

const Offer_Operation_Unreserve& Offer_Operation_Unreserve::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Unreserve* Offer_Operation_Unreserve::default_instance_ = NULL;

Offer_Operation_Unreserve* Offer_Operation_Unreserve::New(::google::protobuf::Arena* arena) const {
  Offer_Operation_Unreserve* n = new Offer_Operation_Unreserve;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation_Unreserve::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation.Unreserve)
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation_Unreserve::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Unreserve)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource resources = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Unreserve)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Unreserve)
  return false;
#undef DO_
}

void Offer_Operation_Unreserve::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Unreserve)
  // repeated .mesos.Resource resources = 1;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->resources(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Unreserve)
}

::google::protobuf::uint8* Offer_Operation_Unreserve::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Unreserve)
  // repeated .mesos.Resource resources = 1;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->resources(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Unreserve)
  return target;
}

int Offer_Operation_Unreserve::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation.Unreserve)
  int total_size = 0;

  // repeated .mesos.Resource resources = 1;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Unreserve::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation.Unreserve)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation_Unreserve* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation_Unreserve>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation.Unreserve)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation.Unreserve)
    MergeFrom(*source);
  }
}

void Offer_Operation_Unreserve::MergeFrom(const Offer_Operation_Unreserve& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation.Unreserve)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation_Unreserve::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation.Unreserve)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Unreserve::CopyFrom(const Offer_Operation_Unreserve& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation.Unreserve)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Unreserve::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Offer_Operation_Unreserve::Swap(Offer_Operation_Unreserve* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation_Unreserve::InternalSwap(Offer_Operation_Unreserve* other) {
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation_Unreserve::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Unreserve_descriptor_;
  metadata.reflection = Offer_Operation_Unreserve_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation_Create::kVolumesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation_Create::Offer_Operation_Create()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Create)
}

void Offer_Operation_Create::InitAsDefaultInstance() {
}

Offer_Operation_Create::Offer_Operation_Create(const Offer_Operation_Create& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Create)
}

void Offer_Operation_Create::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Create::~Offer_Operation_Create() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Create)
  SharedDtor();
}

void Offer_Operation_Create::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Create::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Create::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Create_descriptor_;
}

const Offer_Operation_Create& Offer_Operation_Create::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Create* Offer_Operation_Create::default_instance_ = NULL;

Offer_Operation_Create* Offer_Operation_Create::New(::google::protobuf::Arena* arena) const {
  Offer_Operation_Create* n = new Offer_Operation_Create;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation_Create::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation.Create)
  volumes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation_Create::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Create)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource volumes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_volumes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_volumes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Create)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Create)
  return false;
#undef DO_
}

void Offer_Operation_Create::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Create)
  // repeated .mesos.Resource volumes = 1;
  for (unsigned int i = 0, n = this->volumes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->volumes(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Create)
}

::google::protobuf::uint8* Offer_Operation_Create::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Create)
  // repeated .mesos.Resource volumes = 1;
  for (unsigned int i = 0, n = this->volumes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->volumes(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Create)
  return target;
}

int Offer_Operation_Create::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation.Create)
  int total_size = 0;

  // repeated .mesos.Resource volumes = 1;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Create::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation.Create)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation_Create* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation_Create>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation.Create)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation.Create)
    MergeFrom(*source);
  }
}

void Offer_Operation_Create::MergeFrom(const Offer_Operation_Create& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation.Create)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  volumes_.MergeFrom(from.volumes_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation_Create::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation.Create)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Create::CopyFrom(const Offer_Operation_Create& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation.Create)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Create::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->volumes())) return false;
  return true;
}

void Offer_Operation_Create::Swap(Offer_Operation_Create* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation_Create::InternalSwap(Offer_Operation_Create* other) {
  volumes_.UnsafeArenaSwap(&other->volumes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation_Create::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Create_descriptor_;
  metadata.reflection = Offer_Operation_Create_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation_Destroy::kVolumesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation_Destroy::Offer_Operation_Destroy()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation.Destroy)
}

void Offer_Operation_Destroy::InitAsDefaultInstance() {
}

Offer_Operation_Destroy::Offer_Operation_Destroy(const Offer_Operation_Destroy& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation.Destroy)
}

void Offer_Operation_Destroy::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation_Destroy::~Offer_Operation_Destroy() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation.Destroy)
  SharedDtor();
}

void Offer_Operation_Destroy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Offer_Operation_Destroy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation_Destroy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_Destroy_descriptor_;
}

const Offer_Operation_Destroy& Offer_Operation_Destroy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation_Destroy* Offer_Operation_Destroy::default_instance_ = NULL;

Offer_Operation_Destroy* Offer_Operation_Destroy::New(::google::protobuf::Arena* arena) const {
  Offer_Operation_Destroy* n = new Offer_Operation_Destroy;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation_Destroy::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation.Destroy)
  volumes_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation_Destroy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation.Destroy)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Resource volumes = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_volumes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_volumes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation.Destroy)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation.Destroy)
  return false;
#undef DO_
}

void Offer_Operation_Destroy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation.Destroy)
  // repeated .mesos.Resource volumes = 1;
  for (unsigned int i = 0, n = this->volumes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->volumes(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation.Destroy)
}

::google::protobuf::uint8* Offer_Operation_Destroy::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation.Destroy)
  // repeated .mesos.Resource volumes = 1;
  for (unsigned int i = 0, n = this->volumes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->volumes(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation.Destroy)
  return target;
}

int Offer_Operation_Destroy::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation.Destroy)
  int total_size = 0;

  // repeated .mesos.Resource volumes = 1;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation_Destroy::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation.Destroy)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation_Destroy* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation_Destroy>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation.Destroy)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation.Destroy)
    MergeFrom(*source);
  }
}

void Offer_Operation_Destroy::MergeFrom(const Offer_Operation_Destroy& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation.Destroy)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  volumes_.MergeFrom(from.volumes_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation_Destroy::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation.Destroy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation_Destroy::CopyFrom(const Offer_Operation_Destroy& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation.Destroy)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation_Destroy::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->volumes())) return false;
  return true;
}

void Offer_Operation_Destroy::Swap(Offer_Operation_Destroy* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation_Destroy::InternalSwap(Offer_Operation_Destroy* other) {
  volumes_.UnsafeArenaSwap(&other->volumes_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation_Destroy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_Destroy_descriptor_;
  metadata.reflection = Offer_Operation_Destroy_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer_Operation::kTypeFieldNumber;
const int Offer_Operation::kLaunchFieldNumber;
const int Offer_Operation::kLaunchGroupFieldNumber;
const int Offer_Operation::kReserveFieldNumber;
const int Offer_Operation::kUnreserveFieldNumber;
const int Offer_Operation::kCreateFieldNumber;
const int Offer_Operation::kDestroyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer_Operation::Offer_Operation()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer.Operation)
}

void Offer_Operation::InitAsDefaultInstance() {
  launch_ = const_cast< ::mesos::Offer_Operation_Launch*>(&::mesos::Offer_Operation_Launch::default_instance());
  launch_group_ = const_cast< ::mesos::Offer_Operation_LaunchGroup*>(&::mesos::Offer_Operation_LaunchGroup::default_instance());
  reserve_ = const_cast< ::mesos::Offer_Operation_Reserve*>(&::mesos::Offer_Operation_Reserve::default_instance());
  unreserve_ = const_cast< ::mesos::Offer_Operation_Unreserve*>(&::mesos::Offer_Operation_Unreserve::default_instance());
  create_ = const_cast< ::mesos::Offer_Operation_Create*>(&::mesos::Offer_Operation_Create::default_instance());
  destroy_ = const_cast< ::mesos::Offer_Operation_Destroy*>(&::mesos::Offer_Operation_Destroy::default_instance());
}

Offer_Operation::Offer_Operation(const Offer_Operation& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer.Operation)
}

void Offer_Operation::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  launch_ = NULL;
  launch_group_ = NULL;
  reserve_ = NULL;
  unreserve_ = NULL;
  create_ = NULL;
  destroy_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer_Operation::~Offer_Operation() {
  // @@protoc_insertion_point(destructor:mesos.Offer.Operation)
  SharedDtor();
}

void Offer_Operation::SharedDtor() {
  if (this != default_instance_) {
    delete launch_;
    delete launch_group_;
    delete reserve_;
    delete unreserve_;
    delete create_;
    delete destroy_;
  }
}

void Offer_Operation::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer_Operation::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_Operation_descriptor_;
}

const Offer_Operation& Offer_Operation::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer_Operation* Offer_Operation::default_instance_ = NULL;

Offer_Operation* Offer_Operation::New(::google::protobuf::Arena* arena) const {
  Offer_Operation* n = new Offer_Operation;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer_Operation::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer.Operation)
  if (_has_bits_[0 / 32] & 127u) {
    type_ = 0;
    if (has_launch()) {
      if (launch_ != NULL) launch_->::mesos::Offer_Operation_Launch::Clear();
    }
    if (has_launch_group()) {
      if (launch_group_ != NULL) launch_group_->::mesos::Offer_Operation_LaunchGroup::Clear();
    }
    if (has_reserve()) {
      if (reserve_ != NULL) reserve_->::mesos::Offer_Operation_Reserve::Clear();
    }
    if (has_unreserve()) {
      if (unreserve_ != NULL) unreserve_->::mesos::Offer_Operation_Unreserve::Clear();
    }
    if (has_create()) {
      if (create_ != NULL) create_->::mesos::Offer_Operation_Create::Clear();
    }
    if (has_destroy()) {
      if (destroy_ != NULL) destroy_->::mesos::Offer_Operation_Destroy::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer_Operation::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer.Operation)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Offer.Operation.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Offer_Operation_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Offer_Operation_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_launch;
        break;
      }

      // optional .mesos.Offer.Operation.Launch launch = 2;
      case 2: {
        if (tag == 18) {
         parse_launch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_launch()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_reserve;
        break;
      }

      // optional .mesos.Offer.Operation.Reserve reserve = 3;
      case 3: {
        if (tag == 26) {
         parse_reserve:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reserve()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_unreserve;
        break;
      }

      // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
      case 4: {
        if (tag == 34) {
         parse_unreserve:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unreserve()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_create;
        break;
      }

      // optional .mesos.Offer.Operation.Create create = 5;
      case 5: {
        if (tag == 42) {
         parse_create:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_create()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_destroy;
        break;
      }

      // optional .mesos.Offer.Operation.Destroy destroy = 6;
      case 6: {
        if (tag == 50) {
         parse_destroy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_destroy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_launch_group;
        break;
      }

      // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
      case 7: {
        if (tag == 58) {
         parse_launch_group:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_launch_group()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer.Operation)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer.Operation)
  return false;
#undef DO_
}

void Offer_Operation::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer.Operation)
  // optional .mesos.Offer.Operation.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Offer.Operation.Launch launch = 2;
  if (has_launch()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->launch_, output);
  }

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  if (has_reserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->reserve_, output);
  }

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  if (has_unreserve()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->unreserve_, output);
  }

  // optional .mesos.Offer.Operation.Create create = 5;
  if (has_create()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->create_, output);
  }

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  if (has_destroy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->destroy_, output);
  }

  // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
  if (has_launch_group()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->launch_group_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer.Operation)
}

::google::protobuf::uint8* Offer_Operation::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer.Operation)
  // optional .mesos.Offer.Operation.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Offer.Operation.Launch launch = 2;
  if (has_launch()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->launch_, false, target);
  }

  // optional .mesos.Offer.Operation.Reserve reserve = 3;
  if (has_reserve()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->reserve_, false, target);
  }

  // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
  if (has_unreserve()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->unreserve_, false, target);
  }

  // optional .mesos.Offer.Operation.Create create = 5;
  if (has_create()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->create_, false, target);
  }

  // optional .mesos.Offer.Operation.Destroy destroy = 6;
  if (has_destroy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->destroy_, false, target);
  }

  // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
  if (has_launch_group()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->launch_group_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer.Operation)
  return target;
}

int Offer_Operation::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer.Operation)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 127u) {
    // optional .mesos.Offer.Operation.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Offer.Operation.Launch launch = 2;
    if (has_launch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->launch_);
    }

    // optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
    if (has_launch_group()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->launch_group_);
    }

    // optional .mesos.Offer.Operation.Reserve reserve = 3;
    if (has_reserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reserve_);
    }

    // optional .mesos.Offer.Operation.Unreserve unreserve = 4;
    if (has_unreserve()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->unreserve_);
    }

    // optional .mesos.Offer.Operation.Create create = 5;
    if (has_create()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->create_);
    }

    // optional .mesos.Offer.Operation.Destroy destroy = 6;
    if (has_destroy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->destroy_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer_Operation::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer.Operation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer_Operation* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer_Operation>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer.Operation)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer.Operation)
    MergeFrom(*source);
  }
}

void Offer_Operation::MergeFrom(const Offer_Operation& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer.Operation)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_launch()) {
      mutable_launch()->::mesos::Offer_Operation_Launch::MergeFrom(from.launch());
    }
    if (from.has_launch_group()) {
      mutable_launch_group()->::mesos::Offer_Operation_LaunchGroup::MergeFrom(from.launch_group());
    }
    if (from.has_reserve()) {
      mutable_reserve()->::mesos::Offer_Operation_Reserve::MergeFrom(from.reserve());
    }
    if (from.has_unreserve()) {
      mutable_unreserve()->::mesos::Offer_Operation_Unreserve::MergeFrom(from.unreserve());
    }
    if (from.has_create()) {
      mutable_create()->::mesos::Offer_Operation_Create::MergeFrom(from.create());
    }
    if (from.has_destroy()) {
      mutable_destroy()->::mesos::Offer_Operation_Destroy::MergeFrom(from.destroy());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer_Operation::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer_Operation::CopyFrom(const Offer_Operation& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer.Operation)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer_Operation::IsInitialized() const {

  if (has_launch()) {
    if (!this->launch_->IsInitialized()) return false;
  }
  if (has_launch_group()) {
    if (!this->launch_group_->IsInitialized()) return false;
  }
  if (has_reserve()) {
    if (!this->reserve_->IsInitialized()) return false;
  }
  if (has_unreserve()) {
    if (!this->unreserve_->IsInitialized()) return false;
  }
  if (has_create()) {
    if (!this->create_->IsInitialized()) return false;
  }
  if (has_destroy()) {
    if (!this->destroy_->IsInitialized()) return false;
  }
  return true;
}

void Offer_Operation::Swap(Offer_Operation* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer_Operation::InternalSwap(Offer_Operation* other) {
  std::swap(type_, other->type_);
  std::swap(launch_, other->launch_);
  std::swap(launch_group_, other->launch_group_);
  std::swap(reserve_, other->reserve_);
  std::swap(unreserve_, other->unreserve_);
  std::swap(create_, other->create_);
  std::swap(destroy_, other->destroy_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer_Operation::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_Operation_descriptor_;
  metadata.reflection = Offer_Operation_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Offer::kIdFieldNumber;
const int Offer::kFrameworkIdFieldNumber;
const int Offer::kSlaveIdFieldNumber;
const int Offer::kHostnameFieldNumber;
const int Offer::kUrlFieldNumber;
const int Offer::kResourcesFieldNumber;
const int Offer::kAttributesFieldNumber;
const int Offer::kExecutorIdsFieldNumber;
const int Offer::kUnavailabilityFieldNumber;
const int Offer::kAllocationInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Offer::Offer()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Offer)
}

void Offer::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  url_ = const_cast< ::mesos::URL*>(&::mesos::URL::default_instance());
  unavailability_ = const_cast< ::mesos::Unavailability*>(&::mesos::Unavailability::default_instance());
  allocation_info_ = const_cast< ::mesos::Resource_AllocationInfo*>(&::mesos::Resource_AllocationInfo::default_instance());
}

Offer::Offer(const Offer& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Offer)
}

void Offer::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  id_ = NULL;
  framework_id_ = NULL;
  slave_id_ = NULL;
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  url_ = NULL;
  unavailability_ = NULL;
  allocation_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Offer::~Offer() {
  // @@protoc_insertion_point(destructor:mesos.Offer)
  SharedDtor();
}

void Offer::SharedDtor() {
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete id_;
    delete framework_id_;
    delete slave_id_;
    delete url_;
    delete unavailability_;
    delete allocation_info_;
  }
}

void Offer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Offer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Offer_descriptor_;
}

const Offer& Offer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Offer* Offer::default_instance_ = NULL;

Offer* Offer::New(::google::protobuf::Arena* arena) const {
  Offer* n = new Offer;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Offer::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Offer)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::OfferID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_url()) {
      if (url_ != NULL) url_->::mesos::URL::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 768u) {
    if (has_unavailability()) {
      if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
    }
    if (has_allocation_info()) {
      if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
    }
  }
  resources_.Clear();
  attributes_.Clear();
  executor_ids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Offer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Offer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 2;
      case 2: {
        if (tag == 18) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 3;
      case 3: {
        if (tag == 26) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_hostname;
        break;
      }

      // required string hostname = 4;
      case 4: {
        if (tag == 34) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Offer.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 5;
      case 5: {
        if (tag == 42) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_resources;
        if (input->ExpectTag(50)) goto parse_loop_executor_ids;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mesos.ExecutorID executor_ids = 6;
      case 6: {
        if (tag == 50) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_executor_ids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_executor_ids()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_executor_ids;
        if (input->ExpectTag(58)) goto parse_loop_attributes;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mesos.Attribute attributes = 7;
      case 7: {
        if (tag == 58) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_attributes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_attributes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_attributes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(66)) goto parse_url;
        break;
      }

      // optional .mesos.URL url = 8;
      case 8: {
        if (tag == 66) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_unavailability;
        break;
      }

      // optional .mesos.Unavailability unavailability = 9;
      case 9: {
        if (tag == 74) {
         parse_unavailability:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unavailability()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_allocation_info;
        break;
      }

      // optional .mesos.Resource.AllocationInfo allocation_info = 10;
      case 10: {
        if (tag == 82) {
         parse_allocation_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_allocation_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Offer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Offer)
  return false;
#undef DO_
}

void Offer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Offer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->framework_id_, output);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->slave_id_, output);
  }

  // required string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Offer.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->hostname(), output);
  }

  // repeated .mesos.Resource resources = 5;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->resources(i), output);
  }

  // repeated .mesos.ExecutorID executor_ids = 6;
  for (unsigned int i = 0, n = this->executor_ids_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->executor_ids(i), output);
  }

  // repeated .mesos.Attribute attributes = 7;
  for (unsigned int i = 0, n = this->attributes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->attributes(i), output);
  }

  // optional .mesos.URL url = 8;
  if (has_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->url_, output);
  }

  // optional .mesos.Unavailability unavailability = 9;
  if (has_unavailability()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->unavailability_, output);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 10;
  if (has_allocation_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->allocation_info_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Offer)
}

::google::protobuf::uint8* Offer::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Offer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // required .mesos.FrameworkID framework_id = 2;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->framework_id_, false, target);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->slave_id_, false, target);
  }

  // required string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Offer.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->hostname(), target);
  }

  // repeated .mesos.Resource resources = 5;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->resources(i), false, target);
  }

  // repeated .mesos.ExecutorID executor_ids = 6;
  for (unsigned int i = 0, n = this->executor_ids_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->executor_ids(i), false, target);
  }

  // repeated .mesos.Attribute attributes = 7;
  for (unsigned int i = 0, n = this->attributes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->attributes(i), false, target);
  }

  // optional .mesos.URL url = 8;
  if (has_url()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->url_, false, target);
  }

  // optional .mesos.Unavailability unavailability = 9;
  if (has_unavailability()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->unavailability_, false, target);
  }

  // optional .mesos.Resource.AllocationInfo allocation_info = 10;
  if (has_allocation_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->allocation_info_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Offer)
  return target;
}

int Offer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Offer)
  int total_size = 0;

  if (has_id()) {
    // required .mesos.OfferID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }

  if (has_framework_id()) {
    // required .mesos.FrameworkID framework_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->framework_id_);
  }

  if (has_slave_id()) {
    // required .mesos.SlaveID slave_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);
  }

  if (has_hostname()) {
    // required string hostname = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->hostname());
  }

  return total_size;
}
int Offer::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Offer)
  int total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .mesos.OfferID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);

    // required .mesos.FrameworkID framework_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->framework_id_);

    // required .mesos.SlaveID slave_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);

    // required string hostname = 4;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->hostname());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .mesos.URL url = 8;
  if (has_url()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->url_);
  }

  if (_has_bits_[8 / 32] & 768u) {
    // optional .mesos.Unavailability unavailability = 9;
    if (has_unavailability()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->unavailability_);
    }

    // optional .mesos.Resource.AllocationInfo allocation_info = 10;
    if (has_allocation_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->allocation_info_);
    }

  }
  // repeated .mesos.Resource resources = 5;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.Attribute attributes = 7;
  total_size += 1 * this->attributes_size();
  for (int i = 0; i < this->attributes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->attributes(i));
  }

  // repeated .mesos.ExecutorID executor_ids = 6;
  total_size += 1 * this->executor_ids_size();
  for (int i = 0; i < this->executor_ids_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->executor_ids(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Offer::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Offer)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Offer* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Offer>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Offer)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Offer)
    MergeFrom(*source);
  }
}

void Offer::MergeFrom(const Offer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Offer)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  attributes_.MergeFrom(from.attributes_);
  executor_ids_.MergeFrom(from.executor_ids_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::mesos::OfferID::MergeFrom(from.id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_url()) {
      mutable_url()->::mesos::URL::MergeFrom(from.url());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_unavailability()) {
      mutable_unavailability()->::mesos::Unavailability::MergeFrom(from.unavailability());
    }
    if (from.has_allocation_info()) {
      mutable_allocation_info()->::mesos::Resource_AllocationInfo::MergeFrom(from.allocation_info());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Offer::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Offer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Offer::CopyFrom(const Offer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Offer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Offer::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id_->IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id_->IsInitialized()) return false;
  }
  if (has_url()) {
    if (!this->url_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->attributes())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->executor_ids())) return false;
  if (has_unavailability()) {
    if (!this->unavailability_->IsInitialized()) return false;
  }
  return true;
}

void Offer::Swap(Offer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Offer::InternalSwap(Offer* other) {
  std::swap(id_, other->id_);
  std::swap(framework_id_, other->framework_id_);
  std::swap(slave_id_, other->slave_id_);
  hostname_.Swap(&other->hostname_);
  std::swap(url_, other->url_);
  resources_.UnsafeArenaSwap(&other->resources_);
  attributes_.UnsafeArenaSwap(&other->attributes_);
  executor_ids_.UnsafeArenaSwap(&other->executor_ids_);
  std::swap(unavailability_, other->unavailability_);
  std::swap(allocation_info_, other->allocation_info_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Offer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Offer_descriptor_;
  metadata.reflection = Offer_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Offer_Operation_Launch

// repeated .mesos.TaskInfo task_infos = 1;
int Offer_Operation_Launch::task_infos_size() const {
  return task_infos_.size();
}
void Offer_Operation_Launch::clear_task_infos() {
  task_infos_.Clear();
}
const ::mesos::TaskInfo& Offer_Operation_Launch::task_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Get(index);
}
::mesos::TaskInfo* Offer_Operation_Launch::mutable_task_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Mutable(index);
}
::mesos::TaskInfo* Offer_Operation_Launch::add_task_infos() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
Offer_Operation_Launch::mutable_task_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Launch.task_infos)
  return &task_infos_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
Offer_Operation_Launch::task_infos() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Launch.task_infos)
  return task_infos_;
}

// -------------------------------------------------------------------

// Offer_Operation_LaunchGroup

// required .mesos.ExecutorInfo executor = 1;
bool Offer_Operation_LaunchGroup::has_executor() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Offer_Operation_LaunchGroup::set_has_executor() {
  _has_bits_[0] |= 0x00000001u;
}
void Offer_Operation_LaunchGroup::clear_has_executor() {
  _has_bits_[0] &= ~0x00000001u;
}
void Offer_Operation_LaunchGroup::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
const ::mesos::ExecutorInfo& Offer_Operation_LaunchGroup::executor() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.LaunchGroup.executor)
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) {
    executor_ = new ::mesos::ExecutorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.LaunchGroup.executor)
  return executor_;
}
::mesos::ExecutorInfo* Offer_Operation_LaunchGroup::release_executor() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.LaunchGroup.executor)
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
void Offer_Operation_LaunchGroup::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  delete executor_;
  executor_ = executor;
  if (executor) {
    set_has_executor();
  } else {
    clear_has_executor();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.LaunchGroup.executor)
}

// required .mesos.TaskGroupInfo task_group = 2;
bool Offer_Operation_LaunchGroup::has_task_group() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Offer_Operation_LaunchGroup::set_has_task_group() {
  _has_bits_[0] |= 0x00000002u;
}
void Offer_Operation_LaunchGroup::clear_has_task_group() {
  _has_bits_[0] &= ~0x00000002u;
}
void Offer_Operation_LaunchGroup::clear_task_group() {
  if (task_group_ != NULL) task_group_->::mesos::TaskGroupInfo::Clear();
  clear_has_task_group();
}
const ::mesos::TaskGroupInfo& Offer_Operation_LaunchGroup::task_group() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.LaunchGroup.task_group)
  return task_group_ != NULL ? *task_group_ : *default_instance_->task_group_;
}
::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::mutable_task_group() {
  set_has_task_group();
  if (task_group_ == NULL) {
    task_group_ = new ::mesos::TaskGroupInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.LaunchGroup.task_group)
  return task_group_;
}
::mesos::TaskGroupInfo* Offer_Operation_LaunchGroup::release_task_group() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.LaunchGroup.task_group)
  clear_has_task_group();
  ::mesos::TaskGroupInfo* temp = task_group_;
  task_group_ = NULL;
  return temp;
}
void Offer_Operation_LaunchGroup::set_allocated_task_group(::mesos::TaskGroupInfo* task_group) {
  delete task_group_;
  task_group_ = task_group;
  if (task_group) {
    set_has_task_group();
  } else {
    clear_has_task_group();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.LaunchGroup.task_group)
}

// -------------------------------------------------------------------

// Offer_Operation_Reserve

// repeated .mesos.Resource resources = 1;
int Offer_Operation_Reserve::resources_size() const {
  return resources_.size();
}
void Offer_Operation_Reserve::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& Offer_Operation_Reserve::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Reserve.resources)
  return resources_.Get(index);
}
::mesos::Resource* Offer_Operation_Reserve::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Reserve.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* Offer_Operation_Reserve::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Reserve.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Reserve::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Reserve.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Reserve::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Reserve.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Unreserve

// repeated .mesos.Resource resources = 1;
int Offer_Operation_Unreserve::resources_size() const {
  return resources_.size();
}
void Offer_Operation_Unreserve::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& Offer_Operation_Unreserve::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Get(index);
}
::mesos::Resource* Offer_Operation_Unreserve::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* Offer_Operation_Unreserve::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Unreserve.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Unreserve::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Unreserve.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Unreserve::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Unreserve.resources)
  return resources_;
}

// -------------------------------------------------------------------

// Offer_Operation_Create

// repeated .mesos.Resource volumes = 1;
int Offer_Operation_Create::volumes_size() const {
  return volumes_.size();
}
void Offer_Operation_Create::clear_volumes() {
  volumes_.Clear();
}
const ::mesos::Resource& Offer_Operation_Create::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Create.volumes)
  return volumes_.Get(index);
}
::mesos::Resource* Offer_Operation_Create::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Create.volumes)
  return volumes_.Mutable(index);
}
::mesos::Resource* Offer_Operation_Create::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Create.volumes)
  return volumes_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Create::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Create.volumes)
  return &volumes_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Create::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Create.volumes)
  return volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation_Destroy

// repeated .mesos.Resource volumes = 1;
int Offer_Operation_Destroy::volumes_size() const {
  return volumes_.size();
}
void Offer_Operation_Destroy::clear_volumes() {
  volumes_.Clear();
}
const ::mesos::Resource& Offer_Operation_Destroy::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Get(index);
}
::mesos::Resource* Offer_Operation_Destroy::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Mutable(index);
}
::mesos::Resource* Offer_Operation_Destroy::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.Operation.Destroy.volumes)
  return volumes_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer_Operation_Destroy::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.Operation.Destroy.volumes)
  return &volumes_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer_Operation_Destroy::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.Operation.Destroy.volumes)
  return volumes_;
}

// -------------------------------------------------------------------

// Offer_Operation

// optional .mesos.Offer.Operation.Type type = 1;
bool Offer_Operation::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Offer_Operation::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Offer_Operation::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Offer_Operation::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Offer_Operation_Type Offer_Operation::type() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.type)
  return static_cast< ::mesos::Offer_Operation_Type >(type_);
}
 void Offer_Operation::set_type(::mesos::Offer_Operation_Type value) {
  assert(::mesos::Offer_Operation_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Offer.Operation.type)
}

// optional .mesos.Offer.Operation.Launch launch = 2;
bool Offer_Operation::has_launch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Offer_Operation::set_has_launch() {
  _has_bits_[0] |= 0x00000002u;
}
void Offer_Operation::clear_has_launch() {
  _has_bits_[0] &= ~0x00000002u;
}
void Offer_Operation::clear_launch() {
  if (launch_ != NULL) launch_->::mesos::Offer_Operation_Launch::Clear();
  clear_has_launch();
}
const ::mesos::Offer_Operation_Launch& Offer_Operation::launch() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.launch)
  return launch_ != NULL ? *launch_ : *default_instance_->launch_;
}
::mesos::Offer_Operation_Launch* Offer_Operation::mutable_launch() {
  set_has_launch();
  if (launch_ == NULL) {
    launch_ = new ::mesos::Offer_Operation_Launch;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.launch)
  return launch_;
}
::mesos::Offer_Operation_Launch* Offer_Operation::release_launch() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.launch)
  clear_has_launch();
  ::mesos::Offer_Operation_Launch* temp = launch_;
  launch_ = NULL;
  return temp;
}
void Offer_Operation::set_allocated_launch(::mesos::Offer_Operation_Launch* launch) {
  delete launch_;
  launch_ = launch;
  if (launch) {
    set_has_launch();
  } else {
    clear_has_launch();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.launch)
}

// optional .mesos.Offer.Operation.LaunchGroup launch_group = 7;
bool Offer_Operation::has_launch_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Offer_Operation::set_has_launch_group() {
  _has_bits_[0] |= 0x00000004u;
}
void Offer_Operation::clear_has_launch_group() {
  _has_bits_[0] &= ~0x00000004u;
}
void Offer_Operation::clear_launch_group() {
  if (launch_group_ != NULL) launch_group_->::mesos::Offer_Operation_LaunchGroup::Clear();
  clear_has_launch_group();
}
const ::mesos::Offer_Operation_LaunchGroup& Offer_Operation::launch_group() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.launch_group)
  return launch_group_ != NULL ? *launch_group_ : *default_instance_->launch_group_;
}
::mesos::Offer_Operation_LaunchGroup* Offer_Operation::mutable_launch_group() {
  set_has_launch_group();
  if (launch_group_ == NULL) {
    launch_group_ = new ::mesos::Offer_Operation_LaunchGroup;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.launch_group)
  return launch_group_;
}
::mesos::Offer_Operation_LaunchGroup* Offer_Operation::release_launch_group() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.launch_group)
  clear_has_launch_group();
  ::mesos::Offer_Operation_LaunchGroup* temp = launch_group_;
  launch_group_ = NULL;
  return temp;
}
void Offer_Operation::set_allocated_launch_group(::mesos::Offer_Operation_LaunchGroup* launch_group) {
  delete launch_group_;
  launch_group_ = launch_group;
  if (launch_group) {
    set_has_launch_group();
  } else {
    clear_has_launch_group();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.launch_group)
}

// optional .mesos.Offer.Operation.Reserve reserve = 3;
bool Offer_Operation::has_reserve() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Offer_Operation::set_has_reserve() {
  _has_bits_[0] |= 0x00000008u;
}
void Offer_Operation::clear_has_reserve() {
  _has_bits_[0] &= ~0x00000008u;
}
void Offer_Operation::clear_reserve() {
  if (reserve_ != NULL) reserve_->::mesos::Offer_Operation_Reserve::Clear();
  clear_has_reserve();
}
const ::mesos::Offer_Operation_Reserve& Offer_Operation::reserve() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.reserve)
  return reserve_ != NULL ? *reserve_ : *default_instance_->reserve_;
}
::mesos::Offer_Operation_Reserve* Offer_Operation::mutable_reserve() {
  set_has_reserve();
  if (reserve_ == NULL) {
    reserve_ = new ::mesos::Offer_Operation_Reserve;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.reserve)
  return reserve_;
}
::mesos::Offer_Operation_Reserve* Offer_Operation::release_reserve() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.reserve)
  clear_has_reserve();
  ::mesos::Offer_Operation_Reserve* temp = reserve_;
  reserve_ = NULL;
  return temp;
}
void Offer_Operation::set_allocated_reserve(::mesos::Offer_Operation_Reserve* reserve) {
  delete reserve_;
  reserve_ = reserve;
  if (reserve) {
    set_has_reserve();
  } else {
    clear_has_reserve();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.reserve)
}

// optional .mesos.Offer.Operation.Unreserve unreserve = 4;
bool Offer_Operation::has_unreserve() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Offer_Operation::set_has_unreserve() {
  _has_bits_[0] |= 0x00000010u;
}
void Offer_Operation::clear_has_unreserve() {
  _has_bits_[0] &= ~0x00000010u;
}
void Offer_Operation::clear_unreserve() {
  if (unreserve_ != NULL) unreserve_->::mesos::Offer_Operation_Unreserve::Clear();
  clear_has_unreserve();
}
const ::mesos::Offer_Operation_Unreserve& Offer_Operation::unreserve() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.unreserve)
  return unreserve_ != NULL ? *unreserve_ : *default_instance_->unreserve_;
}
::mesos::Offer_Operation_Unreserve* Offer_Operation::mutable_unreserve() {
  set_has_unreserve();
  if (unreserve_ == NULL) {
    unreserve_ = new ::mesos::Offer_Operation_Unreserve;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.unreserve)
  return unreserve_;
}
::mesos::Offer_Operation_Unreserve* Offer_Operation::release_unreserve() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.unreserve)
  clear_has_unreserve();
  ::mesos::Offer_Operation_Unreserve* temp = unreserve_;
  unreserve_ = NULL;
  return temp;
}
void Offer_Operation::set_allocated_unreserve(::mesos::Offer_Operation_Unreserve* unreserve) {
  delete unreserve_;
  unreserve_ = unreserve;
  if (unreserve) {
    set_has_unreserve();
  } else {
    clear_has_unreserve();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.unreserve)
}

// optional .mesos.Offer.Operation.Create create = 5;
bool Offer_Operation::has_create() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Offer_Operation::set_has_create() {
  _has_bits_[0] |= 0x00000020u;
}
void Offer_Operation::clear_has_create() {
  _has_bits_[0] &= ~0x00000020u;
}
void Offer_Operation::clear_create() {
  if (create_ != NULL) create_->::mesos::Offer_Operation_Create::Clear();
  clear_has_create();
}
const ::mesos::Offer_Operation_Create& Offer_Operation::create() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.create)
  return create_ != NULL ? *create_ : *default_instance_->create_;
}
::mesos::Offer_Operation_Create* Offer_Operation::mutable_create() {
  set_has_create();
  if (create_ == NULL) {
    create_ = new ::mesos::Offer_Operation_Create;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.create)
  return create_;
}
::mesos::Offer_Operation_Create* Offer_Operation::release_create() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.create)
  clear_has_create();
  ::mesos::Offer_Operation_Create* temp = create_;
  create_ = NULL;
  return temp;
}
void Offer_Operation::set_allocated_create(::mesos::Offer_Operation_Create* create) {
  delete create_;
  create_ = create;
  if (create) {
    set_has_create();
  } else {
    clear_has_create();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.create)
}

// optional .mesos.Offer.Operation.Destroy destroy = 6;
bool Offer_Operation::has_destroy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void Offer_Operation::set_has_destroy() {
  _has_bits_[0] |= 0x00000040u;
}
void Offer_Operation::clear_has_destroy() {
  _has_bits_[0] &= ~0x00000040u;
}
void Offer_Operation::clear_destroy() {
  if (destroy_ != NULL) destroy_->::mesos::Offer_Operation_Destroy::Clear();
  clear_has_destroy();
}
const ::mesos::Offer_Operation_Destroy& Offer_Operation::destroy() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.Operation.destroy)
  return destroy_ != NULL ? *destroy_ : *default_instance_->destroy_;
}
::mesos::Offer_Operation_Destroy* Offer_Operation::mutable_destroy() {
  set_has_destroy();
  if (destroy_ == NULL) {
    destroy_ = new ::mesos::Offer_Operation_Destroy;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.Operation.destroy)
  return destroy_;
}
::mesos::Offer_Operation_Destroy* Offer_Operation::release_destroy() {
  // @@protoc_insertion_point(field_release:mesos.Offer.Operation.destroy)
  clear_has_destroy();
  ::mesos::Offer_Operation_Destroy* temp = destroy_;
  destroy_ = NULL;
  return temp;
}
void Offer_Operation::set_allocated_destroy(::mesos::Offer_Operation_Destroy* destroy) {
  delete destroy_;
  destroy_ = destroy;
  if (destroy) {
    set_has_destroy();
  } else {
    clear_has_destroy();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.Operation.destroy)
}

// -------------------------------------------------------------------

// Offer

// required .mesos.OfferID id = 1;
bool Offer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Offer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void Offer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void Offer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
const ::mesos::OfferID& Offer::id() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::mesos::OfferID* Offer::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::mesos::OfferID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.id)
  return id_;
}
::mesos::OfferID* Offer::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.id)
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
void Offer::set_allocated_id(::mesos::OfferID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.id)
}

// required .mesos.FrameworkID framework_id = 2;
bool Offer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Offer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Offer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Offer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
const ::mesos::FrameworkID& Offer::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
::mesos::FrameworkID* Offer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    framework_id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.framework_id)
  return framework_id_;
}
::mesos::FrameworkID* Offer::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
void Offer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.framework_id)
}

// required .mesos.SlaveID slave_id = 3;
bool Offer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Offer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
void Offer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void Offer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
const ::mesos::SlaveID& Offer::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
::mesos::SlaveID* Offer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.slave_id)
  return slave_id_;
}
::mesos::SlaveID* Offer::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Offer.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
void Offer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.slave_id)
}

// required string hostname = 4;
bool Offer::has_hostname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Offer::set_has_hostname() {
  _has_bits_[0] |= 0x00000008u;
}
void Offer::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000008u;
}
void Offer::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& Offer::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Offer::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Offer.hostname)
}
 void Offer::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Offer.hostname)
}
 void Offer::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Offer.hostname)
}
 ::std::string* Offer::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.Offer.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Offer::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.Offer.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Offer::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.hostname)
}

// optional .mesos.URL url = 8;
bool Offer::has_url() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Offer::set_has_url() {
  _has_bits_[0] |= 0x00000010u;
}
void Offer::clear_has_url() {
  _has_bits_[0] &= ~0x00000010u;
}
void Offer::clear_url() {
  if (url_ != NULL) url_->::mesos::URL::Clear();
  clear_has_url();
}
const ::mesos::URL& Offer::url() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.url)
  return url_ != NULL ? *url_ : *default_instance_->url_;
}
::mesos::URL* Offer::mutable_url() {
  set_has_url();
  if (url_ == NULL) {
    url_ = new ::mesos::URL;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.url)
  return url_;
}
::mesos::URL* Offer::release_url() {
  // @@protoc_insertion_point(field_release:mesos.Offer.url)
  clear_has_url();
  ::mesos::URL* temp = url_;
  url_ = NULL;
  return temp;
}
void Offer::set_allocated_url(::mesos::URL* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.url)
}

// repeated .mesos.Resource resources = 5;
int Offer::resources_size() const {
  return resources_.size();
}
void Offer::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& Offer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.resources)
  return resources_.Get(index);
}
::mesos::Resource* Offer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* Offer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Offer.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Offer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Offer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.resources)
  return resources_;
}

// repeated .mesos.Attribute attributes = 7;
int Offer::attributes_size() const {
  return attributes_.size();
}
void Offer::clear_attributes() {
  attributes_.Clear();
}
const ::mesos::Attribute& Offer::attributes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.attributes)
  return attributes_.Get(index);
}
::mesos::Attribute* Offer::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.attributes)
  return attributes_.Mutable(index);
}
::mesos::Attribute* Offer::add_attributes() {
  // @@protoc_insertion_point(field_add:mesos.Offer.attributes)
  return attributes_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Attribute >*
Offer::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.attributes)
  return &attributes_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Attribute >&
Offer::attributes() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.attributes)
  return attributes_;
}

// repeated .mesos.ExecutorID executor_ids = 6;
int Offer::executor_ids_size() const {
  return executor_ids_.size();
}
void Offer::clear_executor_ids() {
  executor_ids_.Clear();
}
const ::mesos::ExecutorID& Offer::executor_ids(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Offer.executor_ids)
  return executor_ids_.Get(index);
}
::mesos::ExecutorID* Offer::mutable_executor_ids(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Offer.executor_ids)
  return executor_ids_.Mutable(index);
}
::mesos::ExecutorID* Offer::add_executor_ids() {
  // @@protoc_insertion_point(field_add:mesos.Offer.executor_ids)
  return executor_ids_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >*
Offer::mutable_executor_ids() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Offer.executor_ids)
  return &executor_ids_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::ExecutorID >&
Offer::executor_ids() const {
  // @@protoc_insertion_point(field_list:mesos.Offer.executor_ids)
  return executor_ids_;
}

// optional .mesos.Unavailability unavailability = 9;
bool Offer::has_unavailability() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Offer::set_has_unavailability() {
  _has_bits_[0] |= 0x00000100u;
}
void Offer::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000100u;
}
void Offer::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
  clear_has_unavailability();
}
const ::mesos::Unavailability& Offer::unavailability() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.unavailability)
  return unavailability_ != NULL ? *unavailability_ : *default_instance_->unavailability_;
}
::mesos::Unavailability* Offer::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) {
    unavailability_ = new ::mesos::Unavailability;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.unavailability)
  return unavailability_;
}
::mesos::Unavailability* Offer::release_unavailability() {
  // @@protoc_insertion_point(field_release:mesos.Offer.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
void Offer::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  delete unavailability_;
  unavailability_ = unavailability;
  if (unavailability) {
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.unavailability)
}

// optional .mesos.Resource.AllocationInfo allocation_info = 10;
bool Offer::has_allocation_info() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Offer::set_has_allocation_info() {
  _has_bits_[0] |= 0x00000200u;
}
void Offer::clear_has_allocation_info() {
  _has_bits_[0] &= ~0x00000200u;
}
void Offer::clear_allocation_info() {
  if (allocation_info_ != NULL) allocation_info_->::mesos::Resource_AllocationInfo::Clear();
  clear_has_allocation_info();
}
const ::mesos::Resource_AllocationInfo& Offer::allocation_info() const {
  // @@protoc_insertion_point(field_get:mesos.Offer.allocation_info)
  return allocation_info_ != NULL ? *allocation_info_ : *default_instance_->allocation_info_;
}
::mesos::Resource_AllocationInfo* Offer::mutable_allocation_info() {
  set_has_allocation_info();
  if (allocation_info_ == NULL) {
    allocation_info_ = new ::mesos::Resource_AllocationInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Offer.allocation_info)
  return allocation_info_;
}
::mesos::Resource_AllocationInfo* Offer::release_allocation_info() {
  // @@protoc_insertion_point(field_release:mesos.Offer.allocation_info)
  clear_has_allocation_info();
  ::mesos::Resource_AllocationInfo* temp = allocation_info_;
  allocation_info_ = NULL;
  return temp;
}
void Offer::set_allocated_allocation_info(::mesos::Resource_AllocationInfo* allocation_info) {
  delete allocation_info_;
  allocation_info_ = allocation_info;
  if (allocation_info) {
    set_has_allocation_info();
  } else {
    clear_has_allocation_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Offer.allocation_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int InverseOffer::kIdFieldNumber;
const int InverseOffer::kUrlFieldNumber;
const int InverseOffer::kFrameworkIdFieldNumber;
const int InverseOffer::kSlaveIdFieldNumber;
const int InverseOffer::kUnavailabilityFieldNumber;
const int InverseOffer::kResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

InverseOffer::InverseOffer()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.InverseOffer)
}

void InverseOffer::InitAsDefaultInstance() {
  id_ = const_cast< ::mesos::OfferID*>(&::mesos::OfferID::default_instance());
  url_ = const_cast< ::mesos::URL*>(&::mesos::URL::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  unavailability_ = const_cast< ::mesos::Unavailability*>(&::mesos::Unavailability::default_instance());
}

InverseOffer::InverseOffer(const InverseOffer& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.InverseOffer)
}

void InverseOffer::SharedCtor() {
  _cached_size_ = 0;
  id_ = NULL;
  url_ = NULL;
  framework_id_ = NULL;
  slave_id_ = NULL;
  unavailability_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

InverseOffer::~InverseOffer() {
  // @@protoc_insertion_point(destructor:mesos.InverseOffer)
  SharedDtor();
}

void InverseOffer::SharedDtor() {
  if (this != default_instance_) {
    delete id_;
    delete url_;
    delete framework_id_;
    delete slave_id_;
    delete unavailability_;
  }
}

void InverseOffer::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* InverseOffer::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return InverseOffer_descriptor_;
}

const InverseOffer& InverseOffer::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

InverseOffer* InverseOffer::default_instance_ = NULL;

InverseOffer* InverseOffer::New(::google::protobuf::Arena* arena) const {
  InverseOffer* n = new InverseOffer;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void InverseOffer::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.InverseOffer)
  if (_has_bits_[0 / 32] & 31u) {
    if (has_id()) {
      if (id_ != NULL) id_->::mesos::OfferID::Clear();
    }
    if (has_url()) {
      if (url_ != NULL) url_->::mesos::URL::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_unavailability()) {
      if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool InverseOffer::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.InverseOffer)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.OfferID id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_url;
        break;
      }

      // optional .mesos.URL url = 2;
      case 2: {
        if (tag == 18) {
         parse_url:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_url()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (tag == 26) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 4;
      case 4: {
        if (tag == 34) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_unavailability;
        break;
      }

      // required .mesos.Unavailability unavailability = 5;
      case 5: {
        if (tag == 42) {
         parse_unavailability:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unavailability()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 6;
      case 6: {
        if (tag == 50) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.InverseOffer)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.InverseOffer)
  return false;
#undef DO_
}

void InverseOffer::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.InverseOffer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->id_, output);
  }

  // optional .mesos.URL url = 2;
  if (has_url()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->url_, output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->framework_id_, output);
  }

  // optional .mesos.SlaveID slave_id = 4;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->slave_id_, output);
  }

  // required .mesos.Unavailability unavailability = 5;
  if (has_unavailability()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->unavailability_, output);
  }

  // repeated .mesos.Resource resources = 6;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->resources(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.InverseOffer)
}

::google::protobuf::uint8* InverseOffer::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.InverseOffer)
  // required .mesos.OfferID id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->id_, false, target);
  }

  // optional .mesos.URL url = 2;
  if (has_url()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->url_, false, target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->framework_id_, false, target);
  }

  // optional .mesos.SlaveID slave_id = 4;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->slave_id_, false, target);
  }

  // required .mesos.Unavailability unavailability = 5;
  if (has_unavailability()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->unavailability_, false, target);
  }

  // repeated .mesos.Resource resources = 6;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, this->resources(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.InverseOffer)
  return target;
}

int InverseOffer::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.InverseOffer)
  int total_size = 0;

  if (has_id()) {
    // required .mesos.OfferID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);
  }

  if (has_framework_id()) {
    // required .mesos.FrameworkID framework_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->framework_id_);
  }

  if (has_unavailability()) {
    // required .mesos.Unavailability unavailability = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->unavailability_);
  }

  return total_size;
}
int InverseOffer::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.InverseOffer)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000015) ^ 0x00000015) == 0) {  // All required fields are present.
    // required .mesos.OfferID id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->id_);

    // required .mesos.FrameworkID framework_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->framework_id_);

    // required .mesos.Unavailability unavailability = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->unavailability_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[1 / 32] & 10u) {
    // optional .mesos.URL url = 2;
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->url_);
    }

    // optional .mesos.SlaveID slave_id = 4;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->slave_id_);
    }

  }
  // repeated .mesos.Resource resources = 6;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void InverseOffer::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.InverseOffer)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const InverseOffer* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const InverseOffer>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.InverseOffer)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.InverseOffer)
    MergeFrom(*source);
  }
}

void InverseOffer::MergeFrom(const InverseOffer& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.InverseOffer)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      mutable_id()->::mesos::OfferID::MergeFrom(from.id());
    }
    if (from.has_url()) {
      mutable_url()->::mesos::URL::MergeFrom(from.url());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_unavailability()) {
      mutable_unavailability()->::mesos::Unavailability::MergeFrom(from.unavailability());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void InverseOffer::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.InverseOffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void InverseOffer::CopyFrom(const InverseOffer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.InverseOffer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool InverseOffer::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000015) != 0x00000015) return false;

  if (has_id()) {
    if (!this->id_->IsInitialized()) return false;
  }
  if (has_url()) {
    if (!this->url_->IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id_->IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id_->IsInitialized()) return false;
  }
  if (has_unavailability()) {
    if (!this->unavailability_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void InverseOffer::Swap(InverseOffer* other) {
  if (other == this) return;
  InternalSwap(other);
}
void InverseOffer::InternalSwap(InverseOffer* other) {
  std::swap(id_, other->id_);
  std::swap(url_, other->url_);
  std::swap(framework_id_, other->framework_id_);
  std::swap(slave_id_, other->slave_id_);
  std::swap(unavailability_, other->unavailability_);
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata InverseOffer::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = InverseOffer_descriptor_;
  metadata.reflection = InverseOffer_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// InverseOffer

// required .mesos.OfferID id = 1;
bool InverseOffer::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void InverseOffer::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
void InverseOffer::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void InverseOffer::clear_id() {
  if (id_ != NULL) id_->::mesos::OfferID::Clear();
  clear_has_id();
}
const ::mesos::OfferID& InverseOffer::id() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
::mesos::OfferID* InverseOffer::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::mesos::OfferID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.id)
  return id_;
}
::mesos::OfferID* InverseOffer::release_id() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.id)
  clear_has_id();
  ::mesos::OfferID* temp = id_;
  id_ = NULL;
  return temp;
}
void InverseOffer::set_allocated_id(::mesos::OfferID* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.id)
}

// optional .mesos.URL url = 2;
bool InverseOffer::has_url() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void InverseOffer::set_has_url() {
  _has_bits_[0] |= 0x00000002u;
}
void InverseOffer::clear_has_url() {
  _has_bits_[0] &= ~0x00000002u;
}
void InverseOffer::clear_url() {
  if (url_ != NULL) url_->::mesos::URL::Clear();
  clear_has_url();
}
const ::mesos::URL& InverseOffer::url() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.url)
  return url_ != NULL ? *url_ : *default_instance_->url_;
}
::mesos::URL* InverseOffer::mutable_url() {
  set_has_url();
  if (url_ == NULL) {
    url_ = new ::mesos::URL;
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.url)
  return url_;
}
::mesos::URL* InverseOffer::release_url() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.url)
  clear_has_url();
  ::mesos::URL* temp = url_;
  url_ = NULL;
  return temp;
}
void InverseOffer::set_allocated_url(::mesos::URL* url) {
  delete url_;
  url_ = url;
  if (url) {
    set_has_url();
  } else {
    clear_has_url();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.url)
}

// required .mesos.FrameworkID framework_id = 3;
bool InverseOffer::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void InverseOffer::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
void InverseOffer::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void InverseOffer::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
const ::mesos::FrameworkID& InverseOffer::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
::mesos::FrameworkID* InverseOffer::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    framework_id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.framework_id)
  return framework_id_;
}
::mesos::FrameworkID* InverseOffer::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
void InverseOffer::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.framework_id)
}

// optional .mesos.SlaveID slave_id = 4;
bool InverseOffer::has_slave_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void InverseOffer::set_has_slave_id() {
  _has_bits_[0] |= 0x00000008u;
}
void InverseOffer::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void InverseOffer::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
const ::mesos::SlaveID& InverseOffer::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
::mesos::SlaveID* InverseOffer::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.slave_id)
  return slave_id_;
}
::mesos::SlaveID* InverseOffer::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
void InverseOffer::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.slave_id)
}

// required .mesos.Unavailability unavailability = 5;
bool InverseOffer::has_unavailability() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void InverseOffer::set_has_unavailability() {
  _has_bits_[0] |= 0x00000010u;
}
void InverseOffer::clear_has_unavailability() {
  _has_bits_[0] &= ~0x00000010u;
}
void InverseOffer::clear_unavailability() {
  if (unavailability_ != NULL) unavailability_->::mesos::Unavailability::Clear();
  clear_has_unavailability();
}
const ::mesos::Unavailability& InverseOffer::unavailability() const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.unavailability)
  return unavailability_ != NULL ? *unavailability_ : *default_instance_->unavailability_;
}
::mesos::Unavailability* InverseOffer::mutable_unavailability() {
  set_has_unavailability();
  if (unavailability_ == NULL) {
    unavailability_ = new ::mesos::Unavailability;
  }
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.unavailability)
  return unavailability_;
}
::mesos::Unavailability* InverseOffer::release_unavailability() {
  // @@protoc_insertion_point(field_release:mesos.InverseOffer.unavailability)
  clear_has_unavailability();
  ::mesos::Unavailability* temp = unavailability_;
  unavailability_ = NULL;
  return temp;
}
void InverseOffer::set_allocated_unavailability(::mesos::Unavailability* unavailability) {
  delete unavailability_;
  unavailability_ = unavailability;
  if (unavailability) {
    set_has_unavailability();
  } else {
    clear_has_unavailability();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.InverseOffer.unavailability)
}

// repeated .mesos.Resource resources = 6;
int InverseOffer::resources_size() const {
  return resources_.size();
}
void InverseOffer::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& InverseOffer::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.InverseOffer.resources)
  return resources_.Get(index);
}
::mesos::Resource* InverseOffer::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.InverseOffer.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* InverseOffer::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.InverseOffer.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
InverseOffer::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.InverseOffer.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
InverseOffer::resources() const {
  // @@protoc_insertion_point(field_list:mesos.InverseOffer.resources)
  return resources_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TaskInfo::kNameFieldNumber;
const int TaskInfo::kTaskIdFieldNumber;
const int TaskInfo::kSlaveIdFieldNumber;
const int TaskInfo::kResourcesFieldNumber;
const int TaskInfo::kExecutorFieldNumber;
const int TaskInfo::kCommandFieldNumber;
const int TaskInfo::kContainerFieldNumber;
const int TaskInfo::kHealthCheckFieldNumber;
const int TaskInfo::kCheckFieldNumber;
const int TaskInfo::kKillPolicyFieldNumber;
const int TaskInfo::kDataFieldNumber;
const int TaskInfo::kLabelsFieldNumber;
const int TaskInfo::kDiscoveryFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TaskInfo::TaskInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskInfo)
}

void TaskInfo::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_ = const_cast< ::mesos::ExecutorInfo*>(&::mesos::ExecutorInfo::default_instance());
  command_ = const_cast< ::mesos::CommandInfo*>(&::mesos::CommandInfo::default_instance());
  container_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
  health_check_ = const_cast< ::mesos::HealthCheck*>(&::mesos::HealthCheck::default_instance());
  check_ = const_cast< ::mesos::CheckInfo*>(&::mesos::CheckInfo::default_instance());
  kill_policy_ = const_cast< ::mesos::KillPolicy*>(&::mesos::KillPolicy::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
}

TaskInfo::TaskInfo(const TaskInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskInfo)
}

void TaskInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_ = NULL;
  slave_id_ = NULL;
  executor_ = NULL;
  command_ = NULL;
  container_ = NULL;
  health_check_ = NULL;
  check_ = NULL;
  kill_policy_ = NULL;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  discovery_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskInfo::~TaskInfo() {
  // @@protoc_insertion_point(destructor:mesos.TaskInfo)
  SharedDtor();
}

void TaskInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete task_id_;
    delete slave_id_;
    delete executor_;
    delete command_;
    delete container_;
    delete health_check_;
    delete check_;
    delete kill_policy_;
    delete labels_;
    delete discovery_;
  }
}

void TaskInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskInfo_descriptor_;
}

const TaskInfo& TaskInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskInfo* TaskInfo::default_instance_ = NULL;

TaskInfo* TaskInfo::New(::google::protobuf::Arena* arena) const {
  TaskInfo* n = new TaskInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TaskInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TaskInfo)
  if (_has_bits_[0 / 32] & 247u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor()) {
      if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
    }
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
    }
    if (has_health_check()) {
      if (health_check_ != NULL) health_check_->::mesos::HealthCheck::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 7936u) {
    if (has_check()) {
      if (check_ != NULL) check_->::mesos::CheckInfo::Clear();
    }
    if (has_kill_policy()) {
      if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
    }
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
  }
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TaskInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.TaskInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 3;
      case 3: {
        if (tag == 26) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 4;
      case 4: {
        if (tag == 34) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(42)) goto parse_executor;
        break;
      }

      // optional .mesos.ExecutorInfo executor = 5;
      case 5: {
        if (tag == 42) {
         parse_executor:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_data;
        break;
      }

      // optional bytes data = 6;
      case 6: {
        if (tag == 50) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_command;
        break;
      }

      // optional .mesos.CommandInfo command = 7;
      case 7: {
        if (tag == 58) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_health_check;
        break;
      }

      // optional .mesos.HealthCheck health_check = 8;
      case 8: {
        if (tag == 66) {
         parse_health_check:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_health_check()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_container;
        break;
      }

      // optional .mesos.ContainerInfo container = 9;
      case 9: {
        if (tag == 74) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 10;
      case 10: {
        if (tag == 82) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 11;
      case 11: {
        if (tag == 90) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_kill_policy;
        break;
      }

      // optional .mesos.KillPolicy kill_policy = 12;
      case 12: {
        if (tag == 98) {
         parse_kill_policy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_kill_policy()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_check;
        break;
      }

      // optional .mesos.CheckInfo check = 13;
      case 13: {
        if (tag == 106) {
         parse_check:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_check()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskInfo)
  return false;
#undef DO_
}

void TaskInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TaskInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->task_id_, output);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->slave_id_, output);
  }

  // repeated .mesos.Resource resources = 4;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->resources(i), output);
  }

  // optional .mesos.ExecutorInfo executor = 5;
  if (has_executor()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->executor_, output);
  }

  // optional bytes data = 6;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      6, this->data(), output);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->command_, output);
  }

  // optional .mesos.HealthCheck health_check = 8;
  if (has_health_check()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->health_check_, output);
  }

  // optional .mesos.ContainerInfo container = 9;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->container_, output);
  }

  // optional .mesos.Labels labels = 10;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->labels_, output);
  }

  // optional .mesos.DiscoveryInfo discovery = 11;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->discovery_, output);
  }

  // optional .mesos.KillPolicy kill_policy = 12;
  if (has_kill_policy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->kill_policy_, output);
  }

  // optional .mesos.CheckInfo check = 13;
  if (has_check()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->check_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskInfo)
}

::google::protobuf::uint8* TaskInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskInfo)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TaskInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->task_id_, false, target);
  }

  // required .mesos.SlaveID slave_id = 3;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->slave_id_, false, target);
  }

  // repeated .mesos.Resource resources = 4;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->resources(i), false, target);
  }

  // optional .mesos.ExecutorInfo executor = 5;
  if (has_executor()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->executor_, false, target);
  }

  // optional bytes data = 6;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        6, this->data(), target);
  }

  // optional .mesos.CommandInfo command = 7;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->command_, false, target);
  }

  // optional .mesos.HealthCheck health_check = 8;
  if (has_health_check()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->health_check_, false, target);
  }

  // optional .mesos.ContainerInfo container = 9;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->container_, false, target);
  }

  // optional .mesos.Labels labels = 10;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->labels_, false, target);
  }

  // optional .mesos.DiscoveryInfo discovery = 11;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->discovery_, false, target);
  }

  // optional .mesos.KillPolicy kill_policy = 12;
  if (has_kill_policy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *this->kill_policy_, false, target);
  }

  // optional .mesos.CheckInfo check = 13;
  if (has_check()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->check_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskInfo)
  return target;
}

int TaskInfo::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.TaskInfo)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_task_id()) {
    // required .mesos.TaskID task_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_id_);
  }

  if (has_slave_id()) {
    // required .mesos.SlaveID slave_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);
  }

  return total_size;
}
int TaskInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TaskInfo)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required .mesos.TaskID task_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_id_);

    // required .mesos.SlaveID slave_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[4 / 32] & 240u) {
    // optional .mesos.ExecutorInfo executor = 5;
    if (has_executor()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->executor_);
    }

    // optional .mesos.CommandInfo command = 7;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->command_);
    }

    // optional .mesos.ContainerInfo container = 9;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->container_);
    }

    // optional .mesos.HealthCheck health_check = 8;
    if (has_health_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->health_check_);
    }

  }
  if (_has_bits_[8 / 32] & 7936u) {
    // optional .mesos.CheckInfo check = 13;
    if (has_check()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->check_);
    }

    // optional .mesos.KillPolicy kill_policy = 12;
    if (has_kill_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->kill_policy_);
    }

    // optional bytes data = 6;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .mesos.Labels labels = 10;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

    // optional .mesos.DiscoveryInfo discovery = 11;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->discovery_);
    }

  }
  // repeated .mesos.Resource resources = 4;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TaskInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TaskInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TaskInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TaskInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TaskInfo)
    MergeFrom(*source);
  }
}

void TaskInfo::MergeFrom(const TaskInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TaskInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor()) {
      mutable_executor()->::mesos::ExecutorInfo::MergeFrom(from.executor());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CommandInfo::MergeFrom(from.command());
    }
    if (from.has_container()) {
      mutable_container()->::mesos::ContainerInfo::MergeFrom(from.container());
    }
    if (from.has_health_check()) {
      mutable_health_check()->::mesos::HealthCheck::MergeFrom(from.health_check());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_check()) {
      mutable_check()->::mesos::CheckInfo::MergeFrom(from.check());
    }
    if (from.has_kill_policy()) {
      mutable_kill_policy()->::mesos::KillPolicy::MergeFrom(from.kill_policy());
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TaskInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TaskInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskInfo::CopyFrom(const TaskInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TaskInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  if (has_task_id()) {
    if (!this->task_id_->IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (has_executor()) {
    if (!this->executor_->IsInitialized()) return false;
  }
  if (has_command()) {
    if (!this->command_->IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container_->IsInitialized()) return false;
  }
  if (has_health_check()) {
    if (!this->health_check_->IsInitialized()) return false;
  }
  if (has_check()) {
    if (!this->check_->IsInitialized()) return false;
  }
  if (has_kill_policy()) {
    if (!this->kill_policy_->IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  if (has_discovery()) {
    if (!this->discovery_->IsInitialized()) return false;
  }
  return true;
}

void TaskInfo::Swap(TaskInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TaskInfo::InternalSwap(TaskInfo* other) {
  name_.Swap(&other->name_);
  std::swap(task_id_, other->task_id_);
  std::swap(slave_id_, other->slave_id_);
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(executor_, other->executor_);
  std::swap(command_, other->command_);
  std::swap(container_, other->container_);
  std::swap(health_check_, other->health_check_);
  std::swap(check_, other->check_);
  std::swap(kill_policy_, other->kill_policy_);
  data_.Swap(&other->data_);
  std::swap(labels_, other->labels_);
  std::swap(discovery_, other->discovery_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TaskInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskInfo_descriptor_;
  metadata.reflection = TaskInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TaskInfo

// required string name = 1;
bool TaskInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TaskInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void TaskInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void TaskInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& TaskInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TaskInfo.name)
}
 void TaskInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TaskInfo.name)
}
 void TaskInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskInfo.name)
}
 ::std::string* TaskInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TaskInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.name)
}

// required .mesos.TaskID task_id = 2;
bool TaskInfo::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TaskInfo::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
void TaskInfo::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void TaskInfo::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
const ::mesos::TaskID& TaskInfo::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
::mesos::TaskID* TaskInfo::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    task_id_ = new ::mesos::TaskID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.task_id)
  return task_id_;
}
::mesos::TaskID* TaskInfo::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.task_id)
}

// required .mesos.SlaveID slave_id = 3;
bool TaskInfo::has_slave_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TaskInfo::set_has_slave_id() {
  _has_bits_[0] |= 0x00000004u;
}
void TaskInfo::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void TaskInfo::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
const ::mesos::SlaveID& TaskInfo::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
::mesos::SlaveID* TaskInfo::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.slave_id)
  return slave_id_;
}
::mesos::SlaveID* TaskInfo::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.slave_id)
}

// repeated .mesos.Resource resources = 4;
int TaskInfo::resources_size() const {
  return resources_.size();
}
void TaskInfo::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& TaskInfo::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.resources)
  return resources_.Get(index);
}
::mesos::Resource* TaskInfo::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* TaskInfo::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.TaskInfo.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
TaskInfo::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskInfo.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
TaskInfo::resources() const {
  // @@protoc_insertion_point(field_list:mesos.TaskInfo.resources)
  return resources_;
}

// optional .mesos.ExecutorInfo executor = 5;
bool TaskInfo::has_executor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TaskInfo::set_has_executor() {
  _has_bits_[0] |= 0x00000010u;
}
void TaskInfo::clear_has_executor() {
  _has_bits_[0] &= ~0x00000010u;
}
void TaskInfo::clear_executor() {
  if (executor_ != NULL) executor_->::mesos::ExecutorInfo::Clear();
  clear_has_executor();
}
const ::mesos::ExecutorInfo& TaskInfo::executor() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.executor)
  return executor_ != NULL ? *executor_ : *default_instance_->executor_;
}
::mesos::ExecutorInfo* TaskInfo::mutable_executor() {
  set_has_executor();
  if (executor_ == NULL) {
    executor_ = new ::mesos::ExecutorInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.executor)
  return executor_;
}
::mesos::ExecutorInfo* TaskInfo::release_executor() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.executor)
  clear_has_executor();
  ::mesos::ExecutorInfo* temp = executor_;
  executor_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_executor(::mesos::ExecutorInfo* executor) {
  delete executor_;
  executor_ = executor;
  if (executor) {
    set_has_executor();
  } else {
    clear_has_executor();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.executor)
}

// optional .mesos.CommandInfo command = 7;
bool TaskInfo::has_command() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TaskInfo::set_has_command() {
  _has_bits_[0] |= 0x00000020u;
}
void TaskInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000020u;
}
void TaskInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CommandInfo::Clear();
  clear_has_command();
}
const ::mesos::CommandInfo& TaskInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
::mesos::CommandInfo* TaskInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CommandInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.command)
  return command_;
}
::mesos::CommandInfo* TaskInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.command)
  clear_has_command();
  ::mesos::CommandInfo* temp = command_;
  command_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_command(::mesos::CommandInfo* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.command)
}

// optional .mesos.ContainerInfo container = 9;
bool TaskInfo::has_container() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TaskInfo::set_has_container() {
  _has_bits_[0] |= 0x00000040u;
}
void TaskInfo::clear_has_container() {
  _has_bits_[0] &= ~0x00000040u;
}
void TaskInfo::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
const ::mesos::ContainerInfo& TaskInfo::container() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
::mesos::ContainerInfo* TaskInfo::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    container_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.container)
  return container_;
}
::mesos::ContainerInfo* TaskInfo::release_container() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.container)
}

// optional .mesos.HealthCheck health_check = 8;
bool TaskInfo::has_health_check() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TaskInfo::set_has_health_check() {
  _has_bits_[0] |= 0x00000080u;
}
void TaskInfo::clear_has_health_check() {
  _has_bits_[0] &= ~0x00000080u;
}
void TaskInfo::clear_health_check() {
  if (health_check_ != NULL) health_check_->::mesos::HealthCheck::Clear();
  clear_has_health_check();
}
const ::mesos::HealthCheck& TaskInfo::health_check() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.health_check)
  return health_check_ != NULL ? *health_check_ : *default_instance_->health_check_;
}
::mesos::HealthCheck* TaskInfo::mutable_health_check() {
  set_has_health_check();
  if (health_check_ == NULL) {
    health_check_ = new ::mesos::HealthCheck;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.health_check)
  return health_check_;
}
::mesos::HealthCheck* TaskInfo::release_health_check() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.health_check)
  clear_has_health_check();
  ::mesos::HealthCheck* temp = health_check_;
  health_check_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_health_check(::mesos::HealthCheck* health_check) {
  delete health_check_;
  health_check_ = health_check;
  if (health_check) {
    set_has_health_check();
  } else {
    clear_has_health_check();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.health_check)
}

// optional .mesos.CheckInfo check = 13;
bool TaskInfo::has_check() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TaskInfo::set_has_check() {
  _has_bits_[0] |= 0x00000100u;
}
void TaskInfo::clear_has_check() {
  _has_bits_[0] &= ~0x00000100u;
}
void TaskInfo::clear_check() {
  if (check_ != NULL) check_->::mesos::CheckInfo::Clear();
  clear_has_check();
}
const ::mesos::CheckInfo& TaskInfo::check() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.check)
  return check_ != NULL ? *check_ : *default_instance_->check_;
}
::mesos::CheckInfo* TaskInfo::mutable_check() {
  set_has_check();
  if (check_ == NULL) {
    check_ = new ::mesos::CheckInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.check)
  return check_;
}
::mesos::CheckInfo* TaskInfo::release_check() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.check)
  clear_has_check();
  ::mesos::CheckInfo* temp = check_;
  check_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_check(::mesos::CheckInfo* check) {
  delete check_;
  check_ = check;
  if (check) {
    set_has_check();
  } else {
    clear_has_check();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.check)
}

// optional .mesos.KillPolicy kill_policy = 12;
bool TaskInfo::has_kill_policy() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TaskInfo::set_has_kill_policy() {
  _has_bits_[0] |= 0x00000200u;
}
void TaskInfo::clear_has_kill_policy() {
  _has_bits_[0] &= ~0x00000200u;
}
void TaskInfo::clear_kill_policy() {
  if (kill_policy_ != NULL) kill_policy_->::mesos::KillPolicy::Clear();
  clear_has_kill_policy();
}
const ::mesos::KillPolicy& TaskInfo::kill_policy() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.kill_policy)
  return kill_policy_ != NULL ? *kill_policy_ : *default_instance_->kill_policy_;
}
::mesos::KillPolicy* TaskInfo::mutable_kill_policy() {
  set_has_kill_policy();
  if (kill_policy_ == NULL) {
    kill_policy_ = new ::mesos::KillPolicy;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.kill_policy)
  return kill_policy_;
}
::mesos::KillPolicy* TaskInfo::release_kill_policy() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.kill_policy)
  clear_has_kill_policy();
  ::mesos::KillPolicy* temp = kill_policy_;
  kill_policy_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_kill_policy(::mesos::KillPolicy* kill_policy) {
  delete kill_policy_;
  kill_policy_ = kill_policy;
  if (kill_policy) {
    set_has_kill_policy();
  } else {
    clear_has_kill_policy();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.kill_policy)
}

// optional bytes data = 6;
bool TaskInfo::has_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void TaskInfo::set_has_data() {
  _has_bits_[0] |= 0x00000400u;
}
void TaskInfo::clear_has_data() {
  _has_bits_[0] &= ~0x00000400u;
}
void TaskInfo::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& TaskInfo::data() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskInfo::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TaskInfo.data)
}
 void TaskInfo::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TaskInfo.data)
}
 void TaskInfo::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskInfo.data)
}
 ::std::string* TaskInfo::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TaskInfo::release_data() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskInfo::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.data)
}

// optional .mesos.Labels labels = 10;
bool TaskInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void TaskInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000800u;
}
void TaskInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000800u;
}
void TaskInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& TaskInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* TaskInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.labels)
  return labels_;
}
::mesos::Labels* TaskInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.labels)
}

// optional .mesos.DiscoveryInfo discovery = 11;
bool TaskInfo::has_discovery() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void TaskInfo::set_has_discovery() {
  _has_bits_[0] |= 0x00001000u;
}
void TaskInfo::clear_has_discovery() {
  _has_bits_[0] &= ~0x00001000u;
}
void TaskInfo::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
const ::mesos::DiscoveryInfo& TaskInfo::discovery() const {
  // @@protoc_insertion_point(field_get:mesos.TaskInfo.discovery)
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
::mesos::DiscoveryInfo* TaskInfo::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) {
    discovery_ = new ::mesos::DiscoveryInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskInfo.discovery)
  return discovery_;
}
::mesos::DiscoveryInfo* TaskInfo::release_discovery() {
  // @@protoc_insertion_point(field_release:mesos.TaskInfo.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
void TaskInfo::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskInfo.discovery)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TaskGroupInfo::kTasksFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TaskGroupInfo::TaskGroupInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskGroupInfo)
}

void TaskGroupInfo::InitAsDefaultInstance() {
}

TaskGroupInfo::TaskGroupInfo(const TaskGroupInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskGroupInfo)
}

void TaskGroupInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskGroupInfo::~TaskGroupInfo() {
  // @@protoc_insertion_point(destructor:mesos.TaskGroupInfo)
  SharedDtor();
}

void TaskGroupInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TaskGroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskGroupInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskGroupInfo_descriptor_;
}

const TaskGroupInfo& TaskGroupInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskGroupInfo* TaskGroupInfo::default_instance_ = NULL;

TaskGroupInfo* TaskGroupInfo::New(::google::protobuf::Arena* arena) const {
  TaskGroupInfo* n = new TaskGroupInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TaskGroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TaskGroupInfo)
  tasks_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TaskGroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskGroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.TaskInfo tasks = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_tasks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_tasks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_tasks;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskGroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskGroupInfo)
  return false;
#undef DO_
}

void TaskGroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskGroupInfo)
  // repeated .mesos.TaskInfo tasks = 1;
  for (unsigned int i = 0, n = this->tasks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->tasks(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskGroupInfo)
}

::google::protobuf::uint8* TaskGroupInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskGroupInfo)
  // repeated .mesos.TaskInfo tasks = 1;
  for (unsigned int i = 0, n = this->tasks_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->tasks(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskGroupInfo)
  return target;
}

int TaskGroupInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TaskGroupInfo)
  int total_size = 0;

  // repeated .mesos.TaskInfo tasks = 1;
  total_size += 1 * this->tasks_size();
  for (int i = 0; i < this->tasks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->tasks(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskGroupInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TaskGroupInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TaskGroupInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TaskGroupInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TaskGroupInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TaskGroupInfo)
    MergeFrom(*source);
  }
}

void TaskGroupInfo::MergeFrom(const TaskGroupInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TaskGroupInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  tasks_.MergeFrom(from.tasks_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TaskGroupInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TaskGroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskGroupInfo::CopyFrom(const TaskGroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TaskGroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskGroupInfo::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->tasks())) return false;
  return true;
}

void TaskGroupInfo::Swap(TaskGroupInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TaskGroupInfo::InternalSwap(TaskGroupInfo* other) {
  tasks_.UnsafeArenaSwap(&other->tasks_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TaskGroupInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskGroupInfo_descriptor_;
  metadata.reflection = TaskGroupInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TaskGroupInfo

// repeated .mesos.TaskInfo tasks = 1;
int TaskGroupInfo::tasks_size() const {
  return tasks_.size();
}
void TaskGroupInfo::clear_tasks() {
  tasks_.Clear();
}
const ::mesos::TaskInfo& TaskGroupInfo::tasks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.TaskGroupInfo.tasks)
  return tasks_.Get(index);
}
::mesos::TaskInfo* TaskGroupInfo::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.TaskGroupInfo.tasks)
  return tasks_.Mutable(index);
}
::mesos::TaskInfo* TaskGroupInfo::add_tasks() {
  // @@protoc_insertion_point(field_add:mesos.TaskGroupInfo.tasks)
  return tasks_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >*
TaskGroupInfo::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.TaskGroupInfo.tasks)
  return &tasks_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::TaskInfo >&
TaskGroupInfo::tasks() const {
  // @@protoc_insertion_point(field_list:mesos.TaskGroupInfo.tasks)
  return tasks_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Task::kNameFieldNumber;
const int Task::kTaskIdFieldNumber;
const int Task::kFrameworkIdFieldNumber;
const int Task::kExecutorIdFieldNumber;
const int Task::kSlaveIdFieldNumber;
const int Task::kStateFieldNumber;
const int Task::kResourcesFieldNumber;
const int Task::kStatusesFieldNumber;
const int Task::kStatusUpdateStateFieldNumber;
const int Task::kStatusUpdateUuidFieldNumber;
const int Task::kLabelsFieldNumber;
const int Task::kDiscoveryFieldNumber;
const int Task::kContainerFieldNumber;
const int Task::kUserFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Task::Task()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Task)
}

void Task::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  framework_id_ = const_cast< ::mesos::FrameworkID*>(&::mesos::FrameworkID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  discovery_ = const_cast< ::mesos::DiscoveryInfo*>(&::mesos::DiscoveryInfo::default_instance());
  container_ = const_cast< ::mesos::ContainerInfo*>(&::mesos::ContainerInfo::default_instance());
}

Task::Task(const Task& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Task)
}

void Task::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  task_id_ = NULL;
  framework_id_ = NULL;
  executor_id_ = NULL;
  slave_id_ = NULL;
  state_ = 6;
  status_update_state_ = 6;
  status_update_uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  discovery_ = NULL;
  container_ = NULL;
  user_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Task::~Task() {
  // @@protoc_insertion_point(destructor:mesos.Task)
  SharedDtor();
}

void Task::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  status_update_uuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  user_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete task_id_;
    delete framework_id_;
    delete executor_id_;
    delete slave_id_;
    delete labels_;
    delete discovery_;
    delete container_;
  }
}

void Task::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Task::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Task_descriptor_;
}

const Task& Task::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Task* Task::default_instance_ = NULL;

Task* Task::New(::google::protobuf::Arena* arena) const {
  Task* n = new Task;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Task::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Task)
  if (_has_bits_[0 / 32] & 63u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    if (has_framework_id()) {
      if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    state_ = 6;
  }
  if (_has_bits_[8 / 32] & 16128u) {
    status_update_state_ = 6;
    if (has_status_update_uuid()) {
      status_update_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_discovery()) {
      if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
    }
    if (has_container()) {
      if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
    }
    if (has_user()) {
      user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  resources_.Clear();
  statuses_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Task::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Task)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Task.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_task_id;
        break;
      }

      // required .mesos.TaskID task_id = 2;
      case 2: {
        if (tag == 18) {
         parse_task_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_framework_id;
        break;
      }

      // required .mesos.FrameworkID framework_id = 3;
      case 3: {
        if (tag == 26) {
         parse_framework_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_framework_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 4;
      case 4: {
        if (tag == 34) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // required .mesos.SlaveID slave_id = 5;
      case 5: {
        if (tag == 42) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_state;
        break;
      }

      // required .mesos.TaskState state = 6;
      case 6: {
        if (tag == 48) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(6, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_resources;
        break;
      }

      // repeated .mesos.Resource resources = 7;
      case 7: {
        if (tag == 58) {
         parse_resources:
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_resources;
        if (input->ExpectTag(66)) goto parse_loop_statuses;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mesos.TaskStatus statuses = 8;
      case 8: {
        if (tag == 66) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_statuses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_statuses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_loop_statuses;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(72)) goto parse_status_update_state;
        break;
      }

      // optional .mesos.TaskState status_update_state = 9;
      case 9: {
        if (tag == 72) {
         parse_status_update_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_status_update_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_status_update_uuid;
        break;
      }

      // optional bytes status_update_uuid = 10;
      case 10: {
        if (tag == 82) {
         parse_status_update_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_status_update_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 11;
      case 11: {
        if (tag == 90) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_discovery;
        break;
      }

      // optional .mesos.DiscoveryInfo discovery = 12;
      case 12: {
        if (tag == 98) {
         parse_discovery:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_discovery()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_container;
        break;
      }

      // optional .mesos.ContainerInfo container = 13;
      case 13: {
        if (tag == 106) {
         parse_container:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_user;
        break;
      }

      // optional string user = 14;
      case 14: {
        if (tag == 114) {
         parse_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->user().data(), this->user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Task.user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Task)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Task)
  return false;
#undef DO_
}

void Task::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Task.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->task_id_, output);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->framework_id_, output);
  }

  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->executor_id_, output);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->slave_id_, output);
  }

  // required .mesos.TaskState state = 6;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      6, this->state(), output);
  }

  // repeated .mesos.Resource resources = 7;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->resources(i), output);
  }

  // repeated .mesos.TaskStatus statuses = 8;
  for (unsigned int i = 0, n = this->statuses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->statuses(i), output);
  }

  // optional .mesos.TaskState status_update_state = 9;
  if (has_status_update_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->status_update_state(), output);
  }

  // optional bytes status_update_uuid = 10;
  if (has_status_update_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      10, this->status_update_uuid(), output);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      11, *this->labels_, output);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->discovery_, output);
  }

  // optional .mesos.ContainerInfo container = 13;
  if (has_container()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->container_, output);
  }

  // optional string user = 14;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Task.user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      14, this->user(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Task)
}

::google::protobuf::uint8* Task::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Task)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Task.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required .mesos.TaskID task_id = 2;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->task_id_, false, target);
  }

  // required .mesos.FrameworkID framework_id = 3;
  if (has_framework_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->framework_id_, false, target);
  }

  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->executor_id_, false, target);
  }

  // required .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->slave_id_, false, target);
  }

  // required .mesos.TaskState state = 6;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      6, this->state(), target);
  }

  // repeated .mesos.Resource resources = 7;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->resources(i), false, target);
  }

  // repeated .mesos.TaskStatus statuses = 8;
  for (unsigned int i = 0, n = this->statuses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, this->statuses(i), false, target);
  }

  // optional .mesos.TaskState status_update_state = 9;
  if (has_status_update_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->status_update_state(), target);
  }

  // optional bytes status_update_uuid = 10;
  if (has_status_update_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        10, this->status_update_uuid(), target);
  }

  // optional .mesos.Labels labels = 11;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        11, *this->labels_, false, target);
  }

  // optional .mesos.DiscoveryInfo discovery = 12;
  if (has_discovery()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *this->discovery_, false, target);
  }

  // optional .mesos.ContainerInfo container = 13;
  if (has_container()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->container_, false, target);
  }

  // optional string user = 14;
  if (has_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->user().data(), this->user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Task.user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        14, this->user(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Task)
  return target;
}

int Task::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Task)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_task_id()) {
    // required .mesos.TaskID task_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_id_);
  }

  if (has_framework_id()) {
    // required .mesos.FrameworkID framework_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->framework_id_);
  }

  if (has_slave_id()) {
    // required .mesos.SlaveID slave_id = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);
  }

  if (has_state()) {
    // required .mesos.TaskState state = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }

  return total_size;
}
int Task::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Task)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000037) ^ 0x00000037) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required .mesos.TaskID task_id = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_id_);

    // required .mesos.FrameworkID framework_id = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->framework_id_);

    // required .mesos.SlaveID slave_id = 5;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->slave_id_);

    // required .mesos.TaskState state = 6;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional .mesos.ExecutorID executor_id = 4;
  if (has_executor_id()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->executor_id_);
  }

  if (_has_bits_[8 / 32] & 16128u) {
    // optional .mesos.TaskState status_update_state = 9;
    if (has_status_update_state()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->status_update_state());
    }

    // optional bytes status_update_uuid = 10;
    if (has_status_update_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->status_update_uuid());
    }

    // optional .mesos.Labels labels = 11;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

    // optional .mesos.DiscoveryInfo discovery = 12;
    if (has_discovery()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->discovery_);
    }

    // optional .mesos.ContainerInfo container = 13;
    if (has_container()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->container_);
    }

    // optional string user = 14;
    if (has_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->user());
    }

  }
  // repeated .mesos.Resource resources = 7;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  // repeated .mesos.TaskStatus statuses = 8;
  total_size += 1 * this->statuses_size();
  for (int i = 0; i < this->statuses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->statuses(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Task::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Task)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Task* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Task>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Task)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Task)
    MergeFrom(*source);
  }
}

void Task::MergeFrom(const Task& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Task)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  resources_.MergeFrom(from.resources_);
  statuses_.MergeFrom(from.statuses_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_framework_id()) {
      mutable_framework_id()->::mesos::FrameworkID::MergeFrom(from.framework_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_status_update_state()) {
      set_status_update_state(from.status_update_state());
    }
    if (from.has_status_update_uuid()) {
      set_has_status_update_uuid();
      status_update_uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.status_update_uuid_);
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_discovery()) {
      mutable_discovery()->::mesos::DiscoveryInfo::MergeFrom(from.discovery());
    }
    if (from.has_container()) {
      mutable_container()->::mesos::ContainerInfo::MergeFrom(from.container());
    }
    if (from.has_user()) {
      set_has_user();
      user_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.user_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Task::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Task::CopyFrom(const Task& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Task)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Task::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000037) != 0x00000037) return false;

  if (has_task_id()) {
    if (!this->task_id_->IsInitialized()) return false;
  }
  if (has_framework_id()) {
    if (!this->framework_id_->IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id_->IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->statuses())) return false;
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  if (has_discovery()) {
    if (!this->discovery_->IsInitialized()) return false;
  }
  if (has_container()) {
    if (!this->container_->IsInitialized()) return false;
  }
  return true;
}

void Task::Swap(Task* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Task::InternalSwap(Task* other) {
  name_.Swap(&other->name_);
  std::swap(task_id_, other->task_id_);
  std::swap(framework_id_, other->framework_id_);
  std::swap(executor_id_, other->executor_id_);
  std::swap(slave_id_, other->slave_id_);
  std::swap(state_, other->state_);
  resources_.UnsafeArenaSwap(&other->resources_);
  statuses_.UnsafeArenaSwap(&other->statuses_);
  std::swap(status_update_state_, other->status_update_state_);
  status_update_uuid_.Swap(&other->status_update_uuid_);
  std::swap(labels_, other->labels_);
  std::swap(discovery_, other->discovery_);
  std::swap(container_, other->container_);
  user_.Swap(&other->user_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Task::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Task_descriptor_;
  metadata.reflection = Task_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Task

// required string name = 1;
bool Task::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Task::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Task::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Task::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Task::name() const {
  // @@protoc_insertion_point(field_get:mesos.Task.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Task::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Task.name)
}
 void Task::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Task.name)
}
 void Task::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.name)
}
 ::std::string* Task::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Task.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Task::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Task.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Task::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.name)
}

// required .mesos.TaskID task_id = 2;
bool Task::has_task_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Task::set_has_task_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Task::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Task::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
const ::mesos::TaskID& Task::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
::mesos::TaskID* Task::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    task_id_ = new ::mesos::TaskID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.task_id)
  return task_id_;
}
::mesos::TaskID* Task::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
void Task::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.task_id)
}

// required .mesos.FrameworkID framework_id = 3;
bool Task::has_framework_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Task::set_has_framework_id() {
  _has_bits_[0] |= 0x00000004u;
}
void Task::clear_has_framework_id() {
  _has_bits_[0] &= ~0x00000004u;
}
void Task::clear_framework_id() {
  if (framework_id_ != NULL) framework_id_->::mesos::FrameworkID::Clear();
  clear_has_framework_id();
}
const ::mesos::FrameworkID& Task::framework_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.framework_id)
  return framework_id_ != NULL ? *framework_id_ : *default_instance_->framework_id_;
}
::mesos::FrameworkID* Task::mutable_framework_id() {
  set_has_framework_id();
  if (framework_id_ == NULL) {
    framework_id_ = new ::mesos::FrameworkID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.framework_id)
  return framework_id_;
}
::mesos::FrameworkID* Task::release_framework_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.framework_id)
  clear_has_framework_id();
  ::mesos::FrameworkID* temp = framework_id_;
  framework_id_ = NULL;
  return temp;
}
void Task::set_allocated_framework_id(::mesos::FrameworkID* framework_id) {
  delete framework_id_;
  framework_id_ = framework_id;
  if (framework_id) {
    set_has_framework_id();
  } else {
    clear_has_framework_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.framework_id)
}

// optional .mesos.ExecutorID executor_id = 4;
bool Task::has_executor_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Task::set_has_executor_id() {
  _has_bits_[0] |= 0x00000008u;
}
void Task::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000008u;
}
void Task::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
const ::mesos::ExecutorID& Task::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
::mesos::ExecutorID* Task::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    executor_id_ = new ::mesos::ExecutorID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.executor_id)
  return executor_id_;
}
::mesos::ExecutorID* Task::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
void Task::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.executor_id)
}

// required .mesos.SlaveID slave_id = 5;
bool Task::has_slave_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Task::set_has_slave_id() {
  _has_bits_[0] |= 0x00000010u;
}
void Task::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000010u;
}
void Task::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
const ::mesos::SlaveID& Task::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.Task.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
::mesos::SlaveID* Task::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.slave_id)
  return slave_id_;
}
::mesos::SlaveID* Task::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.Task.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
void Task::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.slave_id)
}

// required .mesos.TaskState state = 6;
bool Task::has_state() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void Task::set_has_state() {
  _has_bits_[0] |= 0x00000020u;
}
void Task::clear_has_state() {
  _has_bits_[0] &= ~0x00000020u;
}
void Task::clear_state() {
  state_ = 6;
  clear_has_state();
}
 ::mesos::TaskState Task::state() const {
  // @@protoc_insertion_point(field_get:mesos.Task.state)
  return static_cast< ::mesos::TaskState >(state_);
}
 void Task::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.Task.state)
}

// repeated .mesos.Resource resources = 7;
int Task::resources_size() const {
  return resources_.size();
}
void Task::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& Task::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Task.resources)
  return resources_.Get(index);
}
::mesos::Resource* Task::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Task.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* Task::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Task.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Task::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Task.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Task::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Task.resources)
  return resources_;
}

// repeated .mesos.TaskStatus statuses = 8;
int Task::statuses_size() const {
  return statuses_.size();
}
void Task::clear_statuses() {
  statuses_.Clear();
}
const ::mesos::TaskStatus& Task::statuses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Task.statuses)
  return statuses_.Get(index);
}
::mesos::TaskStatus* Task::mutable_statuses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Task.statuses)
  return statuses_.Mutable(index);
}
::mesos::TaskStatus* Task::add_statuses() {
  // @@protoc_insertion_point(field_add:mesos.Task.statuses)
  return statuses_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >*
Task::mutable_statuses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Task.statuses)
  return &statuses_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::TaskStatus >&
Task::statuses() const {
  // @@protoc_insertion_point(field_list:mesos.Task.statuses)
  return statuses_;
}

// optional .mesos.TaskState status_update_state = 9;
bool Task::has_status_update_state() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void Task::set_has_status_update_state() {
  _has_bits_[0] |= 0x00000100u;
}
void Task::clear_has_status_update_state() {
  _has_bits_[0] &= ~0x00000100u;
}
void Task::clear_status_update_state() {
  status_update_state_ = 6;
  clear_has_status_update_state();
}
 ::mesos::TaskState Task::status_update_state() const {
  // @@protoc_insertion_point(field_get:mesos.Task.status_update_state)
  return static_cast< ::mesos::TaskState >(status_update_state_);
}
 void Task::set_status_update_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_status_update_state();
  status_update_state_ = value;
  // @@protoc_insertion_point(field_set:mesos.Task.status_update_state)
}

// optional bytes status_update_uuid = 10;
bool Task::has_status_update_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void Task::set_has_status_update_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
void Task::clear_has_status_update_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
void Task::clear_status_update_uuid() {
  status_update_uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status_update_uuid();
}
 const ::std::string& Task::status_update_uuid() const {
  // @@protoc_insertion_point(field_get:mesos.Task.status_update_uuid)
  return status_update_uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Task::set_status_update_uuid(const ::std::string& value) {
  set_has_status_update_uuid();
  status_update_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Task.status_update_uuid)
}
 void Task::set_status_update_uuid(const char* value) {
  set_has_status_update_uuid();
  status_update_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Task.status_update_uuid)
}
 void Task::set_status_update_uuid(const void* value, size_t size) {
  set_has_status_update_uuid();
  status_update_uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.status_update_uuid)
}
 ::std::string* Task::mutable_status_update_uuid() {
  set_has_status_update_uuid();
  // @@protoc_insertion_point(field_mutable:mesos.Task.status_update_uuid)
  return status_update_uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Task::release_status_update_uuid() {
  // @@protoc_insertion_point(field_release:mesos.Task.status_update_uuid)
  clear_has_status_update_uuid();
  return status_update_uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Task::set_allocated_status_update_uuid(::std::string* status_update_uuid) {
  if (status_update_uuid != NULL) {
    set_has_status_update_uuid();
  } else {
    clear_has_status_update_uuid();
  }
  status_update_uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status_update_uuid);
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.status_update_uuid)
}

// optional .mesos.Labels labels = 11;
bool Task::has_labels() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void Task::set_has_labels() {
  _has_bits_[0] |= 0x00000400u;
}
void Task::clear_has_labels() {
  _has_bits_[0] &= ~0x00000400u;
}
void Task::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& Task::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Task.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* Task::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.labels)
  return labels_;
}
::mesos::Labels* Task::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Task.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void Task::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.labels)
}

// optional .mesos.DiscoveryInfo discovery = 12;
bool Task::has_discovery() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void Task::set_has_discovery() {
  _has_bits_[0] |= 0x00000800u;
}
void Task::clear_has_discovery() {
  _has_bits_[0] &= ~0x00000800u;
}
void Task::clear_discovery() {
  if (discovery_ != NULL) discovery_->::mesos::DiscoveryInfo::Clear();
  clear_has_discovery();
}
const ::mesos::DiscoveryInfo& Task::discovery() const {
  // @@protoc_insertion_point(field_get:mesos.Task.discovery)
  return discovery_ != NULL ? *discovery_ : *default_instance_->discovery_;
}
::mesos::DiscoveryInfo* Task::mutable_discovery() {
  set_has_discovery();
  if (discovery_ == NULL) {
    discovery_ = new ::mesos::DiscoveryInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.discovery)
  return discovery_;
}
::mesos::DiscoveryInfo* Task::release_discovery() {
  // @@protoc_insertion_point(field_release:mesos.Task.discovery)
  clear_has_discovery();
  ::mesos::DiscoveryInfo* temp = discovery_;
  discovery_ = NULL;
  return temp;
}
void Task::set_allocated_discovery(::mesos::DiscoveryInfo* discovery) {
  delete discovery_;
  discovery_ = discovery;
  if (discovery) {
    set_has_discovery();
  } else {
    clear_has_discovery();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.discovery)
}

// optional .mesos.ContainerInfo container = 13;
bool Task::has_container() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void Task::set_has_container() {
  _has_bits_[0] |= 0x00001000u;
}
void Task::clear_has_container() {
  _has_bits_[0] &= ~0x00001000u;
}
void Task::clear_container() {
  if (container_ != NULL) container_->::mesos::ContainerInfo::Clear();
  clear_has_container();
}
const ::mesos::ContainerInfo& Task::container() const {
  // @@protoc_insertion_point(field_get:mesos.Task.container)
  return container_ != NULL ? *container_ : *default_instance_->container_;
}
::mesos::ContainerInfo* Task::mutable_container() {
  set_has_container();
  if (container_ == NULL) {
    container_ = new ::mesos::ContainerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Task.container)
  return container_;
}
::mesos::ContainerInfo* Task::release_container() {
  // @@protoc_insertion_point(field_release:mesos.Task.container)
  clear_has_container();
  ::mesos::ContainerInfo* temp = container_;
  container_ = NULL;
  return temp;
}
void Task::set_allocated_container(::mesos::ContainerInfo* container) {
  delete container_;
  container_ = container;
  if (container) {
    set_has_container();
  } else {
    clear_has_container();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.container)
}

// optional string user = 14;
bool Task::has_user() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void Task::set_has_user() {
  _has_bits_[0] |= 0x00002000u;
}
void Task::clear_has_user() {
  _has_bits_[0] &= ~0x00002000u;
}
void Task::clear_user() {
  user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_user();
}
 const ::std::string& Task::user() const {
  // @@protoc_insertion_point(field_get:mesos.Task.user)
  return user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Task::set_user(const ::std::string& value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Task.user)
}
 void Task::set_user(const char* value) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Task.user)
}
 void Task::set_user(const char* value, size_t size) {
  set_has_user();
  user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Task.user)
}
 ::std::string* Task::mutable_user() {
  set_has_user();
  // @@protoc_insertion_point(field_mutable:mesos.Task.user)
  return user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Task::release_user() {
  // @@protoc_insertion_point(field_release:mesos.Task.user)
  clear_has_user();
  return user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Task::set_allocated_user(::std::string* user) {
  if (user != NULL) {
    set_has_user();
  } else {
    clear_has_user();
  }
  user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), user);
  // @@protoc_insertion_point(field_set_allocated:mesos.Task.user)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckStatusInfo_Command::kExitCodeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckStatusInfo_Command::CheckStatusInfo_Command()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo.Command)
}

void CheckStatusInfo_Command::InitAsDefaultInstance() {
}

CheckStatusInfo_Command::CheckStatusInfo_Command(const CheckStatusInfo_Command& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo.Command)
}

void CheckStatusInfo_Command::SharedCtor() {
  _cached_size_ = 0;
  exit_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo_Command::~CheckStatusInfo_Command() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo.Command)
  SharedDtor();
}

void CheckStatusInfo_Command::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckStatusInfo_Command::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo_Command::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_Command_descriptor_;
}

const CheckStatusInfo_Command& CheckStatusInfo_Command::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo_Command* CheckStatusInfo_Command::default_instance_ = NULL;

CheckStatusInfo_Command* CheckStatusInfo_Command::New(::google::protobuf::Arena* arena) const {
  CheckStatusInfo_Command* n = new CheckStatusInfo_Command;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckStatusInfo_Command::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CheckStatusInfo.Command)
  exit_code_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckStatusInfo_Command::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo.Command)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 exit_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &exit_code_)));
          set_has_exit_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo.Command)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo.Command)
  return false;
#undef DO_
}

void CheckStatusInfo_Command::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo.Command)
  // optional int32 exit_code = 1;
  if (has_exit_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->exit_code(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo.Command)
}

::google::protobuf::uint8* CheckStatusInfo_Command::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo.Command)
  // optional int32 exit_code = 1;
  if (has_exit_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->exit_code(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo.Command)
  return target;
}

int CheckStatusInfo_Command::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CheckStatusInfo.Command)
  int total_size = 0;

  // optional int32 exit_code = 1;
  if (has_exit_code()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->exit_code());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo_Command::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CheckStatusInfo.Command)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CheckStatusInfo_Command* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckStatusInfo_Command>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CheckStatusInfo.Command)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CheckStatusInfo.Command)
    MergeFrom(*source);
  }
}

void CheckStatusInfo_Command::MergeFrom(const CheckStatusInfo_Command& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CheckStatusInfo.Command)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_exit_code()) {
      set_exit_code(from.exit_code());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckStatusInfo_Command::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CheckStatusInfo.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo_Command::CopyFrom(const CheckStatusInfo_Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CheckStatusInfo.Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo_Command::IsInitialized() const {

  return true;
}

void CheckStatusInfo_Command::Swap(CheckStatusInfo_Command* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckStatusInfo_Command::InternalSwap(CheckStatusInfo_Command* other) {
  std::swap(exit_code_, other->exit_code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckStatusInfo_Command::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_Command_descriptor_;
  metadata.reflection = CheckStatusInfo_Command_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckStatusInfo_Http::kStatusCodeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckStatusInfo_Http::CheckStatusInfo_Http()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo.Http)
}

void CheckStatusInfo_Http::InitAsDefaultInstance() {
}

CheckStatusInfo_Http::CheckStatusInfo_Http(const CheckStatusInfo_Http& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo.Http)
}

void CheckStatusInfo_Http::SharedCtor() {
  _cached_size_ = 0;
  status_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo_Http::~CheckStatusInfo_Http() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo.Http)
  SharedDtor();
}

void CheckStatusInfo_Http::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CheckStatusInfo_Http::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo_Http::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_Http_descriptor_;
}

const CheckStatusInfo_Http& CheckStatusInfo_Http::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo_Http* CheckStatusInfo_Http::default_instance_ = NULL;

CheckStatusInfo_Http* CheckStatusInfo_Http::New(::google::protobuf::Arena* arena) const {
  CheckStatusInfo_Http* n = new CheckStatusInfo_Http;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckStatusInfo_Http::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CheckStatusInfo.Http)
  status_code_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckStatusInfo_Http::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo.Http)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 status_code = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &status_code_)));
          set_has_status_code();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo.Http)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo.Http)
  return false;
#undef DO_
}

void CheckStatusInfo_Http::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo.Http)
  // optional uint32 status_code = 1;
  if (has_status_code()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->status_code(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo.Http)
}

::google::protobuf::uint8* CheckStatusInfo_Http::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo.Http)
  // optional uint32 status_code = 1;
  if (has_status_code()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->status_code(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo.Http)
  return target;
}

int CheckStatusInfo_Http::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CheckStatusInfo.Http)
  int total_size = 0;

  // optional uint32 status_code = 1;
  if (has_status_code()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->status_code());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo_Http::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CheckStatusInfo.Http)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CheckStatusInfo_Http* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckStatusInfo_Http>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CheckStatusInfo.Http)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CheckStatusInfo.Http)
    MergeFrom(*source);
  }
}

void CheckStatusInfo_Http::MergeFrom(const CheckStatusInfo_Http& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CheckStatusInfo.Http)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_status_code()) {
      set_status_code(from.status_code());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckStatusInfo_Http::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CheckStatusInfo.Http)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo_Http::CopyFrom(const CheckStatusInfo_Http& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CheckStatusInfo.Http)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo_Http::IsInitialized() const {

  return true;
}

void CheckStatusInfo_Http::Swap(CheckStatusInfo_Http* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckStatusInfo_Http::InternalSwap(CheckStatusInfo_Http* other) {
  std::swap(status_code_, other->status_code_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckStatusInfo_Http::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_Http_descriptor_;
  metadata.reflection = CheckStatusInfo_Http_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CheckStatusInfo::kTypeFieldNumber;
const int CheckStatusInfo::kCommandFieldNumber;
const int CheckStatusInfo::kHttpFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CheckStatusInfo::CheckStatusInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CheckStatusInfo)
}

void CheckStatusInfo::InitAsDefaultInstance() {
  command_ = const_cast< ::mesos::CheckStatusInfo_Command*>(&::mesos::CheckStatusInfo_Command::default_instance());
  http_ = const_cast< ::mesos::CheckStatusInfo_Http*>(&::mesos::CheckStatusInfo_Http::default_instance());
}

CheckStatusInfo::CheckStatusInfo(const CheckStatusInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CheckStatusInfo)
}

void CheckStatusInfo::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  command_ = NULL;
  http_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CheckStatusInfo::~CheckStatusInfo() {
  // @@protoc_insertion_point(destructor:mesos.CheckStatusInfo)
  SharedDtor();
}

void CheckStatusInfo::SharedDtor() {
  if (this != default_instance_) {
    delete command_;
    delete http_;
  }
}

void CheckStatusInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CheckStatusInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CheckStatusInfo_descriptor_;
}

const CheckStatusInfo& CheckStatusInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CheckStatusInfo* CheckStatusInfo::default_instance_ = NULL;

CheckStatusInfo* CheckStatusInfo::New(::google::protobuf::Arena* arena) const {
  CheckStatusInfo* n = new CheckStatusInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CheckStatusInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CheckStatusInfo)
  if (_has_bits_[0 / 32] & 7u) {
    type_ = 0;
    if (has_command()) {
      if (command_ != NULL) command_->::mesos::CheckStatusInfo_Command::Clear();
    }
    if (has_http()) {
      if (http_ != NULL) http_->::mesos::CheckStatusInfo_Http::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CheckStatusInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CheckStatusInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CheckInfo.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::CheckInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::CheckInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_command;
        break;
      }

      // optional .mesos.CheckStatusInfo.Command command = 2;
      case 2: {
        if (tag == 18) {
         parse_command:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_command()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_http;
        break;
      }

      // optional .mesos.CheckStatusInfo.Http http = 3;
      case 3: {
        if (tag == 26) {
         parse_http:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_http()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CheckStatusInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CheckStatusInfo)
  return false;
#undef DO_
}

void CheckStatusInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CheckStatusInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.CheckStatusInfo.Command command = 2;
  if (has_command()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->command_, output);
  }

  // optional .mesos.CheckStatusInfo.Http http = 3;
  if (has_http()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->http_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CheckStatusInfo)
}

::google::protobuf::uint8* CheckStatusInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CheckStatusInfo)
  // optional .mesos.CheckInfo.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.CheckStatusInfo.Command command = 2;
  if (has_command()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->command_, false, target);
  }

  // optional .mesos.CheckStatusInfo.Http http = 3;
  if (has_http()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->http_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CheckStatusInfo)
  return target;
}

int CheckStatusInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CheckStatusInfo)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .mesos.CheckInfo.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.CheckStatusInfo.Command command = 2;
    if (has_command()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->command_);
    }

    // optional .mesos.CheckStatusInfo.Http http = 3;
    if (has_http()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->http_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CheckStatusInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CheckStatusInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CheckStatusInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CheckStatusInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CheckStatusInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CheckStatusInfo)
    MergeFrom(*source);
  }
}

void CheckStatusInfo::MergeFrom(const CheckStatusInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CheckStatusInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_command()) {
      mutable_command()->::mesos::CheckStatusInfo_Command::MergeFrom(from.command());
    }
    if (from.has_http()) {
      mutable_http()->::mesos::CheckStatusInfo_Http::MergeFrom(from.http());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CheckStatusInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CheckStatusInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CheckStatusInfo::CopyFrom(const CheckStatusInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CheckStatusInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CheckStatusInfo::IsInitialized() const {

  return true;
}

void CheckStatusInfo::Swap(CheckStatusInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CheckStatusInfo::InternalSwap(CheckStatusInfo* other) {
  std::swap(type_, other->type_);
  std::swap(command_, other->command_);
  std::swap(http_, other->http_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CheckStatusInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CheckStatusInfo_descriptor_;
  metadata.reflection = CheckStatusInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CheckStatusInfo_Command

// optional int32 exit_code = 1;
bool CheckStatusInfo_Command::has_exit_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckStatusInfo_Command::set_has_exit_code() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckStatusInfo_Command::clear_has_exit_code() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckStatusInfo_Command::clear_exit_code() {
  exit_code_ = 0;
  clear_has_exit_code();
}
 ::google::protobuf::int32 CheckStatusInfo_Command::exit_code() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Command.exit_code)
  return exit_code_;
}
 void CheckStatusInfo_Command::set_exit_code(::google::protobuf::int32 value) {
  set_has_exit_code();
  exit_code_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Command.exit_code)
}

// -------------------------------------------------------------------

// CheckStatusInfo_Http

// optional uint32 status_code = 1;
bool CheckStatusInfo_Http::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckStatusInfo_Http::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckStatusInfo_Http::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckStatusInfo_Http::clear_status_code() {
  status_code_ = 0u;
  clear_has_status_code();
}
 ::google::protobuf::uint32 CheckStatusInfo_Http::status_code() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.Http.status_code)
  return status_code_;
}
 void CheckStatusInfo_Http::set_status_code(::google::protobuf::uint32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.Http.status_code)
}

// -------------------------------------------------------------------

// CheckStatusInfo

// optional .mesos.CheckInfo.Type type = 1;
bool CheckStatusInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CheckStatusInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void CheckStatusInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void CheckStatusInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::CheckInfo_Type CheckStatusInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.type)
  return static_cast< ::mesos::CheckInfo_Type >(type_);
}
 void CheckStatusInfo::set_type(::mesos::CheckInfo_Type value) {
  assert(::mesos::CheckInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.CheckStatusInfo.type)
}

// optional .mesos.CheckStatusInfo.Command command = 2;
bool CheckStatusInfo::has_command() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void CheckStatusInfo::set_has_command() {
  _has_bits_[0] |= 0x00000002u;
}
void CheckStatusInfo::clear_has_command() {
  _has_bits_[0] &= ~0x00000002u;
}
void CheckStatusInfo::clear_command() {
  if (command_ != NULL) command_->::mesos::CheckStatusInfo_Command::Clear();
  clear_has_command();
}
const ::mesos::CheckStatusInfo_Command& CheckStatusInfo::command() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.command)
  return command_ != NULL ? *command_ : *default_instance_->command_;
}
::mesos::CheckStatusInfo_Command* CheckStatusInfo::mutable_command() {
  set_has_command();
  if (command_ == NULL) {
    command_ = new ::mesos::CheckStatusInfo_Command;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.command)
  return command_;
}
::mesos::CheckStatusInfo_Command* CheckStatusInfo::release_command() {
  // @@protoc_insertion_point(field_release:mesos.CheckStatusInfo.command)
  clear_has_command();
  ::mesos::CheckStatusInfo_Command* temp = command_;
  command_ = NULL;
  return temp;
}
void CheckStatusInfo::set_allocated_command(::mesos::CheckStatusInfo_Command* command) {
  delete command_;
  command_ = command;
  if (command) {
    set_has_command();
  } else {
    clear_has_command();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.command)
}

// optional .mesos.CheckStatusInfo.Http http = 3;
bool CheckStatusInfo::has_http() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void CheckStatusInfo::set_has_http() {
  _has_bits_[0] |= 0x00000004u;
}
void CheckStatusInfo::clear_has_http() {
  _has_bits_[0] &= ~0x00000004u;
}
void CheckStatusInfo::clear_http() {
  if (http_ != NULL) http_->::mesos::CheckStatusInfo_Http::Clear();
  clear_has_http();
}
const ::mesos::CheckStatusInfo_Http& CheckStatusInfo::http() const {
  // @@protoc_insertion_point(field_get:mesos.CheckStatusInfo.http)
  return http_ != NULL ? *http_ : *default_instance_->http_;
}
::mesos::CheckStatusInfo_Http* CheckStatusInfo::mutable_http() {
  set_has_http();
  if (http_ == NULL) {
    http_ = new ::mesos::CheckStatusInfo_Http;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CheckStatusInfo.http)
  return http_;
}
::mesos::CheckStatusInfo_Http* CheckStatusInfo::release_http() {
  // @@protoc_insertion_point(field_release:mesos.CheckStatusInfo.http)
  clear_has_http();
  ::mesos::CheckStatusInfo_Http* temp = http_;
  http_ = NULL;
  return temp;
}
void CheckStatusInfo::set_allocated_http(::mesos::CheckStatusInfo_Http* http) {
  delete http_;
  http_ = http;
  if (http) {
    set_has_http();
  } else {
    clear_has_http();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CheckStatusInfo.http)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* TaskStatus_Source_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskStatus_Source_descriptor_;
}
bool TaskStatus_Source_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TaskStatus_Source TaskStatus::SOURCE_MASTER;
const TaskStatus_Source TaskStatus::SOURCE_SLAVE;
const TaskStatus_Source TaskStatus::SOURCE_EXECUTOR;
const TaskStatus_Source TaskStatus::Source_MIN;
const TaskStatus_Source TaskStatus::Source_MAX;
const int TaskStatus::Source_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* TaskStatus_Reason_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskStatus_Reason_descriptor_;
}
bool TaskStatus_Reason_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const TaskStatus_Reason TaskStatus::REASON_COMMAND_EXECUTOR_FAILED;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LAUNCH_FAILED;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LIMITATION;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LIMITATION_DISK;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_LIMITATION_MEMORY;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_PREEMPTED;
const TaskStatus_Reason TaskStatus::REASON_CONTAINER_UPDATE_FAILED;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_REGISTRATION_TIMEOUT;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_REREGISTRATION_TIMEOUT;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_TERMINATED;
const TaskStatus_Reason TaskStatus::REASON_EXECUTOR_UNREGISTERED;
const TaskStatus_Reason TaskStatus::REASON_FRAMEWORK_REMOVED;
const TaskStatus_Reason TaskStatus::REASON_GC_ERROR;
const TaskStatus_Reason TaskStatus::REASON_INVALID_FRAMEWORKID;
const TaskStatus_Reason TaskStatus::REASON_INVALID_OFFERS;
const TaskStatus_Reason TaskStatus::REASON_IO_SWITCHBOARD_EXITED;
const TaskStatus_Reason TaskStatus::REASON_MASTER_DISCONNECTED;
const TaskStatus_Reason TaskStatus::REASON_RECONCILIATION;
const TaskStatus_Reason TaskStatus::REASON_RESOURCES_UNKNOWN;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_DISCONNECTED;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_REMOVED;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_RESTARTED;
const TaskStatus_Reason TaskStatus::REASON_SLAVE_UNKNOWN;
const TaskStatus_Reason TaskStatus::REASON_TASK_CHECK_STATUS_UPDATED;
const TaskStatus_Reason TaskStatus::REASON_TASK_GROUP_INVALID;
const TaskStatus_Reason TaskStatus::REASON_TASK_GROUP_UNAUTHORIZED;
const TaskStatus_Reason TaskStatus::REASON_TASK_INVALID;
const TaskStatus_Reason TaskStatus::REASON_TASK_UNAUTHORIZED;
const TaskStatus_Reason TaskStatus::REASON_TASK_UNKNOWN;
const TaskStatus_Reason TaskStatus::Reason_MIN;
const TaskStatus_Reason TaskStatus::Reason_MAX;
const int TaskStatus::Reason_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TaskStatus::kTaskIdFieldNumber;
const int TaskStatus::kStateFieldNumber;
const int TaskStatus::kMessageFieldNumber;
const int TaskStatus::kSourceFieldNumber;
const int TaskStatus::kReasonFieldNumber;
const int TaskStatus::kDataFieldNumber;
const int TaskStatus::kSlaveIdFieldNumber;
const int TaskStatus::kExecutorIdFieldNumber;
const int TaskStatus::kTimestampFieldNumber;
const int TaskStatus::kUuidFieldNumber;
const int TaskStatus::kHealthyFieldNumber;
const int TaskStatus::kCheckStatusFieldNumber;
const int TaskStatus::kLabelsFieldNumber;
const int TaskStatus::kContainerStatusFieldNumber;
const int TaskStatus::kUnreachableTimeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TaskStatus::TaskStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TaskStatus)
}

void TaskStatus::InitAsDefaultInstance() {
  task_id_ = const_cast< ::mesos::TaskID*>(&::mesos::TaskID::default_instance());
  slave_id_ = const_cast< ::mesos::SlaveID*>(&::mesos::SlaveID::default_instance());
  executor_id_ = const_cast< ::mesos::ExecutorID*>(&::mesos::ExecutorID::default_instance());
  check_status_ = const_cast< ::mesos::CheckStatusInfo*>(&::mesos::CheckStatusInfo::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
  container_status_ = const_cast< ::mesos::ContainerStatus*>(&::mesos::ContainerStatus::default_instance());
  unreachable_time_ = const_cast< ::mesos::TimeInfo*>(&::mesos::TimeInfo::default_instance());
}

TaskStatus::TaskStatus(const TaskStatus& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TaskStatus)
}

void TaskStatus::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  task_id_ = NULL;
  state_ = 6;
  message_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  source_ = 0;
  reason_ = 0;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  slave_id_ = NULL;
  executor_id_ = NULL;
  timestamp_ = 0;
  uuid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  healthy_ = false;
  check_status_ = NULL;
  labels_ = NULL;
  container_status_ = NULL;
  unreachable_time_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TaskStatus::~TaskStatus() {
  // @@protoc_insertion_point(destructor:mesos.TaskStatus)
  SharedDtor();
}

void TaskStatus::SharedDtor() {
  message_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uuid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete task_id_;
    delete slave_id_;
    delete executor_id_;
    delete check_status_;
    delete labels_;
    delete container_status_;
    delete unreachable_time_;
  }
}

void TaskStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TaskStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TaskStatus_descriptor_;
}

const TaskStatus& TaskStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TaskStatus* TaskStatus::default_instance_ = NULL;

TaskStatus* TaskStatus::New(::google::protobuf::Arena* arena) const {
  TaskStatus* n = new TaskStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TaskStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TaskStatus)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TaskStatus, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TaskStatus*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 255u) {
    if (has_task_id()) {
      if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
    }
    state_ = 6;
    if (has_message()) {
      message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    source_ = 0;
    reason_ = 0;
    if (has_data()) {
      data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_slave_id()) {
      if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
    }
    if (has_executor_id()) {
      if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
    }
  }
  if (_has_bits_[8 / 32] & 32512u) {
    ZR_(healthy_, timestamp_);
    if (has_uuid()) {
      uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_check_status()) {
      if (check_status_ != NULL) check_status_->::mesos::CheckStatusInfo::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
    if (has_container_status()) {
      if (container_status_ != NULL) container_status_->::mesos::ContainerStatus::Clear();
    }
    if (has_unreachable_time()) {
      if (unreachable_time_ != NULL) unreachable_time_->::mesos::TimeInfo::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TaskStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TaskStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.TaskID task_id = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_task_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_state;
        break;
      }

      // required .mesos.TaskState state = 2;
      case 2: {
        if (tag == 16) {
         parse_state:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskState_IsValid(value)) {
            set_state(static_cast< ::mesos::TaskState >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_data;
        break;
      }

      // optional bytes data = 3;
      case 3: {
        if (tag == 26) {
         parse_data:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_message;
        break;
      }

      // optional string message = 4;
      case 4: {
        if (tag == 34) {
         parse_message:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_message()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->message().data(), this->message().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.TaskStatus.message");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_slave_id;
        break;
      }

      // optional .mesos.SlaveID slave_id = 5;
      case 5: {
        if (tag == 42) {
         parse_slave_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_slave_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(49)) goto parse_timestamp;
        break;
      }

      // optional double timestamp = 6;
      case 6: {
        if (tag == 49) {
         parse_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &timestamp_)));
          set_has_timestamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_executor_id;
        break;
      }

      // optional .mesos.ExecutorID executor_id = 7;
      case 7: {
        if (tag == 58) {
         parse_executor_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_executor_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_healthy;
        break;
      }

      // optional bool healthy = 8;
      case 8: {
        if (tag == 64) {
         parse_healthy:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &healthy_)));
          set_has_healthy();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_source;
        break;
      }

      // optional .mesos.TaskStatus.Source source = 9;
      case 9: {
        if (tag == 72) {
         parse_source:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskStatus_Source_IsValid(value)) {
            set_source(static_cast< ::mesos::TaskStatus_Source >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(80)) goto parse_reason;
        break;
      }

      // optional .mesos.TaskStatus.Reason reason = 10;
      case 10: {
        if (tag == 80) {
         parse_reason:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::TaskStatus_Reason_IsValid(value)) {
            set_reason(static_cast< ::mesos::TaskStatus_Reason >(value));
          } else {
            mutable_unknown_fields()->AddVarint(10, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(90)) goto parse_uuid;
        break;
      }

      // optional bytes uuid = 11;
      case 11: {
        if (tag == 90) {
         parse_uuid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_uuid()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(98)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 12;
      case 12: {
        if (tag == 98) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(106)) goto parse_container_status;
        break;
      }

      // optional .mesos.ContainerStatus container_status = 13;
      case 13: {
        if (tag == 106) {
         parse_container_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(114)) goto parse_unreachable_time;
        break;
      }

      // optional .mesos.TimeInfo unreachable_time = 14;
      case 14: {
        if (tag == 114) {
         parse_unreachable_time:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_unreachable_time()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(122)) goto parse_check_status;
        break;
      }

      // optional .mesos.CheckStatusInfo check_status = 15;
      case 15: {
        if (tag == 122) {
         parse_check_status:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_check_status()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TaskStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TaskStatus)
  return false;
#undef DO_
}

void TaskStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TaskStatus)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->task_id_, output);
  }

  // required .mesos.TaskState state = 2;
  if (has_state()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->state(), output);
  }

  // optional bytes data = 3;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->data(), output);
  }

  // optional string message = 4;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TaskStatus.message");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->message(), output);
  }

  // optional .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->slave_id_, output);
  }

  // optional double timestamp = 6;
  if (has_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(6, this->timestamp(), output);
  }

  // optional .mesos.ExecutorID executor_id = 7;
  if (has_executor_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->executor_id_, output);
  }

  // optional bool healthy = 8;
  if (has_healthy()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(8, this->healthy(), output);
  }

  // optional .mesos.TaskStatus.Source source = 9;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->source(), output);
  }

  // optional .mesos.TaskStatus.Reason reason = 10;
  if (has_reason()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      10, this->reason(), output);
  }

  // optional bytes uuid = 11;
  if (has_uuid()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      11, this->uuid(), output);
  }

  // optional .mesos.Labels labels = 12;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      12, *this->labels_, output);
  }

  // optional .mesos.ContainerStatus container_status = 13;
  if (has_container_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, *this->container_status_, output);
  }

  // optional .mesos.TimeInfo unreachable_time = 14;
  if (has_unreachable_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      14, *this->unreachable_time_, output);
  }

  // optional .mesos.CheckStatusInfo check_status = 15;
  if (has_check_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      15, *this->check_status_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TaskStatus)
}

::google::protobuf::uint8* TaskStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TaskStatus)
  // required .mesos.TaskID task_id = 1;
  if (has_task_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->task_id_, false, target);
  }

  // required .mesos.TaskState state = 2;
  if (has_state()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->state(), target);
  }

  // optional bytes data = 3;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->data(), target);
  }

  // optional string message = 4;
  if (has_message()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->message().data(), this->message().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.TaskStatus.message");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->message(), target);
  }

  // optional .mesos.SlaveID slave_id = 5;
  if (has_slave_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->slave_id_, false, target);
  }

  // optional double timestamp = 6;
  if (has_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(6, this->timestamp(), target);
  }

  // optional .mesos.ExecutorID executor_id = 7;
  if (has_executor_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->executor_id_, false, target);
  }

  // optional bool healthy = 8;
  if (has_healthy()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(8, this->healthy(), target);
  }

  // optional .mesos.TaskStatus.Source source = 9;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->source(), target);
  }

  // optional .mesos.TaskStatus.Reason reason = 10;
  if (has_reason()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      10, this->reason(), target);
  }

  // optional bytes uuid = 11;
  if (has_uuid()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        11, this->uuid(), target);
  }

  // optional .mesos.Labels labels = 12;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        12, *this->labels_, false, target);
  }

  // optional .mesos.ContainerStatus container_status = 13;
  if (has_container_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        13, *this->container_status_, false, target);
  }

  // optional .mesos.TimeInfo unreachable_time = 14;
  if (has_unreachable_time()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        14, *this->unreachable_time_, false, target);
  }

  // optional .mesos.CheckStatusInfo check_status = 15;
  if (has_check_status()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        15, *this->check_status_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TaskStatus)
  return target;
}

int TaskStatus::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.TaskStatus)
  int total_size = 0;

  if (has_task_id()) {
    // required .mesos.TaskID task_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_id_);
  }

  if (has_state()) {
    // required .mesos.TaskState state = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());
  }

  return total_size;
}
int TaskStatus::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TaskStatus)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mesos.TaskID task_id = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->task_id_);

    // required .mesos.TaskState state = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->state());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 252u) {
    // optional string message = 4;
    if (has_message()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->message());
    }

    // optional .mesos.TaskStatus.Source source = 9;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->source());
    }

    // optional .mesos.TaskStatus.Reason reason = 10;
    if (has_reason()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->reason());
    }

    // optional bytes data = 3;
    if (has_data()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->data());
    }

    // optional .mesos.SlaveID slave_id = 5;
    if (has_slave_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->slave_id_);
    }

    // optional .mesos.ExecutorID executor_id = 7;
    if (has_executor_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->executor_id_);
    }

  }
  if (_has_bits_[8 / 32] & 32512u) {
    // optional double timestamp = 6;
    if (has_timestamp()) {
      total_size += 1 + 8;
    }

    // optional bytes uuid = 11;
    if (has_uuid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->uuid());
    }

    // optional bool healthy = 8;
    if (has_healthy()) {
      total_size += 1 + 1;
    }

    // optional .mesos.CheckStatusInfo check_status = 15;
    if (has_check_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->check_status_);
    }

    // optional .mesos.Labels labels = 12;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

    // optional .mesos.ContainerStatus container_status = 13;
    if (has_container_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->container_status_);
    }

    // optional .mesos.TimeInfo unreachable_time = 14;
    if (has_unreachable_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->unreachable_time_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TaskStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TaskStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TaskStatus* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TaskStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TaskStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TaskStatus)
    MergeFrom(*source);
  }
}

void TaskStatus::MergeFrom(const TaskStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TaskStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_task_id()) {
      mutable_task_id()->::mesos::TaskID::MergeFrom(from.task_id());
    }
    if (from.has_state()) {
      set_state(from.state());
    }
    if (from.has_message()) {
      set_has_message();
      message_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.message_);
    }
    if (from.has_source()) {
      set_source(from.source());
    }
    if (from.has_reason()) {
      set_reason(from.reason());
    }
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
    if (from.has_slave_id()) {
      mutable_slave_id()->::mesos::SlaveID::MergeFrom(from.slave_id());
    }
    if (from.has_executor_id()) {
      mutable_executor_id()->::mesos::ExecutorID::MergeFrom(from.executor_id());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_timestamp()) {
      set_timestamp(from.timestamp());
    }
    if (from.has_uuid()) {
      set_has_uuid();
      uuid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uuid_);
    }
    if (from.has_healthy()) {
      set_healthy(from.healthy());
    }
    if (from.has_check_status()) {
      mutable_check_status()->::mesos::CheckStatusInfo::MergeFrom(from.check_status());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
    if (from.has_container_status()) {
      mutable_container_status()->::mesos::ContainerStatus::MergeFrom(from.container_status());
    }
    if (from.has_unreachable_time()) {
      mutable_unreachable_time()->::mesos::TimeInfo::MergeFrom(from.unreachable_time());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TaskStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TaskStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TaskStatus::CopyFrom(const TaskStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TaskStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TaskStatus::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_task_id()) {
    if (!this->task_id_->IsInitialized()) return false;
  }
  if (has_slave_id()) {
    if (!this->slave_id_->IsInitialized()) return false;
  }
  if (has_executor_id()) {
    if (!this->executor_id_->IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  if (has_container_status()) {
    if (!this->container_status_->IsInitialized()) return false;
  }
  if (has_unreachable_time()) {
    if (!this->unreachable_time_->IsInitialized()) return false;
  }
  return true;
}

void TaskStatus::Swap(TaskStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TaskStatus::InternalSwap(TaskStatus* other) {
  std::swap(task_id_, other->task_id_);
  std::swap(state_, other->state_);
  message_.Swap(&other->message_);
  std::swap(source_, other->source_);
  std::swap(reason_, other->reason_);
  data_.Swap(&other->data_);
  std::swap(slave_id_, other->slave_id_);
  std::swap(executor_id_, other->executor_id_);
  std::swap(timestamp_, other->timestamp_);
  uuid_.Swap(&other->uuid_);
  std::swap(healthy_, other->healthy_);
  std::swap(check_status_, other->check_status_);
  std::swap(labels_, other->labels_);
  std::swap(container_status_, other->container_status_);
  std::swap(unreachable_time_, other->unreachable_time_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TaskStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TaskStatus_descriptor_;
  metadata.reflection = TaskStatus_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TaskStatus

// required .mesos.TaskID task_id = 1;
bool TaskStatus::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TaskStatus::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
void TaskStatus::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void TaskStatus::clear_task_id() {
  if (task_id_ != NULL) task_id_->::mesos::TaskID::Clear();
  clear_has_task_id();
}
const ::mesos::TaskID& TaskStatus::task_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.task_id)
  return task_id_ != NULL ? *task_id_ : *default_instance_->task_id_;
}
::mesos::TaskID* TaskStatus::mutable_task_id() {
  set_has_task_id();
  if (task_id_ == NULL) {
    task_id_ = new ::mesos::TaskID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.task_id)
  return task_id_;
}
::mesos::TaskID* TaskStatus::release_task_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.task_id)
  clear_has_task_id();
  ::mesos::TaskID* temp = task_id_;
  task_id_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_task_id(::mesos::TaskID* task_id) {
  delete task_id_;
  task_id_ = task_id;
  if (task_id) {
    set_has_task_id();
  } else {
    clear_has_task_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.task_id)
}

// required .mesos.TaskState state = 2;
bool TaskStatus::has_state() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TaskStatus::set_has_state() {
  _has_bits_[0] |= 0x00000002u;
}
void TaskStatus::clear_has_state() {
  _has_bits_[0] &= ~0x00000002u;
}
void TaskStatus::clear_state() {
  state_ = 6;
  clear_has_state();
}
 ::mesos::TaskState TaskStatus::state() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.state)
  return static_cast< ::mesos::TaskState >(state_);
}
 void TaskStatus::set_state(::mesos::TaskState value) {
  assert(::mesos::TaskState_IsValid(value));
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.state)
}

// optional string message = 4;
bool TaskStatus::has_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void TaskStatus::set_has_message() {
  _has_bits_[0] |= 0x00000004u;
}
void TaskStatus::clear_has_message() {
  _has_bits_[0] &= ~0x00000004u;
}
void TaskStatus::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_message();
}
 const ::std::string& TaskStatus::message() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.message)
  return message_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskStatus::set_message(const ::std::string& value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.message)
}
 void TaskStatus::set_message(const char* value) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.message)
}
 void TaskStatus::set_message(const char* value, size_t size) {
  set_has_message();
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.message)
}
 ::std::string* TaskStatus::mutable_message() {
  set_has_message();
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TaskStatus::release_message() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.message)
  clear_has_message();
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskStatus::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    set_has_message();
  } else {
    clear_has_message();
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.message)
}

// optional .mesos.TaskStatus.Source source = 9;
bool TaskStatus::has_source() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void TaskStatus::set_has_source() {
  _has_bits_[0] |= 0x00000008u;
}
void TaskStatus::clear_has_source() {
  _has_bits_[0] &= ~0x00000008u;
}
void TaskStatus::clear_source() {
  source_ = 0;
  clear_has_source();
}
 ::mesos::TaskStatus_Source TaskStatus::source() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.source)
  return static_cast< ::mesos::TaskStatus_Source >(source_);
}
 void TaskStatus::set_source(::mesos::TaskStatus_Source value) {
  assert(::mesos::TaskStatus_Source_IsValid(value));
  set_has_source();
  source_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.source)
}

// optional .mesos.TaskStatus.Reason reason = 10;
bool TaskStatus::has_reason() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void TaskStatus::set_has_reason() {
  _has_bits_[0] |= 0x00000010u;
}
void TaskStatus::clear_has_reason() {
  _has_bits_[0] &= ~0x00000010u;
}
void TaskStatus::clear_reason() {
  reason_ = 0;
  clear_has_reason();
}
 ::mesos::TaskStatus_Reason TaskStatus::reason() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.reason)
  return static_cast< ::mesos::TaskStatus_Reason >(reason_);
}
 void TaskStatus::set_reason(::mesos::TaskStatus_Reason value) {
  assert(::mesos::TaskStatus_Reason_IsValid(value));
  set_has_reason();
  reason_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.reason)
}

// optional bytes data = 3;
bool TaskStatus::has_data() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void TaskStatus::set_has_data() {
  _has_bits_[0] |= 0x00000020u;
}
void TaskStatus::clear_has_data() {
  _has_bits_[0] &= ~0x00000020u;
}
void TaskStatus::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& TaskStatus::data() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskStatus::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.data)
}
 void TaskStatus::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.data)
}
 void TaskStatus::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.data)
}
 ::std::string* TaskStatus::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TaskStatus::release_data() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskStatus::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.data)
}

// optional .mesos.SlaveID slave_id = 5;
bool TaskStatus::has_slave_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void TaskStatus::set_has_slave_id() {
  _has_bits_[0] |= 0x00000040u;
}
void TaskStatus::clear_has_slave_id() {
  _has_bits_[0] &= ~0x00000040u;
}
void TaskStatus::clear_slave_id() {
  if (slave_id_ != NULL) slave_id_->::mesos::SlaveID::Clear();
  clear_has_slave_id();
}
const ::mesos::SlaveID& TaskStatus::slave_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.slave_id)
  return slave_id_ != NULL ? *slave_id_ : *default_instance_->slave_id_;
}
::mesos::SlaveID* TaskStatus::mutable_slave_id() {
  set_has_slave_id();
  if (slave_id_ == NULL) {
    slave_id_ = new ::mesos::SlaveID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.slave_id)
  return slave_id_;
}
::mesos::SlaveID* TaskStatus::release_slave_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.slave_id)
  clear_has_slave_id();
  ::mesos::SlaveID* temp = slave_id_;
  slave_id_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_slave_id(::mesos::SlaveID* slave_id) {
  delete slave_id_;
  slave_id_ = slave_id;
  if (slave_id) {
    set_has_slave_id();
  } else {
    clear_has_slave_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.slave_id)
}

// optional .mesos.ExecutorID executor_id = 7;
bool TaskStatus::has_executor_id() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void TaskStatus::set_has_executor_id() {
  _has_bits_[0] |= 0x00000080u;
}
void TaskStatus::clear_has_executor_id() {
  _has_bits_[0] &= ~0x00000080u;
}
void TaskStatus::clear_executor_id() {
  if (executor_id_ != NULL) executor_id_->::mesos::ExecutorID::Clear();
  clear_has_executor_id();
}
const ::mesos::ExecutorID& TaskStatus::executor_id() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.executor_id)
  return executor_id_ != NULL ? *executor_id_ : *default_instance_->executor_id_;
}
::mesos::ExecutorID* TaskStatus::mutable_executor_id() {
  set_has_executor_id();
  if (executor_id_ == NULL) {
    executor_id_ = new ::mesos::ExecutorID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.executor_id)
  return executor_id_;
}
::mesos::ExecutorID* TaskStatus::release_executor_id() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.executor_id)
  clear_has_executor_id();
  ::mesos::ExecutorID* temp = executor_id_;
  executor_id_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_executor_id(::mesos::ExecutorID* executor_id) {
  delete executor_id_;
  executor_id_ = executor_id;
  if (executor_id) {
    set_has_executor_id();
  } else {
    clear_has_executor_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.executor_id)
}

// optional double timestamp = 6;
bool TaskStatus::has_timestamp() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void TaskStatus::set_has_timestamp() {
  _has_bits_[0] |= 0x00000100u;
}
void TaskStatus::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000100u;
}
void TaskStatus::clear_timestamp() {
  timestamp_ = 0;
  clear_has_timestamp();
}
 double TaskStatus::timestamp() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.timestamp)
  return timestamp_;
}
 void TaskStatus::set_timestamp(double value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.timestamp)
}

// optional bytes uuid = 11;
bool TaskStatus::has_uuid() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
void TaskStatus::set_has_uuid() {
  _has_bits_[0] |= 0x00000200u;
}
void TaskStatus::clear_has_uuid() {
  _has_bits_[0] &= ~0x00000200u;
}
void TaskStatus::clear_uuid() {
  uuid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uuid();
}
 const ::std::string& TaskStatus::uuid() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.uuid)
  return uuid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskStatus::set_uuid(const ::std::string& value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.uuid)
}
 void TaskStatus::set_uuid(const char* value) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.TaskStatus.uuid)
}
 void TaskStatus::set_uuid(const void* value, size_t size) {
  set_has_uuid();
  uuid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.TaskStatus.uuid)
}
 ::std::string* TaskStatus::mutable_uuid() {
  set_has_uuid();
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.uuid)
  return uuid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* TaskStatus::release_uuid() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.uuid)
  clear_has_uuid();
  return uuid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void TaskStatus::set_allocated_uuid(::std::string* uuid) {
  if (uuid != NULL) {
    set_has_uuid();
  } else {
    clear_has_uuid();
  }
  uuid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uuid);
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.uuid)
}

// optional bool healthy = 8;
bool TaskStatus::has_healthy() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
void TaskStatus::set_has_healthy() {
  _has_bits_[0] |= 0x00000400u;
}
void TaskStatus::clear_has_healthy() {
  _has_bits_[0] &= ~0x00000400u;
}
void TaskStatus::clear_healthy() {
  healthy_ = false;
  clear_has_healthy();
}
 bool TaskStatus::healthy() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.healthy)
  return healthy_;
}
 void TaskStatus::set_healthy(bool value) {
  set_has_healthy();
  healthy_ = value;
  // @@protoc_insertion_point(field_set:mesos.TaskStatus.healthy)
}

// optional .mesos.CheckStatusInfo check_status = 15;
bool TaskStatus::has_check_status() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
void TaskStatus::set_has_check_status() {
  _has_bits_[0] |= 0x00000800u;
}
void TaskStatus::clear_has_check_status() {
  _has_bits_[0] &= ~0x00000800u;
}
void TaskStatus::clear_check_status() {
  if (check_status_ != NULL) check_status_->::mesos::CheckStatusInfo::Clear();
  clear_has_check_status();
}
const ::mesos::CheckStatusInfo& TaskStatus::check_status() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.check_status)
  return check_status_ != NULL ? *check_status_ : *default_instance_->check_status_;
}
::mesos::CheckStatusInfo* TaskStatus::mutable_check_status() {
  set_has_check_status();
  if (check_status_ == NULL) {
    check_status_ = new ::mesos::CheckStatusInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.check_status)
  return check_status_;
}
::mesos::CheckStatusInfo* TaskStatus::release_check_status() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.check_status)
  clear_has_check_status();
  ::mesos::CheckStatusInfo* temp = check_status_;
  check_status_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_check_status(::mesos::CheckStatusInfo* check_status) {
  delete check_status_;
  check_status_ = check_status;
  if (check_status) {
    set_has_check_status();
  } else {
    clear_has_check_status();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.check_status)
}

// optional .mesos.Labels labels = 12;
bool TaskStatus::has_labels() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
void TaskStatus::set_has_labels() {
  _has_bits_[0] |= 0x00001000u;
}
void TaskStatus::clear_has_labels() {
  _has_bits_[0] &= ~0x00001000u;
}
void TaskStatus::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& TaskStatus::labels() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* TaskStatus::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.labels)
  return labels_;
}
::mesos::Labels* TaskStatus::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.labels)
}

// optional .mesos.ContainerStatus container_status = 13;
bool TaskStatus::has_container_status() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
void TaskStatus::set_has_container_status() {
  _has_bits_[0] |= 0x00002000u;
}
void TaskStatus::clear_has_container_status() {
  _has_bits_[0] &= ~0x00002000u;
}
void TaskStatus::clear_container_status() {
  if (container_status_ != NULL) container_status_->::mesos::ContainerStatus::Clear();
  clear_has_container_status();
}
const ::mesos::ContainerStatus& TaskStatus::container_status() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.container_status)
  return container_status_ != NULL ? *container_status_ : *default_instance_->container_status_;
}
::mesos::ContainerStatus* TaskStatus::mutable_container_status() {
  set_has_container_status();
  if (container_status_ == NULL) {
    container_status_ = new ::mesos::ContainerStatus;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.container_status)
  return container_status_;
}
::mesos::ContainerStatus* TaskStatus::release_container_status() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.container_status)
  clear_has_container_status();
  ::mesos::ContainerStatus* temp = container_status_;
  container_status_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_container_status(::mesos::ContainerStatus* container_status) {
  delete container_status_;
  container_status_ = container_status;
  if (container_status) {
    set_has_container_status();
  } else {
    clear_has_container_status();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.container_status)
}

// optional .mesos.TimeInfo unreachable_time = 14;
bool TaskStatus::has_unreachable_time() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
void TaskStatus::set_has_unreachable_time() {
  _has_bits_[0] |= 0x00004000u;
}
void TaskStatus::clear_has_unreachable_time() {
  _has_bits_[0] &= ~0x00004000u;
}
void TaskStatus::clear_unreachable_time() {
  if (unreachable_time_ != NULL) unreachable_time_->::mesos::TimeInfo::Clear();
  clear_has_unreachable_time();
}
const ::mesos::TimeInfo& TaskStatus::unreachable_time() const {
  // @@protoc_insertion_point(field_get:mesos.TaskStatus.unreachable_time)
  return unreachable_time_ != NULL ? *unreachable_time_ : *default_instance_->unreachable_time_;
}
::mesos::TimeInfo* TaskStatus::mutable_unreachable_time() {
  set_has_unreachable_time();
  if (unreachable_time_ == NULL) {
    unreachable_time_ = new ::mesos::TimeInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TaskStatus.unreachable_time)
  return unreachable_time_;
}
::mesos::TimeInfo* TaskStatus::release_unreachable_time() {
  // @@protoc_insertion_point(field_release:mesos.TaskStatus.unreachable_time)
  clear_has_unreachable_time();
  ::mesos::TimeInfo* temp = unreachable_time_;
  unreachable_time_ = NULL;
  return temp;
}
void TaskStatus::set_allocated_unreachable_time(::mesos::TimeInfo* unreachable_time) {
  delete unreachable_time_;
  unreachable_time_ = unreachable_time;
  if (unreachable_time) {
    set_has_unreachable_time();
  } else {
    clear_has_unreachable_time();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TaskStatus.unreachable_time)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Filters::kRefuseSecondsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Filters::Filters()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Filters)
}

void Filters::InitAsDefaultInstance() {
}

Filters::Filters(const Filters& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Filters)
}

void Filters::SharedCtor() {
  _cached_size_ = 0;
  refuse_seconds_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Filters::~Filters() {
  // @@protoc_insertion_point(destructor:mesos.Filters)
  SharedDtor();
}

void Filters::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Filters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Filters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Filters_descriptor_;
}

const Filters& Filters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Filters* Filters::default_instance_ = NULL;

Filters* Filters::New(::google::protobuf::Arena* arena) const {
  Filters* n = new Filters;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Filters::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Filters)
  refuse_seconds_ = 5;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Filters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Filters)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double refuse_seconds = 1 [default = 5];
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &refuse_seconds_)));
          set_has_refuse_seconds();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Filters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Filters)
  return false;
#undef DO_
}

void Filters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Filters)
  // optional double refuse_seconds = 1 [default = 5];
  if (has_refuse_seconds()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->refuse_seconds(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Filters)
}

::google::protobuf::uint8* Filters::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Filters)
  // optional double refuse_seconds = 1 [default = 5];
  if (has_refuse_seconds()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->refuse_seconds(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Filters)
  return target;
}

int Filters::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Filters)
  int total_size = 0;

  // optional double refuse_seconds = 1 [default = 5];
  if (has_refuse_seconds()) {
    total_size += 1 + 8;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Filters::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Filters)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Filters* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Filters>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Filters)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Filters)
    MergeFrom(*source);
  }
}

void Filters::MergeFrom(const Filters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Filters)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_refuse_seconds()) {
      set_refuse_seconds(from.refuse_seconds());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Filters::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Filters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Filters::CopyFrom(const Filters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Filters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Filters::IsInitialized() const {

  return true;
}

void Filters::Swap(Filters* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Filters::InternalSwap(Filters* other) {
  std::swap(refuse_seconds_, other->refuse_seconds_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Filters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Filters_descriptor_;
  metadata.reflection = Filters_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Filters

// optional double refuse_seconds = 1 [default = 5];
bool Filters::has_refuse_seconds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Filters::set_has_refuse_seconds() {
  _has_bits_[0] |= 0x00000001u;
}
void Filters::clear_has_refuse_seconds() {
  _has_bits_[0] &= ~0x00000001u;
}
void Filters::clear_refuse_seconds() {
  refuse_seconds_ = 5;
  clear_has_refuse_seconds();
}
 double Filters::refuse_seconds() const {
  // @@protoc_insertion_point(field_get:mesos.Filters.refuse_seconds)
  return refuse_seconds_;
}
 void Filters::set_refuse_seconds(double value) {
  set_has_refuse_seconds();
  refuse_seconds_ = value;
  // @@protoc_insertion_point(field_set:mesos.Filters.refuse_seconds)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Environment_Variable_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_Variable_Type_descriptor_;
}
bool Environment_Variable_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Environment_Variable_Type Environment_Variable::UNKNOWN;
const Environment_Variable_Type Environment_Variable::VALUE;
const Environment_Variable_Type Environment_Variable::SECRET;
const Environment_Variable_Type Environment_Variable::Type_MIN;
const Environment_Variable_Type Environment_Variable::Type_MAX;
const int Environment_Variable::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Environment_Variable::kNameFieldNumber;
const int Environment_Variable::kTypeFieldNumber;
const int Environment_Variable::kValueFieldNumber;
const int Environment_Variable::kSecretFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Environment_Variable::Environment_Variable()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Environment.Variable)
}

void Environment_Variable::InitAsDefaultInstance() {
  secret_ = const_cast< ::mesos::Secret*>(&::mesos::Secret::default_instance());
}

Environment_Variable::Environment_Variable(const Environment_Variable& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Environment.Variable)
}

void Environment_Variable::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  type_ = 1;
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  secret_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Environment_Variable::~Environment_Variable() {
  // @@protoc_insertion_point(destructor:mesos.Environment.Variable)
  SharedDtor();
}

void Environment_Variable::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete secret_;
  }
}

void Environment_Variable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Environment_Variable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_Variable_descriptor_;
}

const Environment_Variable& Environment_Variable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Environment_Variable* Environment_Variable::default_instance_ = NULL;

Environment_Variable* Environment_Variable::New(::google::protobuf::Arena* arena) const {
  Environment_Variable* n = new Environment_Variable;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Environment_Variable::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Environment.Variable)
  if (_has_bits_[0 / 32] & 15u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    type_ = 1;
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_secret()) {
      if (secret_ != NULL) secret_->::mesos::Secret::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Environment_Variable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Environment.Variable)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Environment.Variable.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Environment.Variable.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_type;
        break;
      }

      // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
      case 3: {
        if (tag == 24) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Environment_Variable_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Environment_Variable_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_secret;
        break;
      }

      // optional .mesos.Secret secret = 4;
      case 4: {
        if (tag == 34) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_secret()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Environment.Variable)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Environment.Variable)
  return false;
#undef DO_
}

void Environment_Variable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Environment.Variable)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Environment.Variable.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Environment.Variable.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->type(), output);
  }

  // optional .mesos.Secret secret = 4;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->secret_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Environment.Variable)
}

::google::protobuf::uint8* Environment_Variable::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Environment.Variable)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Environment.Variable.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Environment.Variable.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->type(), target);
  }

  // optional .mesos.Secret secret = 4;
  if (has_secret()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->secret_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Environment.Variable)
  return target;
}

int Environment_Variable::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Environment.Variable)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  if (_has_bits_[1 / 32] & 14u) {
    // optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

    // optional .mesos.Secret secret = 4;
    if (has_secret()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->secret_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Environment_Variable::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Environment.Variable)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Environment_Variable* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Environment_Variable>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Environment.Variable)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Environment.Variable)
    MergeFrom(*source);
  }
}

void Environment_Variable::MergeFrom(const Environment_Variable& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Environment.Variable)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
    if (from.has_secret()) {
      mutable_secret()->::mesos::Secret::MergeFrom(from.secret());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Environment_Variable::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Environment.Variable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Environment_Variable::CopyFrom(const Environment_Variable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Environment.Variable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Environment_Variable::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_secret()) {
    if (!this->secret_->IsInitialized()) return false;
  }
  return true;
}

void Environment_Variable::Swap(Environment_Variable* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Environment_Variable::InternalSwap(Environment_Variable* other) {
  name_.Swap(&other->name_);
  std::swap(type_, other->type_);
  value_.Swap(&other->value_);
  std::swap(secret_, other->secret_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Environment_Variable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Environment_Variable_descriptor_;
  metadata.reflection = Environment_Variable_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Environment::kVariablesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Environment::Environment()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Environment)
}

void Environment::InitAsDefaultInstance() {
}

Environment::Environment(const Environment& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Environment)
}

void Environment::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Environment::~Environment() {
  // @@protoc_insertion_point(destructor:mesos.Environment)
  SharedDtor();
}

void Environment::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Environment::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Environment::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Environment_descriptor_;
}

const Environment& Environment::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Environment* Environment::default_instance_ = NULL;

Environment* Environment::New(::google::protobuf::Arena* arena) const {
  Environment* n = new Environment;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Environment::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Environment)
  variables_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Environment::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Environment)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Environment.Variable variables = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_variables:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_variables()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_variables;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Environment)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Environment)
  return false;
#undef DO_
}

void Environment::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Environment)
  // repeated .mesos.Environment.Variable variables = 1;
  for (unsigned int i = 0, n = this->variables_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->variables(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Environment)
}

::google::protobuf::uint8* Environment::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Environment)
  // repeated .mesos.Environment.Variable variables = 1;
  for (unsigned int i = 0, n = this->variables_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->variables(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Environment)
  return target;
}

int Environment::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Environment)
  int total_size = 0;

  // repeated .mesos.Environment.Variable variables = 1;
  total_size += 1 * this->variables_size();
  for (int i = 0; i < this->variables_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->variables(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Environment::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Environment)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Environment* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Environment>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Environment)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Environment)
    MergeFrom(*source);
  }
}

void Environment::MergeFrom(const Environment& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Environment)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  variables_.MergeFrom(from.variables_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Environment::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Environment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Environment::CopyFrom(const Environment& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Environment)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Environment::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->variables())) return false;
  return true;
}

void Environment::Swap(Environment* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Environment::InternalSwap(Environment* other) {
  variables_.UnsafeArenaSwap(&other->variables_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Environment::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Environment_descriptor_;
  metadata.reflection = Environment_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Environment_Variable

// required string name = 1;
bool Environment_Variable::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Environment_Variable::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Environment_Variable::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Environment_Variable::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Environment_Variable::name() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Environment_Variable::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.name)
}
 void Environment_Variable::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Environment.Variable.name)
}
 void Environment_Variable::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Environment.Variable.name)
}
 ::std::string* Environment_Variable::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Environment_Variable::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Environment.Variable.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Environment_Variable::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.name)
}

// optional .mesos.Environment.Variable.Type type = 3 [default = VALUE];
bool Environment_Variable::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Environment_Variable::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
void Environment_Variable::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
void Environment_Variable::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::mesos::Environment_Variable_Type Environment_Variable::type() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.type)
  return static_cast< ::mesos::Environment_Variable_Type >(type_);
}
 void Environment_Variable::set_type(::mesos::Environment_Variable_Type value) {
  assert(::mesos::Environment_Variable_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.type)
}

// optional string value = 2;
bool Environment_Variable::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Environment_Variable::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
void Environment_Variable::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void Environment_Variable::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Environment_Variable::value() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Environment_Variable::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Environment.Variable.value)
}
 void Environment_Variable::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Environment.Variable.value)
}
 void Environment_Variable::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Environment.Variable.value)
}
 ::std::string* Environment_Variable::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Environment_Variable::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Environment.Variable.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Environment_Variable::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.value)
}

// optional .mesos.Secret secret = 4;
bool Environment_Variable::has_secret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Environment_Variable::set_has_secret() {
  _has_bits_[0] |= 0x00000008u;
}
void Environment_Variable::clear_has_secret() {
  _has_bits_[0] &= ~0x00000008u;
}
void Environment_Variable::clear_secret() {
  if (secret_ != NULL) secret_->::mesos::Secret::Clear();
  clear_has_secret();
}
const ::mesos::Secret& Environment_Variable::secret() const {
  // @@protoc_insertion_point(field_get:mesos.Environment.Variable.secret)
  return secret_ != NULL ? *secret_ : *default_instance_->secret_;
}
::mesos::Secret* Environment_Variable::mutable_secret() {
  set_has_secret();
  if (secret_ == NULL) {
    secret_ = new ::mesos::Secret;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Environment.Variable.secret)
  return secret_;
}
::mesos::Secret* Environment_Variable::release_secret() {
  // @@protoc_insertion_point(field_release:mesos.Environment.Variable.secret)
  clear_has_secret();
  ::mesos::Secret* temp = secret_;
  secret_ = NULL;
  return temp;
}
void Environment_Variable::set_allocated_secret(::mesos::Secret* secret) {
  delete secret_;
  secret_ = secret;
  if (secret) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Environment.Variable.secret)
}

// -------------------------------------------------------------------

// Environment

// repeated .mesos.Environment.Variable variables = 1;
int Environment::variables_size() const {
  return variables_.size();
}
void Environment::clear_variables() {
  variables_.Clear();
}
const ::mesos::Environment_Variable& Environment::variables(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Environment.variables)
  return variables_.Get(index);
}
::mesos::Environment_Variable* Environment::mutable_variables(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Environment.variables)
  return variables_.Mutable(index);
}
::mesos::Environment_Variable* Environment::add_variables() {
  // @@protoc_insertion_point(field_add:mesos.Environment.variables)
  return variables_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >*
Environment::mutable_variables() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Environment.variables)
  return &variables_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Environment_Variable >&
Environment::variables() const {
  // @@protoc_insertion_point(field_list:mesos.Environment.variables)
  return variables_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Parameter::kKeyFieldNumber;
const int Parameter::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Parameter::Parameter()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Parameter)
}

void Parameter::InitAsDefaultInstance() {
}

Parameter::Parameter(const Parameter& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Parameter)
}

void Parameter::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Parameter::~Parameter() {
  // @@protoc_insertion_point(destructor:mesos.Parameter)
  SharedDtor();
}

void Parameter::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Parameter::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Parameter::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Parameter_descriptor_;
}

const Parameter& Parameter::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Parameter* Parameter::default_instance_ = NULL;

Parameter* Parameter::New(::google::protobuf::Arena* arena) const {
  Parameter* n = new Parameter;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Parameter::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Parameter)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Parameter::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Parameter)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Parameter.key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Parameter.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Parameter)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Parameter)
  return false;
#undef DO_
}

void Parameter::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Parameter)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Parameter.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Parameter.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Parameter)
}

::google::protobuf::uint8* Parameter::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Parameter)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Parameter.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Parameter.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Parameter)
  return target;
}

int Parameter::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Parameter)
  int total_size = 0;

  if (has_key()) {
    // required string key = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  if (has_value()) {
    // required string value = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  return total_size;
}
int Parameter::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Parameter)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string key = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());

    // required string value = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Parameter::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Parameter)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Parameter* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Parameter>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Parameter)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Parameter)
    MergeFrom(*source);
  }
}

void Parameter::MergeFrom(const Parameter& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Parameter)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Parameter::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Parameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Parameter::CopyFrom(const Parameter& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Parameter)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameter::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void Parameter::Swap(Parameter* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Parameter::InternalSwap(Parameter* other) {
  key_.Swap(&other->key_);
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Parameter::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Parameter_descriptor_;
  metadata.reflection = Parameter_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Parameter

// required string key = 1;
bool Parameter::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Parameter::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void Parameter::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void Parameter::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& Parameter::key() const {
  // @@protoc_insertion_point(field_get:mesos.Parameter.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Parameter::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Parameter.key)
}
 void Parameter::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Parameter.key)
}
 void Parameter::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Parameter.key)
}
 ::std::string* Parameter::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mesos.Parameter.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Parameter::release_key() {
  // @@protoc_insertion_point(field_release:mesos.Parameter.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Parameter::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mesos.Parameter.key)
}

// required string value = 2;
bool Parameter::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Parameter::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void Parameter::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void Parameter::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Parameter::value() const {
  // @@protoc_insertion_point(field_get:mesos.Parameter.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Parameter::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Parameter.value)
}
 void Parameter::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Parameter.value)
}
 void Parameter::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Parameter.value)
}
 ::std::string* Parameter::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Parameter.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Parameter::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Parameter.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Parameter::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.Parameter.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Parameters::kParameterFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Parameters::Parameters()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Parameters)
}

void Parameters::InitAsDefaultInstance() {
}

Parameters::Parameters(const Parameters& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Parameters)
}

void Parameters::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Parameters::~Parameters() {
  // @@protoc_insertion_point(destructor:mesos.Parameters)
  SharedDtor();
}

void Parameters::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Parameters::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Parameters::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Parameters_descriptor_;
}

const Parameters& Parameters::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Parameters* Parameters::default_instance_ = NULL;

Parameters* Parameters::New(::google::protobuf::Arena* arena) const {
  Parameters* n = new Parameters;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Parameters::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Parameters)
  parameter_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Parameters::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Parameters)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Parameter parameter = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_parameter:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_parameter()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_parameter;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Parameters)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Parameters)
  return false;
#undef DO_
}

void Parameters::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Parameters)
  // repeated .mesos.Parameter parameter = 1;
  for (unsigned int i = 0, n = this->parameter_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->parameter(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Parameters)
}

::google::protobuf::uint8* Parameters::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Parameters)
  // repeated .mesos.Parameter parameter = 1;
  for (unsigned int i = 0, n = this->parameter_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->parameter(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Parameters)
  return target;
}

int Parameters::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Parameters)
  int total_size = 0;

  // repeated .mesos.Parameter parameter = 1;
  total_size += 1 * this->parameter_size();
  for (int i = 0; i < this->parameter_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->parameter(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Parameters::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Parameters)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Parameters* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Parameters>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Parameters)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Parameters)
    MergeFrom(*source);
  }
}

void Parameters::MergeFrom(const Parameters& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Parameters)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  parameter_.MergeFrom(from.parameter_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Parameters::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Parameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Parameters::CopyFrom(const Parameters& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Parameters)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Parameters::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->parameter())) return false;
  return true;
}

void Parameters::Swap(Parameters* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Parameters::InternalSwap(Parameters* other) {
  parameter_.UnsafeArenaSwap(&other->parameter_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Parameters::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Parameters_descriptor_;
  metadata.reflection = Parameters_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Parameters

// repeated .mesos.Parameter parameter = 1;
int Parameters::parameter_size() const {
  return parameter_.size();
}
void Parameters::clear_parameter() {
  parameter_.Clear();
}
const ::mesos::Parameter& Parameters::parameter(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Parameters.parameter)
  return parameter_.Get(index);
}
::mesos::Parameter* Parameters::mutable_parameter(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Parameters.parameter)
  return parameter_.Mutable(index);
}
::mesos::Parameter* Parameters::add_parameter() {
  // @@protoc_insertion_point(field_add:mesos.Parameters.parameter)
  return parameter_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
Parameters::mutable_parameter() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Parameters.parameter)
  return &parameter_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
Parameters::parameter() const {
  // @@protoc_insertion_point(field_list:mesos.Parameters.parameter)
  return parameter_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Credential::kPrincipalFieldNumber;
const int Credential::kSecretFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Credential::Credential()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Credential)
}

void Credential::InitAsDefaultInstance() {
}

Credential::Credential(const Credential& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Credential)
}

void Credential::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  secret_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Credential::~Credential() {
  // @@protoc_insertion_point(destructor:mesos.Credential)
  SharedDtor();
}

void Credential::SharedDtor() {
  principal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  secret_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Credential::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Credential::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Credential_descriptor_;
}

const Credential& Credential::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Credential* Credential::default_instance_ = NULL;

Credential* Credential::New(::google::protobuf::Arena* arena) const {
  Credential* n = new Credential;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Credential::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Credential)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_principal()) {
      principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_secret()) {
      secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Credential::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Credential)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string principal = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Credential.principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_secret;
        break;
      }

      // optional string secret = 2;
      case 2: {
        if (tag == 18) {
         parse_secret:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_secret()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->secret().data(), this->secret().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Credential.secret");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Credential)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Credential)
  return false;
#undef DO_
}

void Credential::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Credential)
  // required string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Credential.principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->principal(), output);
  }

  // optional string secret = 2;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Credential.secret");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->secret(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Credential)
}

::google::protobuf::uint8* Credential::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Credential)
  // required string principal = 1;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Credential.principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->principal(), target);
  }

  // optional string secret = 2;
  if (has_secret()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->secret().data(), this->secret().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Credential.secret");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->secret(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Credential)
  return target;
}

int Credential::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Credential)
  int total_size = 0;

  // required string principal = 1;
  if (has_principal()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->principal());
  }
  // optional string secret = 2;
  if (has_secret()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->secret());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Credential::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Credential)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Credential* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Credential>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Credential)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Credential)
    MergeFrom(*source);
  }
}

void Credential::MergeFrom(const Credential& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Credential)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_principal()) {
      set_has_principal();
      principal_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.principal_);
    }
    if (from.has_secret()) {
      set_has_secret();
      secret_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.secret_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Credential::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Credential)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Credential::CopyFrom(const Credential& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Credential)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Credential::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Credential::Swap(Credential* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Credential::InternalSwap(Credential* other) {
  principal_.Swap(&other->principal_);
  secret_.Swap(&other->secret_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Credential::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Credential_descriptor_;
  metadata.reflection = Credential_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Credential

// required string principal = 1;
bool Credential::has_principal() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Credential::set_has_principal() {
  _has_bits_[0] |= 0x00000001u;
}
void Credential::clear_has_principal() {
  _has_bits_[0] &= ~0x00000001u;
}
void Credential::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_principal();
}
 const ::std::string& Credential::principal() const {
  // @@protoc_insertion_point(field_get:mesos.Credential.principal)
  return principal_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Credential::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Credential.principal)
}
 void Credential::set_principal(const char* value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Credential.principal)
}
 void Credential::set_principal(const char* value, size_t size) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Credential.principal)
}
 ::std::string* Credential::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.Credential.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Credential::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.Credential.principal)
  clear_has_principal();
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Credential::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:mesos.Credential.principal)
}

// optional string secret = 2;
bool Credential::has_secret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Credential::set_has_secret() {
  _has_bits_[0] |= 0x00000002u;
}
void Credential::clear_has_secret() {
  _has_bits_[0] &= ~0x00000002u;
}
void Credential::clear_secret() {
  secret_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_secret();
}
 const ::std::string& Credential::secret() const {
  // @@protoc_insertion_point(field_get:mesos.Credential.secret)
  return secret_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Credential::set_secret(const ::std::string& value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Credential.secret)
}
 void Credential::set_secret(const char* value) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Credential.secret)
}
 void Credential::set_secret(const char* value, size_t size) {
  set_has_secret();
  secret_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Credential.secret)
}
 ::std::string* Credential::mutable_secret() {
  set_has_secret();
  // @@protoc_insertion_point(field_mutable:mesos.Credential.secret)
  return secret_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Credential::release_secret() {
  // @@protoc_insertion_point(field_release:mesos.Credential.secret)
  clear_has_secret();
  return secret_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Credential::set_allocated_secret(::std::string* secret) {
  if (secret != NULL) {
    set_has_secret();
  } else {
    clear_has_secret();
  }
  secret_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), secret);
  // @@protoc_insertion_point(field_set_allocated:mesos.Credential.secret)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Credentials::kCredentialsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Credentials::Credentials()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Credentials)
}

void Credentials::InitAsDefaultInstance() {
}

Credentials::Credentials(const Credentials& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Credentials)
}

void Credentials::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Credentials::~Credentials() {
  // @@protoc_insertion_point(destructor:mesos.Credentials)
  SharedDtor();
}

void Credentials::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Credentials::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Credentials::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Credentials_descriptor_;
}

const Credentials& Credentials::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Credentials* Credentials::default_instance_ = NULL;

Credentials* Credentials::New(::google::protobuf::Arena* arena) const {
  Credentials* n = new Credentials;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Credentials::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Credentials)
  credentials_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Credentials::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Credentials)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Credential credentials = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_credentials:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_credentials()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_credentials;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Credentials)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Credentials)
  return false;
#undef DO_
}

void Credentials::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Credentials)
  // repeated .mesos.Credential credentials = 1;
  for (unsigned int i = 0, n = this->credentials_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->credentials(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Credentials)
}

::google::protobuf::uint8* Credentials::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Credentials)
  // repeated .mesos.Credential credentials = 1;
  for (unsigned int i = 0, n = this->credentials_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->credentials(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Credentials)
  return target;
}

int Credentials::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Credentials)
  int total_size = 0;

  // repeated .mesos.Credential credentials = 1;
  total_size += 1 * this->credentials_size();
  for (int i = 0; i < this->credentials_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->credentials(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Credentials::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Credentials)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Credentials* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Credentials>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Credentials)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Credentials)
    MergeFrom(*source);
  }
}

void Credentials::MergeFrom(const Credentials& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Credentials)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  credentials_.MergeFrom(from.credentials_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Credentials::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Credentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Credentials::CopyFrom(const Credentials& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Credentials)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Credentials::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->credentials())) return false;
  return true;
}

void Credentials::Swap(Credentials* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Credentials::InternalSwap(Credentials* other) {
  credentials_.UnsafeArenaSwap(&other->credentials_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Credentials::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Credentials_descriptor_;
  metadata.reflection = Credentials_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Credentials

// repeated .mesos.Credential credentials = 1;
int Credentials::credentials_size() const {
  return credentials_.size();
}
void Credentials::clear_credentials() {
  credentials_.Clear();
}
const ::mesos::Credential& Credentials::credentials(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Credentials.credentials)
  return credentials_.Get(index);
}
::mesos::Credential* Credentials::mutable_credentials(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Credentials.credentials)
  return credentials_.Mutable(index);
}
::mesos::Credential* Credentials::add_credentials() {
  // @@protoc_insertion_point(field_add:mesos.Credentials.credentials)
  return credentials_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Credential >*
Credentials::mutable_credentials() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Credentials.credentials)
  return &credentials_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Credential >&
Credentials::credentials() const {
  // @@protoc_insertion_point(field_list:mesos.Credentials.credentials)
  return credentials_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Secret_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_Type_descriptor_;
}
bool Secret_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Secret_Type Secret::UNKNOWN;
const Secret_Type Secret::REFERENCE;
const Secret_Type Secret::VALUE;
const Secret_Type Secret::Type_MIN;
const Secret_Type Secret::Type_MAX;
const int Secret::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Secret_Reference::kNameFieldNumber;
const int Secret_Reference::kKeyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Secret_Reference::Secret_Reference()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Secret.Reference)
}

void Secret_Reference::InitAsDefaultInstance() {
}

Secret_Reference::Secret_Reference(const Secret_Reference& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Secret.Reference)
}

void Secret_Reference::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret_Reference::~Secret_Reference() {
  // @@protoc_insertion_point(destructor:mesos.Secret.Reference)
  SharedDtor();
}

void Secret_Reference::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Secret_Reference::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Secret_Reference::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_Reference_descriptor_;
}

const Secret_Reference& Secret_Reference::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Secret_Reference* Secret_Reference::default_instance_ = NULL;

Secret_Reference* Secret_Reference::New(::google::protobuf::Arena* arena) const {
  Secret_Reference* n = new Secret_Reference;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Secret_Reference::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Secret.Reference)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Secret_Reference::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Secret.Reference)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Secret.Reference.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Secret.Reference.key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Secret.Reference)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Secret.Reference)
  return false;
#undef DO_
}

void Secret_Reference::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Secret.Reference)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Secret.Reference.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Secret.Reference.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Secret.Reference)
}

::google::protobuf::uint8* Secret_Reference::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Secret.Reference)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Secret.Reference.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string key = 2;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Secret.Reference.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Secret.Reference)
  return target;
}

int Secret_Reference::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Secret.Reference)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional string key = 2;
  if (has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret_Reference::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Secret.Reference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Secret_Reference* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Secret_Reference>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Secret.Reference)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Secret.Reference)
    MergeFrom(*source);
  }
}

void Secret_Reference::MergeFrom(const Secret_Reference& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Secret.Reference)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Secret_Reference::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Secret.Reference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Secret_Reference::CopyFrom(const Secret_Reference& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Secret.Reference)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret_Reference::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Secret_Reference::Swap(Secret_Reference* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Secret_Reference::InternalSwap(Secret_Reference* other) {
  name_.Swap(&other->name_);
  key_.Swap(&other->key_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Secret_Reference::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Secret_Reference_descriptor_;
  metadata.reflection = Secret_Reference_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Secret_Value::kDataFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Secret_Value::Secret_Value()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Secret.Value)
}

void Secret_Value::InitAsDefaultInstance() {
}

Secret_Value::Secret_Value(const Secret_Value& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Secret.Value)
}

void Secret_Value::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  data_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret_Value::~Secret_Value() {
  // @@protoc_insertion_point(destructor:mesos.Secret.Value)
  SharedDtor();
}

void Secret_Value::SharedDtor() {
  data_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Secret_Value::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Secret_Value::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_Value_descriptor_;
}

const Secret_Value& Secret_Value::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Secret_Value* Secret_Value::default_instance_ = NULL;

Secret_Value* Secret_Value::New(::google::protobuf::Arena* arena) const {
  Secret_Value* n = new Secret_Value;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Secret_Value::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Secret.Value)
  if (has_data()) {
    data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Secret_Value::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Secret.Value)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required bytes data = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_data()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Secret.Value)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Secret.Value)
  return false;
#undef DO_
}

void Secret_Value::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Secret.Value)
  // required bytes data = 1;
  if (has_data()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      1, this->data(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Secret.Value)
}

::google::protobuf::uint8* Secret_Value::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Secret.Value)
  // required bytes data = 1;
  if (has_data()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        1, this->data(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Secret.Value)
  return target;
}

int Secret_Value::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Secret.Value)
  int total_size = 0;

  // required bytes data = 1;
  if (has_data()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->data());
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret_Value::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Secret.Value)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Secret_Value* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Secret_Value>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Secret.Value)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Secret.Value)
    MergeFrom(*source);
  }
}

void Secret_Value::MergeFrom(const Secret_Value& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Secret.Value)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_data()) {
      set_has_data();
      data_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.data_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Secret_Value::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Secret.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Secret_Value::CopyFrom(const Secret_Value& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Secret.Value)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret_Value::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Secret_Value::Swap(Secret_Value* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Secret_Value::InternalSwap(Secret_Value* other) {
  data_.Swap(&other->data_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Secret_Value::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Secret_Value_descriptor_;
  metadata.reflection = Secret_Value_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Secret::kTypeFieldNumber;
const int Secret::kReferenceFieldNumber;
const int Secret::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Secret::Secret()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Secret)
}

void Secret::InitAsDefaultInstance() {
  reference_ = const_cast< ::mesos::Secret_Reference*>(&::mesos::Secret_Reference::default_instance());
  value_ = const_cast< ::mesos::Secret_Value*>(&::mesos::Secret_Value::default_instance());
}

Secret::Secret(const Secret& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Secret)
}

void Secret::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  reference_ = NULL;
  value_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Secret::~Secret() {
  // @@protoc_insertion_point(destructor:mesos.Secret)
  SharedDtor();
}

void Secret::SharedDtor() {
  if (this != default_instance_) {
    delete reference_;
    delete value_;
  }
}

void Secret::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Secret::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Secret_descriptor_;
}

const Secret& Secret::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Secret* Secret::default_instance_ = NULL;

Secret* Secret::New(::google::protobuf::Arena* arena) const {
  Secret* n = new Secret;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Secret::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Secret)
  if (_has_bits_[0 / 32] & 7u) {
    type_ = 0;
    if (has_reference()) {
      if (reference_ != NULL) reference_->::mesos::Secret_Reference::Clear();
    }
    if (has_value()) {
      if (value_ != NULL) value_->::mesos::Secret_Value::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Secret::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Secret)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Secret.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Secret_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Secret_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_reference;
        break;
      }

      // optional .mesos.Secret.Reference reference = 2;
      case 2: {
        if (tag == 18) {
         parse_reference:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_reference()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_value;
        break;
      }

      // optional .mesos.Secret.Value value = 3;
      case 3: {
        if (tag == 26) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_value()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Secret)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Secret)
  return false;
#undef DO_
}

void Secret::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Secret)
  // optional .mesos.Secret.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Secret.Reference reference = 2;
  if (has_reference()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->reference_, output);
  }

  // optional .mesos.Secret.Value value = 3;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->value_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Secret)
}

::google::protobuf::uint8* Secret::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Secret)
  // optional .mesos.Secret.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Secret.Reference reference = 2;
  if (has_reference()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->reference_, false, target);
  }

  // optional .mesos.Secret.Value value = 3;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->value_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Secret)
  return target;
}

int Secret::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Secret)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .mesos.Secret.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Secret.Reference reference = 2;
    if (has_reference()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->reference_);
    }

    // optional .mesos.Secret.Value value = 3;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->value_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Secret::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Secret)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Secret* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Secret>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Secret)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Secret)
    MergeFrom(*source);
  }
}

void Secret::MergeFrom(const Secret& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Secret)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_reference()) {
      mutable_reference()->::mesos::Secret_Reference::MergeFrom(from.reference());
    }
    if (from.has_value()) {
      mutable_value()->::mesos::Secret_Value::MergeFrom(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Secret::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Secret)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Secret::CopyFrom(const Secret& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Secret)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Secret::IsInitialized() const {

  if (has_reference()) {
    if (!this->reference_->IsInitialized()) return false;
  }
  if (has_value()) {
    if (!this->value_->IsInitialized()) return false;
  }
  return true;
}

void Secret::Swap(Secret* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Secret::InternalSwap(Secret* other) {
  std::swap(type_, other->type_);
  std::swap(reference_, other->reference_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Secret::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Secret_descriptor_;
  metadata.reflection = Secret_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Secret_Reference

// required string name = 1;
bool Secret_Reference::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Secret_Reference::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Secret_Reference::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Secret_Reference::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Secret_Reference::name() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Reference.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Secret_Reference::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Secret.Reference.name)
}
 void Secret_Reference::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Reference.name)
}
 void Secret_Reference::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Reference.name)
}
 ::std::string* Secret_Reference::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Reference.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Secret_Reference::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Secret.Reference.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Secret_Reference::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Reference.name)
}

// optional string key = 2;
bool Secret_Reference::has_key() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Secret_Reference::set_has_key() {
  _has_bits_[0] |= 0x00000002u;
}
void Secret_Reference::clear_has_key() {
  _has_bits_[0] &= ~0x00000002u;
}
void Secret_Reference::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& Secret_Reference::key() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Reference.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Secret_Reference::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Secret.Reference.key)
}
 void Secret_Reference::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Reference.key)
}
 void Secret_Reference::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Reference.key)
}
 ::std::string* Secret_Reference::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Reference.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Secret_Reference::release_key() {
  // @@protoc_insertion_point(field_release:mesos.Secret.Reference.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Secret_Reference::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Reference.key)
}

// -------------------------------------------------------------------

// Secret_Value

// required bytes data = 1;
bool Secret_Value::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Secret_Value::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
void Secret_Value::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
void Secret_Value::clear_data() {
  data_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_data();
}
 const ::std::string& Secret_Value::data() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.Value.data)
  return data_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Secret_Value::set_data(const ::std::string& value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Secret.Value.data)
}
 void Secret_Value::set_data(const char* value) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Secret.Value.data)
}
 void Secret_Value::set_data(const void* value, size_t size) {
  set_has_data();
  data_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Secret.Value.data)
}
 ::std::string* Secret_Value::mutable_data() {
  set_has_data();
  // @@protoc_insertion_point(field_mutable:mesos.Secret.Value.data)
  return data_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Secret_Value::release_data() {
  // @@protoc_insertion_point(field_release:mesos.Secret.Value.data)
  clear_has_data();
  return data_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Secret_Value::set_allocated_data(::std::string* data) {
  if (data != NULL) {
    set_has_data();
  } else {
    clear_has_data();
  }
  data_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), data);
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.Value.data)
}

// -------------------------------------------------------------------

// Secret

// optional .mesos.Secret.Type type = 1;
bool Secret::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Secret::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Secret::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Secret::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Secret_Type Secret::type() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.type)
  return static_cast< ::mesos::Secret_Type >(type_);
}
 void Secret::set_type(::mesos::Secret_Type value) {
  assert(::mesos::Secret_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Secret.type)
}

// optional .mesos.Secret.Reference reference = 2;
bool Secret::has_reference() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Secret::set_has_reference() {
  _has_bits_[0] |= 0x00000002u;
}
void Secret::clear_has_reference() {
  _has_bits_[0] &= ~0x00000002u;
}
void Secret::clear_reference() {
  if (reference_ != NULL) reference_->::mesos::Secret_Reference::Clear();
  clear_has_reference();
}
const ::mesos::Secret_Reference& Secret::reference() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.reference)
  return reference_ != NULL ? *reference_ : *default_instance_->reference_;
}
::mesos::Secret_Reference* Secret::mutable_reference() {
  set_has_reference();
  if (reference_ == NULL) {
    reference_ = new ::mesos::Secret_Reference;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.reference)
  return reference_;
}
::mesos::Secret_Reference* Secret::release_reference() {
  // @@protoc_insertion_point(field_release:mesos.Secret.reference)
  clear_has_reference();
  ::mesos::Secret_Reference* temp = reference_;
  reference_ = NULL;
  return temp;
}
void Secret::set_allocated_reference(::mesos::Secret_Reference* reference) {
  delete reference_;
  reference_ = reference;
  if (reference) {
    set_has_reference();
  } else {
    clear_has_reference();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.reference)
}

// optional .mesos.Secret.Value value = 3;
bool Secret::has_value() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Secret::set_has_value() {
  _has_bits_[0] |= 0x00000004u;
}
void Secret::clear_has_value() {
  _has_bits_[0] &= ~0x00000004u;
}
void Secret::clear_value() {
  if (value_ != NULL) value_->::mesos::Secret_Value::Clear();
  clear_has_value();
}
const ::mesos::Secret_Value& Secret::value() const {
  // @@protoc_insertion_point(field_get:mesos.Secret.value)
  return value_ != NULL ? *value_ : *default_instance_->value_;
}
::mesos::Secret_Value* Secret::mutable_value() {
  set_has_value();
  if (value_ == NULL) {
    value_ = new ::mesos::Secret_Value;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Secret.value)
  return value_;
}
::mesos::Secret_Value* Secret::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Secret.value)
  clear_has_value();
  ::mesos::Secret_Value* temp = value_;
  value_ = NULL;
  return temp;
}
void Secret::set_allocated_value(::mesos::Secret_Value* value) {
  delete value_;
  value_ = value;
  if (value) {
    set_has_value();
  } else {
    clear_has_value();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Secret.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RateLimit::kQpsFieldNumber;
const int RateLimit::kPrincipalFieldNumber;
const int RateLimit::kCapacityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RateLimit::RateLimit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RateLimit)
}

void RateLimit::InitAsDefaultInstance() {
}

RateLimit::RateLimit(const RateLimit& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RateLimit)
}

void RateLimit::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  qps_ = 0;
  principal_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  capacity_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RateLimit::~RateLimit() {
  // @@protoc_insertion_point(destructor:mesos.RateLimit)
  SharedDtor();
}

void RateLimit::SharedDtor() {
  principal_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void RateLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RateLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RateLimit_descriptor_;
}

const RateLimit& RateLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RateLimit* RateLimit::default_instance_ = NULL;

RateLimit* RateLimit::New(::google::protobuf::Arena* arena) const {
  RateLimit* n = new RateLimit;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RateLimit::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.RateLimit)
  if (_has_bits_[0 / 32] & 7u) {
    qps_ = 0;
    if (has_principal()) {
      principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    capacity_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RateLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RateLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional double qps = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &qps_)));
          set_has_qps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_principal;
        break;
      }

      // required string principal = 2;
      case 2: {
        if (tag == 18) {
         parse_principal:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_principal()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->principal().data(), this->principal().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.RateLimit.principal");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_capacity;
        break;
      }

      // optional uint64 capacity = 3;
      case 3: {
        if (tag == 24) {
         parse_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &capacity_)));
          set_has_capacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RateLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RateLimit)
  return false;
#undef DO_
}

void RateLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RateLimit)
  // optional double qps = 1;
  if (has_qps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->qps(), output);
  }

  // required string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.RateLimit.principal");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->principal(), output);
  }

  // optional uint64 capacity = 3;
  if (has_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->capacity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RateLimit)
}

::google::protobuf::uint8* RateLimit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RateLimit)
  // optional double qps = 1;
  if (has_qps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->qps(), target);
  }

  // required string principal = 2;
  if (has_principal()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->principal().data(), this->principal().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.RateLimit.principal");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->principal(), target);
  }

  // optional uint64 capacity = 3;
  if (has_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->capacity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RateLimit)
  return target;
}

int RateLimit::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.RateLimit)
  int total_size = 0;

  // required string principal = 2;
  if (has_principal()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->principal());
  }
  if (_has_bits_[0 / 32] & 5u) {
    // optional double qps = 1;
    if (has_qps()) {
      total_size += 1 + 8;
    }

    // optional uint64 capacity = 3;
    if (has_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->capacity());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RateLimit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.RateLimit)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RateLimit* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RateLimit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.RateLimit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.RateLimit)
    MergeFrom(*source);
  }
}

void RateLimit::MergeFrom(const RateLimit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.RateLimit)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_qps()) {
      set_qps(from.qps());
    }
    if (from.has_principal()) {
      set_has_principal();
      principal_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.principal_);
    }
    if (from.has_capacity()) {
      set_capacity(from.capacity());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RateLimit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.RateLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RateLimit::CopyFrom(const RateLimit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.RateLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RateLimit::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void RateLimit::Swap(RateLimit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RateLimit::InternalSwap(RateLimit* other) {
  std::swap(qps_, other->qps_);
  principal_.Swap(&other->principal_);
  std::swap(capacity_, other->capacity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RateLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RateLimit_descriptor_;
  metadata.reflection = RateLimit_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RateLimit

// optional double qps = 1;
bool RateLimit::has_qps() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RateLimit::set_has_qps() {
  _has_bits_[0] |= 0x00000001u;
}
void RateLimit::clear_has_qps() {
  _has_bits_[0] &= ~0x00000001u;
}
void RateLimit::clear_qps() {
  qps_ = 0;
  clear_has_qps();
}
 double RateLimit::qps() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.qps)
  return qps_;
}
 void RateLimit::set_qps(double value) {
  set_has_qps();
  qps_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimit.qps)
}

// required string principal = 2;
bool RateLimit::has_principal() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RateLimit::set_has_principal() {
  _has_bits_[0] |= 0x00000002u;
}
void RateLimit::clear_has_principal() {
  _has_bits_[0] &= ~0x00000002u;
}
void RateLimit::clear_principal() {
  principal_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_principal();
}
 const ::std::string& RateLimit::principal() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.principal)
  return principal_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RateLimit::set_principal(const ::std::string& value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.RateLimit.principal)
}
 void RateLimit::set_principal(const char* value) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.RateLimit.principal)
}
 void RateLimit::set_principal(const char* value, size_t size) {
  set_has_principal();
  principal_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.RateLimit.principal)
}
 ::std::string* RateLimit::mutable_principal() {
  set_has_principal();
  // @@protoc_insertion_point(field_mutable:mesos.RateLimit.principal)
  return principal_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* RateLimit::release_principal() {
  // @@protoc_insertion_point(field_release:mesos.RateLimit.principal)
  clear_has_principal();
  return principal_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void RateLimit::set_allocated_principal(::std::string* principal) {
  if (principal != NULL) {
    set_has_principal();
  } else {
    clear_has_principal();
  }
  principal_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), principal);
  // @@protoc_insertion_point(field_set_allocated:mesos.RateLimit.principal)
}

// optional uint64 capacity = 3;
bool RateLimit::has_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RateLimit::set_has_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
void RateLimit::clear_has_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
void RateLimit::clear_capacity() {
  capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_capacity();
}
 ::google::protobuf::uint64 RateLimit::capacity() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimit.capacity)
  return capacity_;
}
 void RateLimit::set_capacity(::google::protobuf::uint64 value) {
  set_has_capacity();
  capacity_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimit.capacity)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RateLimits::kLimitsFieldNumber;
const int RateLimits::kAggregateDefaultQpsFieldNumber;
const int RateLimits::kAggregateDefaultCapacityFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RateLimits::RateLimits()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RateLimits)
}

void RateLimits::InitAsDefaultInstance() {
}

RateLimits::RateLimits(const RateLimits& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RateLimits)
}

void RateLimits::SharedCtor() {
  _cached_size_ = 0;
  aggregate_default_qps_ = 0;
  aggregate_default_capacity_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RateLimits::~RateLimits() {
  // @@protoc_insertion_point(destructor:mesos.RateLimits)
  SharedDtor();
}

void RateLimits::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RateLimits::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RateLimits::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RateLimits_descriptor_;
}

const RateLimits& RateLimits::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RateLimits* RateLimits::default_instance_ = NULL;

RateLimits* RateLimits::New(::google::protobuf::Arena* arena) const {
  RateLimits* n = new RateLimits;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RateLimits::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.RateLimits)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RateLimits, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RateLimits*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(aggregate_default_qps_, aggregate_default_capacity_);

#undef ZR_HELPER_
#undef ZR_

  limits_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RateLimits::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RateLimits)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.RateLimit limits = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_limits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_limits()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_limits;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(17)) goto parse_aggregate_default_qps;
        break;
      }

      // optional double aggregate_default_qps = 2;
      case 2: {
        if (tag == 17) {
         parse_aggregate_default_qps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &aggregate_default_qps_)));
          set_has_aggregate_default_qps();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_aggregate_default_capacity;
        break;
      }

      // optional uint64 aggregate_default_capacity = 3;
      case 3: {
        if (tag == 24) {
         parse_aggregate_default_capacity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &aggregate_default_capacity_)));
          set_has_aggregate_default_capacity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RateLimits)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RateLimits)
  return false;
#undef DO_
}

void RateLimits::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RateLimits)
  // repeated .mesos.RateLimit limits = 1;
  for (unsigned int i = 0, n = this->limits_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->limits(i), output);
  }

  // optional double aggregate_default_qps = 2;
  if (has_aggregate_default_qps()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->aggregate_default_qps(), output);
  }

  // optional uint64 aggregate_default_capacity = 3;
  if (has_aggregate_default_capacity()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->aggregate_default_capacity(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RateLimits)
}

::google::protobuf::uint8* RateLimits::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RateLimits)
  // repeated .mesos.RateLimit limits = 1;
  for (unsigned int i = 0, n = this->limits_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->limits(i), false, target);
  }

  // optional double aggregate_default_qps = 2;
  if (has_aggregate_default_qps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->aggregate_default_qps(), target);
  }

  // optional uint64 aggregate_default_capacity = 3;
  if (has_aggregate_default_capacity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->aggregate_default_capacity(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RateLimits)
  return target;
}

int RateLimits::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.RateLimits)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 6u) {
    // optional double aggregate_default_qps = 2;
    if (has_aggregate_default_qps()) {
      total_size += 1 + 8;
    }

    // optional uint64 aggregate_default_capacity = 3;
    if (has_aggregate_default_capacity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->aggregate_default_capacity());
    }

  }
  // repeated .mesos.RateLimit limits = 1;
  total_size += 1 * this->limits_size();
  for (int i = 0; i < this->limits_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->limits(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RateLimits::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.RateLimits)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RateLimits* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RateLimits>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.RateLimits)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.RateLimits)
    MergeFrom(*source);
  }
}

void RateLimits::MergeFrom(const RateLimits& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.RateLimits)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  limits_.MergeFrom(from.limits_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_aggregate_default_qps()) {
      set_aggregate_default_qps(from.aggregate_default_qps());
    }
    if (from.has_aggregate_default_capacity()) {
      set_aggregate_default_capacity(from.aggregate_default_capacity());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RateLimits::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.RateLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RateLimits::CopyFrom(const RateLimits& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.RateLimits)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RateLimits::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->limits())) return false;
  return true;
}

void RateLimits::Swap(RateLimits* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RateLimits::InternalSwap(RateLimits* other) {
  limits_.UnsafeArenaSwap(&other->limits_);
  std::swap(aggregate_default_qps_, other->aggregate_default_qps_);
  std::swap(aggregate_default_capacity_, other->aggregate_default_capacity_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RateLimits::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RateLimits_descriptor_;
  metadata.reflection = RateLimits_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RateLimits

// repeated .mesos.RateLimit limits = 1;
int RateLimits::limits_size() const {
  return limits_.size();
}
void RateLimits::clear_limits() {
  limits_.Clear();
}
const ::mesos::RateLimit& RateLimits::limits(int index) const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.limits)
  return limits_.Get(index);
}
::mesos::RateLimit* RateLimits::mutable_limits(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.RateLimits.limits)
  return limits_.Mutable(index);
}
::mesos::RateLimit* RateLimits::add_limits() {
  // @@protoc_insertion_point(field_add:mesos.RateLimits.limits)
  return limits_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >*
RateLimits::mutable_limits() {
  // @@protoc_insertion_point(field_mutable_list:mesos.RateLimits.limits)
  return &limits_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::RateLimit >&
RateLimits::limits() const {
  // @@protoc_insertion_point(field_list:mesos.RateLimits.limits)
  return limits_;
}

// optional double aggregate_default_qps = 2;
bool RateLimits::has_aggregate_default_qps() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RateLimits::set_has_aggregate_default_qps() {
  _has_bits_[0] |= 0x00000002u;
}
void RateLimits::clear_has_aggregate_default_qps() {
  _has_bits_[0] &= ~0x00000002u;
}
void RateLimits::clear_aggregate_default_qps() {
  aggregate_default_qps_ = 0;
  clear_has_aggregate_default_qps();
}
 double RateLimits::aggregate_default_qps() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.aggregate_default_qps)
  return aggregate_default_qps_;
}
 void RateLimits::set_aggregate_default_qps(double value) {
  set_has_aggregate_default_qps();
  aggregate_default_qps_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimits.aggregate_default_qps)
}

// optional uint64 aggregate_default_capacity = 3;
bool RateLimits::has_aggregate_default_capacity() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RateLimits::set_has_aggregate_default_capacity() {
  _has_bits_[0] |= 0x00000004u;
}
void RateLimits::clear_has_aggregate_default_capacity() {
  _has_bits_[0] &= ~0x00000004u;
}
void RateLimits::clear_aggregate_default_capacity() {
  aggregate_default_capacity_ = GOOGLE_ULONGLONG(0);
  clear_has_aggregate_default_capacity();
}
 ::google::protobuf::uint64 RateLimits::aggregate_default_capacity() const {
  // @@protoc_insertion_point(field_get:mesos.RateLimits.aggregate_default_capacity)
  return aggregate_default_capacity_;
}
 void RateLimits::set_aggregate_default_capacity(::google::protobuf::uint64 value) {
  set_has_aggregate_default_capacity();
  aggregate_default_capacity_ = value;
  // @@protoc_insertion_point(field_set:mesos.RateLimits.aggregate_default_capacity)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Image_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Type_descriptor_;
}
bool Image_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Image_Type Image::APPC;
const Image_Type Image::DOCKER;
const Image_Type Image::Type_MIN;
const Image_Type Image::Type_MAX;
const int Image::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image_Appc::kNameFieldNumber;
const int Image_Appc::kIdFieldNumber;
const int Image_Appc::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image_Appc::Image_Appc()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Image.Appc)
}

void Image_Appc::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

Image_Appc::Image_Appc(const Image_Appc& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Image.Appc)
}

void Image_Appc::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image_Appc::~Image_Appc() {
  // @@protoc_insertion_point(destructor:mesos.Image.Appc)
  SharedDtor();
}

void Image_Appc::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete labels_;
  }
}

void Image_Appc::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image_Appc::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Appc_descriptor_;
}

const Image_Appc& Image_Appc::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Image_Appc* Image_Appc::default_instance_ = NULL;

Image_Appc* Image_Appc::New(::google::protobuf::Arena* arena) const {
  Image_Appc* n = new Image_Appc;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image_Appc::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Image.Appc)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_id()) {
      id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Image_Appc::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Image.Appc)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Image.Appc.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_id;
        break;
      }

      // optional string id = 2;
      case 2: {
        if (tag == 18) {
         parse_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->id().data(), this->id().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Image.Appc.id");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 3;
      case 3: {
        if (tag == 26) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Image.Appc)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Image.Appc)
  return false;
#undef DO_
}

void Image_Appc::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Image.Appc)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Image.Appc.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Image.Appc.id");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->id(), output);
  }

  // optional .mesos.Labels labels = 3;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->labels_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Image.Appc)
}

::google::protobuf::uint8* Image_Appc::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Image.Appc)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Image.Appc.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string id = 2;
  if (has_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->id().data(), this->id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Image.Appc.id");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->id(), target);
  }

  // optional .mesos.Labels labels = 3;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->labels_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Image.Appc)
  return target;
}

int Image_Appc::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Image.Appc)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  if (_has_bits_[1 / 32] & 6u) {
    // optional string id = 2;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->id());
    }

    // optional .mesos.Labels labels = 3;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image_Appc::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Image.Appc)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Image_Appc* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Image_Appc>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Image.Appc)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Image.Appc)
    MergeFrom(*source);
  }
}

void Image_Appc::MergeFrom(const Image_Appc& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Image.Appc)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_id()) {
      set_has_id();
      id_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.id_);
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Image_Appc::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Image.Appc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image_Appc::CopyFrom(const Image_Appc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Image.Appc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image_Appc::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void Image_Appc::Swap(Image_Appc* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image_Appc::InternalSwap(Image_Appc* other) {
  name_.Swap(&other->name_);
  id_.Swap(&other->id_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Image_Appc::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_Appc_descriptor_;
  metadata.reflection = Image_Appc_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image_Docker::kNameFieldNumber;
const int Image_Docker::kCredentialFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image_Docker::Image_Docker()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Image.Docker)
}

void Image_Docker::InitAsDefaultInstance() {
  credential_ = const_cast< ::mesos::Credential*>(&::mesos::Credential::default_instance());
}

Image_Docker::Image_Docker(const Image_Docker& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Image.Docker)
}

void Image_Docker::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  credential_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image_Docker::~Image_Docker() {
  // @@protoc_insertion_point(destructor:mesos.Image.Docker)
  SharedDtor();
}

void Image_Docker::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete credential_;
  }
}

void Image_Docker::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image_Docker::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_Docker_descriptor_;
}

const Image_Docker& Image_Docker::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Image_Docker* Image_Docker::default_instance_ = NULL;

Image_Docker* Image_Docker::New(::google::protobuf::Arena* arena) const {
  Image_Docker* n = new Image_Docker;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image_Docker::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Image.Docker)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_credential()) {
      if (credential_ != NULL) credential_->::mesos::Credential::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Image_Docker::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Image.Docker)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Image.Docker.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_credential;
        break;
      }

      // optional .mesos.Credential credential = 2;
      case 2: {
        if (tag == 18) {
         parse_credential:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_credential()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Image.Docker)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Image.Docker)
  return false;
#undef DO_
}

void Image_Docker::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Image.Docker)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Image.Docker.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional .mesos.Credential credential = 2;
  if (has_credential()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->credential_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Image.Docker)
}

::google::protobuf::uint8* Image_Docker::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Image.Docker)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Image.Docker.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional .mesos.Credential credential = 2;
  if (has_credential()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->credential_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Image.Docker)
  return target;
}

int Image_Docker::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Image.Docker)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional .mesos.Credential credential = 2;
  if (has_credential()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->credential_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image_Docker::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Image.Docker)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Image_Docker* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Image_Docker>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Image.Docker)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Image.Docker)
    MergeFrom(*source);
  }
}

void Image_Docker::MergeFrom(const Image_Docker& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Image.Docker)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_credential()) {
      mutable_credential()->::mesos::Credential::MergeFrom(from.credential());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Image_Docker::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Image.Docker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image_Docker::CopyFrom(const Image_Docker& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Image.Docker)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image_Docker::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_credential()) {
    if (!this->credential_->IsInitialized()) return false;
  }
  return true;
}

void Image_Docker::Swap(Image_Docker* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image_Docker::InternalSwap(Image_Docker* other) {
  name_.Swap(&other->name_);
  std::swap(credential_, other->credential_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Image_Docker::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_Docker_descriptor_;
  metadata.reflection = Image_Docker_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Image::kTypeFieldNumber;
const int Image::kAppcFieldNumber;
const int Image::kDockerFieldNumber;
const int Image::kCachedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Image::Image()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Image)
}

void Image::InitAsDefaultInstance() {
  appc_ = const_cast< ::mesos::Image_Appc*>(&::mesos::Image_Appc::default_instance());
  docker_ = const_cast< ::mesos::Image_Docker*>(&::mesos::Image_Docker::default_instance());
}

Image::Image(const Image& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Image)
}

void Image::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  appc_ = NULL;
  docker_ = NULL;
  cached_ = true;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Image::~Image() {
  // @@protoc_insertion_point(destructor:mesos.Image)
  SharedDtor();
}

void Image::SharedDtor() {
  if (this != default_instance_) {
    delete appc_;
    delete docker_;
  }
}

void Image::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Image::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Image_descriptor_;
}

const Image& Image::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Image* Image::default_instance_ = NULL;

Image* Image::New(::google::protobuf::Arena* arena) const {
  Image* n = new Image;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Image::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Image)
  if (_has_bits_[0 / 32] & 15u) {
    type_ = 1;
    if (has_appc()) {
      if (appc_ != NULL) appc_->::mesos::Image_Appc::Clear();
    }
    if (has_docker()) {
      if (docker_ != NULL) docker_->::mesos::Image_Docker::Clear();
    }
    cached_ = true;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Image::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Image)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.Image.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Image_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Image_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_appc;
        break;
      }

      // optional .mesos.Image.Appc appc = 2;
      case 2: {
        if (tag == 18) {
         parse_appc:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_appc()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_docker;
        break;
      }

      // optional .mesos.Image.Docker docker = 3;
      case 3: {
        if (tag == 26) {
         parse_docker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_cached;
        break;
      }

      // optional bool cached = 4 [default = true];
      case 4: {
        if (tag == 32) {
         parse_cached:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &cached_)));
          set_has_cached();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Image)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Image)
  return false;
#undef DO_
}

void Image::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Image)
  // required .mesos.Image.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Image.Appc appc = 2;
  if (has_appc()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->appc_, output);
  }

  // optional .mesos.Image.Docker docker = 3;
  if (has_docker()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->docker_, output);
  }

  // optional bool cached = 4 [default = true];
  if (has_cached()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->cached(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Image)
}

::google::protobuf::uint8* Image::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Image)
  // required .mesos.Image.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Image.Appc appc = 2;
  if (has_appc()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->appc_, false, target);
  }

  // optional .mesos.Image.Docker docker = 3;
  if (has_docker()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->docker_, false, target);
  }

  // optional bool cached = 4 [default = true];
  if (has_cached()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->cached(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Image)
  return target;
}

int Image::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Image)
  int total_size = 0;

  // required .mesos.Image.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  if (_has_bits_[1 / 32] & 14u) {
    // optional .mesos.Image.Appc appc = 2;
    if (has_appc()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->appc_);
    }

    // optional .mesos.Image.Docker docker = 3;
    if (has_docker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->docker_);
    }

    // optional bool cached = 4 [default = true];
    if (has_cached()) {
      total_size += 1 + 1;
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Image::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Image* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Image>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Image)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Image)
    MergeFrom(*source);
  }
}

void Image::MergeFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Image)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_appc()) {
      mutable_appc()->::mesos::Image_Appc::MergeFrom(from.appc());
    }
    if (from.has_docker()) {
      mutable_docker()->::mesos::Image_Docker::MergeFrom(from.docker());
    }
    if (from.has_cached()) {
      set_cached(from.cached());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Image::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Image::CopyFrom(const Image& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Image)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Image::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_appc()) {
    if (!this->appc_->IsInitialized()) return false;
  }
  if (has_docker()) {
    if (!this->docker_->IsInitialized()) return false;
  }
  return true;
}

void Image::Swap(Image* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Image::InternalSwap(Image* other) {
  std::swap(type_, other->type_);
  std::swap(appc_, other->appc_);
  std::swap(docker_, other->docker_);
  std::swap(cached_, other->cached_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Image::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Image_descriptor_;
  metadata.reflection = Image_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Image_Appc

// required string name = 1;
bool Image_Appc::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Image_Appc::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Image_Appc::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Image_Appc::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Image_Appc::name() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image_Appc::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Image.Appc.name)
}
 void Image_Appc::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Image.Appc.name)
}
 void Image_Appc::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Appc.name)
}
 ::std::string* Image_Appc::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image_Appc::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Image.Appc.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image_Appc::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.name)
}

// optional string id = 2;
bool Image_Appc::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Image_Appc::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
void Image_Appc::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
void Image_Appc::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_id();
}
 const ::std::string& Image_Appc::id() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.id)
  return id_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image_Appc::set_id(const ::std::string& value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Image.Appc.id)
}
 void Image_Appc::set_id(const char* value) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Image.Appc.id)
}
 void Image_Appc::set_id(const char* value, size_t size) {
  set_has_id();
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Appc.id)
}
 ::std::string* Image_Appc::mutable_id() {
  set_has_id();
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image_Appc::release_id() {
  // @@protoc_insertion_point(field_release:mesos.Image.Appc.id)
  clear_has_id();
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image_Appc::set_allocated_id(::std::string* id) {
  if (id != NULL) {
    set_has_id();
  } else {
    clear_has_id();
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.id)
}

// optional .mesos.Labels labels = 3;
bool Image_Appc::has_labels() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Image_Appc::set_has_labels() {
  _has_bits_[0] |= 0x00000004u;
}
void Image_Appc::clear_has_labels() {
  _has_bits_[0] &= ~0x00000004u;
}
void Image_Appc::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& Image_Appc::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Appc.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* Image_Appc::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Appc.labels)
  return labels_;
}
::mesos::Labels* Image_Appc::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Image.Appc.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void Image_Appc::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Appc.labels)
}

// -------------------------------------------------------------------

// Image_Docker

// required string name = 1;
bool Image_Docker::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Image_Docker::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Image_Docker::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Image_Docker::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Image_Docker::name() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image_Docker::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Image.Docker.name)
}
 void Image_Docker::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Image.Docker.name)
}
 void Image_Docker::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Image.Docker.name)
}
 ::std::string* Image_Docker::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Image_Docker::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Image.Docker.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Image_Docker::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.name)
}

// optional .mesos.Credential credential = 2;
bool Image_Docker::has_credential() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Image_Docker::set_has_credential() {
  _has_bits_[0] |= 0x00000002u;
}
void Image_Docker::clear_has_credential() {
  _has_bits_[0] &= ~0x00000002u;
}
void Image_Docker::clear_credential() {
  if (credential_ != NULL) credential_->::mesos::Credential::Clear();
  clear_has_credential();
}
const ::mesos::Credential& Image_Docker::credential() const {
  // @@protoc_insertion_point(field_get:mesos.Image.Docker.credential)
  return credential_ != NULL ? *credential_ : *default_instance_->credential_;
}
::mesos::Credential* Image_Docker::mutable_credential() {
  set_has_credential();
  if (credential_ == NULL) {
    credential_ = new ::mesos::Credential;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.Docker.credential)
  return credential_;
}
::mesos::Credential* Image_Docker::release_credential() {
  // @@protoc_insertion_point(field_release:mesos.Image.Docker.credential)
  clear_has_credential();
  ::mesos::Credential* temp = credential_;
  credential_ = NULL;
  return temp;
}
void Image_Docker::set_allocated_credential(::mesos::Credential* credential) {
  delete credential_;
  credential_ = credential;
  if (credential) {
    set_has_credential();
  } else {
    clear_has_credential();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.Docker.credential)
}

// -------------------------------------------------------------------

// Image

// required .mesos.Image.Type type = 1;
bool Image::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Image::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Image::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Image::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::mesos::Image_Type Image::type() const {
  // @@protoc_insertion_point(field_get:mesos.Image.type)
  return static_cast< ::mesos::Image_Type >(type_);
}
 void Image::set_type(::mesos::Image_Type value) {
  assert(::mesos::Image_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Image.type)
}

// optional .mesos.Image.Appc appc = 2;
bool Image::has_appc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Image::set_has_appc() {
  _has_bits_[0] |= 0x00000002u;
}
void Image::clear_has_appc() {
  _has_bits_[0] &= ~0x00000002u;
}
void Image::clear_appc() {
  if (appc_ != NULL) appc_->::mesos::Image_Appc::Clear();
  clear_has_appc();
}
const ::mesos::Image_Appc& Image::appc() const {
  // @@protoc_insertion_point(field_get:mesos.Image.appc)
  return appc_ != NULL ? *appc_ : *default_instance_->appc_;
}
::mesos::Image_Appc* Image::mutable_appc() {
  set_has_appc();
  if (appc_ == NULL) {
    appc_ = new ::mesos::Image_Appc;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.appc)
  return appc_;
}
::mesos::Image_Appc* Image::release_appc() {
  // @@protoc_insertion_point(field_release:mesos.Image.appc)
  clear_has_appc();
  ::mesos::Image_Appc* temp = appc_;
  appc_ = NULL;
  return temp;
}
void Image::set_allocated_appc(::mesos::Image_Appc* appc) {
  delete appc_;
  appc_ = appc;
  if (appc) {
    set_has_appc();
  } else {
    clear_has_appc();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.appc)
}

// optional .mesos.Image.Docker docker = 3;
bool Image::has_docker() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Image::set_has_docker() {
  _has_bits_[0] |= 0x00000004u;
}
void Image::clear_has_docker() {
  _has_bits_[0] &= ~0x00000004u;
}
void Image::clear_docker() {
  if (docker_ != NULL) docker_->::mesos::Image_Docker::Clear();
  clear_has_docker();
}
const ::mesos::Image_Docker& Image::docker() const {
  // @@protoc_insertion_point(field_get:mesos.Image.docker)
  return docker_ != NULL ? *docker_ : *default_instance_->docker_;
}
::mesos::Image_Docker* Image::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) {
    docker_ = new ::mesos::Image_Docker;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Image.docker)
  return docker_;
}
::mesos::Image_Docker* Image::release_docker() {
  // @@protoc_insertion_point(field_release:mesos.Image.docker)
  clear_has_docker();
  ::mesos::Image_Docker* temp = docker_;
  docker_ = NULL;
  return temp;
}
void Image::set_allocated_docker(::mesos::Image_Docker* docker) {
  delete docker_;
  docker_ = docker;
  if (docker) {
    set_has_docker();
  } else {
    clear_has_docker();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Image.docker)
}

// optional bool cached = 4 [default = true];
bool Image::has_cached() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Image::set_has_cached() {
  _has_bits_[0] |= 0x00000008u;
}
void Image::clear_has_cached() {
  _has_bits_[0] &= ~0x00000008u;
}
void Image::clear_cached() {
  cached_ = true;
  clear_has_cached();
}
 bool Image::cached() const {
  // @@protoc_insertion_point(field_get:mesos.Image.cached)
  return cached_;
}
 void Image::set_cached(bool value) {
  set_has_cached();
  cached_ = value;
  // @@protoc_insertion_point(field_set:mesos.Image.cached)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* Volume_Mode_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Mode_descriptor_;
}
bool Volume_Mode_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Volume_Mode Volume::RW;
const Volume_Mode Volume::RO;
const Volume_Mode Volume::Mode_MIN;
const Volume_Mode Volume::Mode_MAX;
const int Volume::Mode_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* Volume_Source_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_Type_descriptor_;
}
bool Volume_Source_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Volume_Source_Type Volume_Source::UNKNOWN;
const Volume_Source_Type Volume_Source::DOCKER_VOLUME;
const Volume_Source_Type Volume_Source::SANDBOX_PATH;
const Volume_Source_Type Volume_Source::Type_MIN;
const Volume_Source_Type Volume_Source::Type_MAX;
const int Volume_Source::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Volume_Source_DockerVolume::kDriverFieldNumber;
const int Volume_Source_DockerVolume::kNameFieldNumber;
const int Volume_Source_DockerVolume::kDriverOptionsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Volume_Source_DockerVolume::Volume_Source_DockerVolume()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume.Source.DockerVolume)
}

void Volume_Source_DockerVolume::InitAsDefaultInstance() {
  driver_options_ = const_cast< ::mesos::Parameters*>(&::mesos::Parameters::default_instance());
}

Volume_Source_DockerVolume::Volume_Source_DockerVolume(const Volume_Source_DockerVolume& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume.Source.DockerVolume)
}

void Volume_Source_DockerVolume::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  driver_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  driver_options_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume_Source_DockerVolume::~Volume_Source_DockerVolume() {
  // @@protoc_insertion_point(destructor:mesos.Volume.Source.DockerVolume)
  SharedDtor();
}

void Volume_Source_DockerVolume::SharedDtor() {
  driver_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete driver_options_;
  }
}

void Volume_Source_DockerVolume::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume_Source_DockerVolume::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_DockerVolume_descriptor_;
}

const Volume_Source_DockerVolume& Volume_Source_DockerVolume::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume_Source_DockerVolume* Volume_Source_DockerVolume::default_instance_ = NULL;

Volume_Source_DockerVolume* Volume_Source_DockerVolume::New(::google::protobuf::Arena* arena) const {
  Volume_Source_DockerVolume* n = new Volume_Source_DockerVolume;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Volume_Source_DockerVolume::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Volume.Source.DockerVolume)
  if (_has_bits_[0 / 32] & 7u) {
    if (has_driver()) {
      driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_driver_options()) {
      if (driver_options_ != NULL) driver_options_->::mesos::Parameters::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Volume_Source_DockerVolume::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume.Source.DockerVolume)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string driver = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_driver()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->driver().data(), this->driver().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Volume.Source.DockerVolume.driver");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // required string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Volume.Source.DockerVolume.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_driver_options;
        break;
      }

      // optional .mesos.Parameters driver_options = 3;
      case 3: {
        if (tag == 26) {
         parse_driver_options:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_driver_options()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume.Source.DockerVolume)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume.Source.DockerVolume)
  return false;
#undef DO_
}

void Volume_Source_DockerVolume::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume.Source.DockerVolume)
  // optional string driver = 1;
  if (has_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->driver().data(), this->driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.Source.DockerVolume.driver");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->driver(), output);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.Source.DockerVolume.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional .mesos.Parameters driver_options = 3;
  if (has_driver_options()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->driver_options_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume.Source.DockerVolume)
}

::google::protobuf::uint8* Volume_Source_DockerVolume::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume.Source.DockerVolume)
  // optional string driver = 1;
  if (has_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->driver().data(), this->driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.Source.DockerVolume.driver");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->driver(), target);
  }

  // required string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.Source.DockerVolume.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional .mesos.Parameters driver_options = 3;
  if (has_driver_options()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->driver_options_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume.Source.DockerVolume)
  return target;
}

int Volume_Source_DockerVolume::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Volume.Source.DockerVolume)
  int total_size = 0;

  // required string name = 2;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  if (_has_bits_[0 / 32] & 5u) {
    // optional string driver = 1;
    if (has_driver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->driver());
    }

    // optional .mesos.Parameters driver_options = 3;
    if (has_driver_options()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->driver_options_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume_Source_DockerVolume::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Volume.Source.DockerVolume)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Volume_Source_DockerVolume* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Volume_Source_DockerVolume>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Volume.Source.DockerVolume)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Volume.Source.DockerVolume)
    MergeFrom(*source);
  }
}

void Volume_Source_DockerVolume::MergeFrom(const Volume_Source_DockerVolume& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Volume.Source.DockerVolume)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_driver()) {
      set_has_driver();
      driver_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.driver_);
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_driver_options()) {
      mutable_driver_options()->::mesos::Parameters::MergeFrom(from.driver_options());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Volume_Source_DockerVolume::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Volume.Source.DockerVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume_Source_DockerVolume::CopyFrom(const Volume_Source_DockerVolume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Volume.Source.DockerVolume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume_Source_DockerVolume::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  if (has_driver_options()) {
    if (!this->driver_options_->IsInitialized()) return false;
  }
  return true;
}

void Volume_Source_DockerVolume::Swap(Volume_Source_DockerVolume* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Volume_Source_DockerVolume::InternalSwap(Volume_Source_DockerVolume* other) {
  driver_.Swap(&other->driver_);
  name_.Swap(&other->name_);
  std::swap(driver_options_, other->driver_options_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Volume_Source_DockerVolume::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_Source_DockerVolume_descriptor_;
  metadata.reflection = Volume_Source_DockerVolume_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

const ::google::protobuf::EnumDescriptor* Volume_Source_SandboxPath_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_SandboxPath_Type_descriptor_;
}
bool Volume_Source_SandboxPath_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::UNKNOWN;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::SELF;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::PARENT;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::Type_MIN;
const Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::Type_MAX;
const int Volume_Source_SandboxPath::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Volume_Source_SandboxPath::kTypeFieldNumber;
const int Volume_Source_SandboxPath::kPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Volume_Source_SandboxPath::Volume_Source_SandboxPath()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume.Source.SandboxPath)
}

void Volume_Source_SandboxPath::InitAsDefaultInstance() {
}

Volume_Source_SandboxPath::Volume_Source_SandboxPath(const Volume_Source_SandboxPath& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume.Source.SandboxPath)
}

void Volume_Source_SandboxPath::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume_Source_SandboxPath::~Volume_Source_SandboxPath() {
  // @@protoc_insertion_point(destructor:mesos.Volume.Source.SandboxPath)
  SharedDtor();
}

void Volume_Source_SandboxPath::SharedDtor() {
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Volume_Source_SandboxPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume_Source_SandboxPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_SandboxPath_descriptor_;
}

const Volume_Source_SandboxPath& Volume_Source_SandboxPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume_Source_SandboxPath* Volume_Source_SandboxPath::default_instance_ = NULL;

Volume_Source_SandboxPath* Volume_Source_SandboxPath::New(::google::protobuf::Arena* arena) const {
  Volume_Source_SandboxPath* n = new Volume_Source_SandboxPath;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Volume_Source_SandboxPath::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Volume.Source.SandboxPath)
  if (_has_bits_[0 / 32] & 3u) {
    type_ = 0;
    if (has_path()) {
      path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Volume_Source_SandboxPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume.Source.SandboxPath)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Volume_Source_SandboxPath_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Volume_Source_SandboxPath_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_path;
        break;
      }

      // required string path = 2;
      case 2: {
        if (tag == 18) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Volume.Source.SandboxPath.path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume.Source.SandboxPath)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume.Source.SandboxPath)
  return false;
#undef DO_
}

void Volume_Source_SandboxPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume.Source.SandboxPath)
  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.Source.SandboxPath.path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->path(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume.Source.SandboxPath)
}

::google::protobuf::uint8* Volume_Source_SandboxPath::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume.Source.SandboxPath)
  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required string path = 2;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.Source.SandboxPath.path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->path(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume.Source.SandboxPath)
  return target;
}

int Volume_Source_SandboxPath::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Volume.Source.SandboxPath)
  int total_size = 0;

  // required string path = 2;
  if (has_path()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->path());
  }
  // optional .mesos.Volume.Source.SandboxPath.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume_Source_SandboxPath::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Volume.Source.SandboxPath)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Volume_Source_SandboxPath* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Volume_Source_SandboxPath>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Volume.Source.SandboxPath)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Volume.Source.SandboxPath)
    MergeFrom(*source);
  }
}

void Volume_Source_SandboxPath::MergeFrom(const Volume_Source_SandboxPath& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Volume.Source.SandboxPath)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_path()) {
      set_has_path();
      path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Volume_Source_SandboxPath::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Volume.Source.SandboxPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume_Source_SandboxPath::CopyFrom(const Volume_Source_SandboxPath& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Volume.Source.SandboxPath)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume_Source_SandboxPath::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;

  return true;
}

void Volume_Source_SandboxPath::Swap(Volume_Source_SandboxPath* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Volume_Source_SandboxPath::InternalSwap(Volume_Source_SandboxPath* other) {
  std::swap(type_, other->type_);
  path_.Swap(&other->path_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Volume_Source_SandboxPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_Source_SandboxPath_descriptor_;
  metadata.reflection = Volume_Source_SandboxPath_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Volume_Source::kTypeFieldNumber;
const int Volume_Source::kDockerVolumeFieldNumber;
const int Volume_Source::kSandboxPathFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Volume_Source::Volume_Source()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume.Source)
}

void Volume_Source::InitAsDefaultInstance() {
  docker_volume_ = const_cast< ::mesos::Volume_Source_DockerVolume*>(&::mesos::Volume_Source_DockerVolume::default_instance());
  sandbox_path_ = const_cast< ::mesos::Volume_Source_SandboxPath*>(&::mesos::Volume_Source_SandboxPath::default_instance());
}

Volume_Source::Volume_Source(const Volume_Source& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume.Source)
}

void Volume_Source::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  docker_volume_ = NULL;
  sandbox_path_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume_Source::~Volume_Source() {
  // @@protoc_insertion_point(destructor:mesos.Volume.Source)
  SharedDtor();
}

void Volume_Source::SharedDtor() {
  if (this != default_instance_) {
    delete docker_volume_;
    delete sandbox_path_;
  }
}

void Volume_Source::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume_Source::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_Source_descriptor_;
}

const Volume_Source& Volume_Source::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume_Source* Volume_Source::default_instance_ = NULL;

Volume_Source* Volume_Source::New(::google::protobuf::Arena* arena) const {
  Volume_Source* n = new Volume_Source;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Volume_Source::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Volume.Source)
  if (_has_bits_[0 / 32] & 7u) {
    type_ = 0;
    if (has_docker_volume()) {
      if (docker_volume_ != NULL) docker_volume_->::mesos::Volume_Source_DockerVolume::Clear();
    }
    if (has_sandbox_path()) {
      if (sandbox_path_ != NULL) sandbox_path_->::mesos::Volume_Source_SandboxPath::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Volume_Source::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume.Source)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Volume.Source.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Volume_Source_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::Volume_Source_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_docker_volume;
        break;
      }

      // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
      case 2: {
        if (tag == 18) {
         parse_docker_volume:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker_volume()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_sandbox_path;
        break;
      }

      // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
      case 3: {
        if (tag == 26) {
         parse_sandbox_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sandbox_path()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume.Source)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume.Source)
  return false;
#undef DO_
}

void Volume_Source::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume.Source)
  // optional .mesos.Volume.Source.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
  if (has_docker_volume()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->docker_volume_, output);
  }

  // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
  if (has_sandbox_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->sandbox_path_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume.Source)
}

::google::protobuf::uint8* Volume_Source::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume.Source)
  // optional .mesos.Volume.Source.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
  if (has_docker_volume()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->docker_volume_, false, target);
  }

  // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
  if (has_sandbox_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->sandbox_path_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume.Source)
  return target;
}

int Volume_Source::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Volume.Source)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .mesos.Volume.Source.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
    if (has_docker_volume()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->docker_volume_);
    }

    // optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
    if (has_sandbox_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->sandbox_path_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume_Source::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Volume.Source)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Volume_Source* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Volume_Source>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Volume.Source)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Volume.Source)
    MergeFrom(*source);
  }
}

void Volume_Source::MergeFrom(const Volume_Source& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Volume.Source)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_docker_volume()) {
      mutable_docker_volume()->::mesos::Volume_Source_DockerVolume::MergeFrom(from.docker_volume());
    }
    if (from.has_sandbox_path()) {
      mutable_sandbox_path()->::mesos::Volume_Source_SandboxPath::MergeFrom(from.sandbox_path());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Volume_Source::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Volume.Source)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume_Source::CopyFrom(const Volume_Source& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Volume.Source)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume_Source::IsInitialized() const {

  if (has_docker_volume()) {
    if (!this->docker_volume_->IsInitialized()) return false;
  }
  if (has_sandbox_path()) {
    if (!this->sandbox_path_->IsInitialized()) return false;
  }
  return true;
}

void Volume_Source::Swap(Volume_Source* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Volume_Source::InternalSwap(Volume_Source* other) {
  std::swap(type_, other->type_);
  std::swap(docker_volume_, other->docker_volume_);
  std::swap(sandbox_path_, other->sandbox_path_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Volume_Source::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_Source_descriptor_;
  metadata.reflection = Volume_Source_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Volume::kModeFieldNumber;
const int Volume::kContainerPathFieldNumber;
const int Volume::kHostPathFieldNumber;
const int Volume::kImageFieldNumber;
const int Volume::kSourceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Volume::Volume()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Volume)
}

void Volume::InitAsDefaultInstance() {
  image_ = const_cast< ::mesos::Image*>(&::mesos::Image::default_instance());
  source_ = const_cast< ::mesos::Volume_Source*>(&::mesos::Volume_Source::default_instance());
}

Volume::Volume(const Volume& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Volume)
}

void Volume::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mode_ = 1;
  container_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  host_path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  image_ = NULL;
  source_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Volume::~Volume() {
  // @@protoc_insertion_point(destructor:mesos.Volume)
  SharedDtor();
}

void Volume::SharedDtor() {
  container_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  host_path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete image_;
    delete source_;
  }
}

void Volume::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Volume::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Volume_descriptor_;
}

const Volume& Volume::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Volume* Volume::default_instance_ = NULL;

Volume* Volume::New(::google::protobuf::Arena* arena) const {
  Volume* n = new Volume;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Volume::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Volume)
  if (_has_bits_[0 / 32] & 31u) {
    mode_ = 1;
    if (has_container_path()) {
      container_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_host_path()) {
      host_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_image()) {
      if (image_ != NULL) image_->::mesos::Image::Clear();
    }
    if (has_source()) {
      if (source_ != NULL) source_->::mesos::Volume_Source::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Volume::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Volume)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string container_path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_container_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->container_path().data(), this->container_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Volume.container_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_host_path;
        break;
      }

      // optional string host_path = 2;
      case 2: {
        if (tag == 18) {
         parse_host_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_host_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->host_path().data(), this->host_path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Volume.host_path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_mode;
        break;
      }

      // required .mesos.Volume.Mode mode = 3;
      case 3: {
        if (tag == 24) {
         parse_mode:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::Volume_Mode_IsValid(value)) {
            set_mode(static_cast< ::mesos::Volume_Mode >(value));
          } else {
            mutable_unknown_fields()->AddVarint(3, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_image;
        break;
      }

      // optional .mesos.Image image = 4;
      case 4: {
        if (tag == 34) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_source;
        break;
      }

      // optional .mesos.Volume.Source source = 5;
      case 5: {
        if (tag == 42) {
         parse_source:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_source()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Volume)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Volume)
  return false;
#undef DO_
}

void Volume::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Volume)
  // required string container_path = 1;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.container_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->container_path(), output);
  }

  // optional string host_path = 2;
  if (has_host_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host_path().data(), this->host_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.host_path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->host_path(), output);
  }

  // required .mesos.Volume.Mode mode = 3;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      3, this->mode(), output);
  }

  // optional .mesos.Image image = 4;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->image_, output);
  }

  // optional .mesos.Volume.Source source = 5;
  if (has_source()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->source_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Volume)
}

::google::protobuf::uint8* Volume::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Volume)
  // required string container_path = 1;
  if (has_container_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->container_path().data(), this->container_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.container_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->container_path(), target);
  }

  // optional string host_path = 2;
  if (has_host_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->host_path().data(), this->host_path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Volume.host_path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->host_path(), target);
  }

  // required .mesos.Volume.Mode mode = 3;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      3, this->mode(), target);
  }

  // optional .mesos.Image image = 4;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->image_, false, target);
  }

  // optional .mesos.Volume.Source source = 5;
  if (has_source()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->source_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Volume)
  return target;
}

int Volume::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Volume)
  int total_size = 0;

  if (has_mode()) {
    // required .mesos.Volume.Mode mode = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());
  }

  if (has_container_path()) {
    // required string container_path = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->container_path());
  }

  return total_size;
}
int Volume::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Volume)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .mesos.Volume.Mode mode = 3;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->mode());

    // required string container_path = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->container_path());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_has_bits_[2 / 32] & 28u) {
    // optional string host_path = 2;
    if (has_host_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->host_path());
    }

    // optional .mesos.Image image = 4;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->image_);
    }

    // optional .mesos.Volume.Source source = 5;
    if (has_source()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->source_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Volume::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Volume)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Volume* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Volume>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Volume)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Volume)
    MergeFrom(*source);
  }
}

void Volume::MergeFrom(const Volume& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Volume)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_container_path()) {
      set_has_container_path();
      container_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.container_path_);
    }
    if (from.has_host_path()) {
      set_has_host_path();
      host_path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.host_path_);
    }
    if (from.has_image()) {
      mutable_image()->::mesos::Image::MergeFrom(from.image());
    }
    if (from.has_source()) {
      mutable_source()->::mesos::Volume_Source::MergeFrom(from.source());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Volume::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Volume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Volume::CopyFrom(const Volume& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Volume)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Volume::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_image()) {
    if (!this->image_->IsInitialized()) return false;
  }
  if (has_source()) {
    if (!this->source_->IsInitialized()) return false;
  }
  return true;
}

void Volume::Swap(Volume* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Volume::InternalSwap(Volume* other) {
  std::swap(mode_, other->mode_);
  container_path_.Swap(&other->container_path_);
  host_path_.Swap(&other->host_path_);
  std::swap(image_, other->image_);
  std::swap(source_, other->source_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Volume::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Volume_descriptor_;
  metadata.reflection = Volume_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Volume_Source_DockerVolume

// optional string driver = 1;
bool Volume_Source_DockerVolume::has_driver() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Volume_Source_DockerVolume::set_has_driver() {
  _has_bits_[0] |= 0x00000001u;
}
void Volume_Source_DockerVolume::clear_has_driver() {
  _has_bits_[0] &= ~0x00000001u;
}
void Volume_Source_DockerVolume::clear_driver() {
  driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_driver();
}
 const ::std::string& Volume_Source_DockerVolume::driver() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.driver)
  return driver_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume_Source_DockerVolume::set_driver(const ::std::string& value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.DockerVolume.driver)
}
 void Volume_Source_DockerVolume::set_driver(const char* value) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.DockerVolume.driver)
}
 void Volume_Source_DockerVolume::set_driver(const char* value, size_t size) {
  set_has_driver();
  driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.DockerVolume.driver)
}
 ::std::string* Volume_Source_DockerVolume::mutable_driver() {
  set_has_driver();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.driver)
  return driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Volume_Source_DockerVolume::release_driver() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.DockerVolume.driver)
  clear_has_driver();
  return driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume_Source_DockerVolume::set_allocated_driver(::std::string* driver) {
  if (driver != NULL) {
    set_has_driver();
  } else {
    clear_has_driver();
  }
  driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), driver);
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.driver)
}

// required string name = 2;
bool Volume_Source_DockerVolume::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Volume_Source_DockerVolume::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Volume_Source_DockerVolume::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Volume_Source_DockerVolume::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Volume_Source_DockerVolume::name() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume_Source_DockerVolume::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.DockerVolume.name)
}
 void Volume_Source_DockerVolume::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.DockerVolume.name)
}
 void Volume_Source_DockerVolume::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.DockerVolume.name)
}
 ::std::string* Volume_Source_DockerVolume::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Volume_Source_DockerVolume::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.DockerVolume.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume_Source_DockerVolume::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.name)
}

// optional .mesos.Parameters driver_options = 3;
bool Volume_Source_DockerVolume::has_driver_options() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Volume_Source_DockerVolume::set_has_driver_options() {
  _has_bits_[0] |= 0x00000004u;
}
void Volume_Source_DockerVolume::clear_has_driver_options() {
  _has_bits_[0] &= ~0x00000004u;
}
void Volume_Source_DockerVolume::clear_driver_options() {
  if (driver_options_ != NULL) driver_options_->::mesos::Parameters::Clear();
  clear_has_driver_options();
}
const ::mesos::Parameters& Volume_Source_DockerVolume::driver_options() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.DockerVolume.driver_options)
  return driver_options_ != NULL ? *driver_options_ : *default_instance_->driver_options_;
}
::mesos::Parameters* Volume_Source_DockerVolume::mutable_driver_options() {
  set_has_driver_options();
  if (driver_options_ == NULL) {
    driver_options_ = new ::mesos::Parameters;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.DockerVolume.driver_options)
  return driver_options_;
}
::mesos::Parameters* Volume_Source_DockerVolume::release_driver_options() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.DockerVolume.driver_options)
  clear_has_driver_options();
  ::mesos::Parameters* temp = driver_options_;
  driver_options_ = NULL;
  return temp;
}
void Volume_Source_DockerVolume::set_allocated_driver_options(::mesos::Parameters* driver_options) {
  delete driver_options_;
  driver_options_ = driver_options;
  if (driver_options) {
    set_has_driver_options();
  } else {
    clear_has_driver_options();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.DockerVolume.driver_options)
}

// -------------------------------------------------------------------

// Volume_Source_SandboxPath

// optional .mesos.Volume.Source.SandboxPath.Type type = 1;
bool Volume_Source_SandboxPath::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Volume_Source_SandboxPath::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Volume_Source_SandboxPath::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Volume_Source_SandboxPath::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Volume_Source_SandboxPath_Type Volume_Source_SandboxPath::type() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.SandboxPath.type)
  return static_cast< ::mesos::Volume_Source_SandboxPath_Type >(type_);
}
 void Volume_Source_SandboxPath::set_type(::mesos::Volume_Source_SandboxPath_Type value) {
  assert(::mesos::Volume_Source_SandboxPath_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.SandboxPath.type)
}

// required string path = 2;
bool Volume_Source_SandboxPath::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Volume_Source_SandboxPath::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
void Volume_Source_SandboxPath::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
void Volume_Source_SandboxPath::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
 const ::std::string& Volume_Source_SandboxPath::path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.SandboxPath.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume_Source_SandboxPath::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.SandboxPath.path)
}
 void Volume_Source_SandboxPath::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Volume.Source.SandboxPath.path)
}
 void Volume_Source_SandboxPath::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.Source.SandboxPath.path)
}
 ::std::string* Volume_Source_SandboxPath::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.SandboxPath.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Volume_Source_SandboxPath::release_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.SandboxPath.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume_Source_SandboxPath::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.SandboxPath.path)
}

// -------------------------------------------------------------------

// Volume_Source

// optional .mesos.Volume.Source.Type type = 1;
bool Volume_Source::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Volume_Source::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void Volume_Source::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void Volume_Source::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::Volume_Source_Type Volume_Source::type() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.type)
  return static_cast< ::mesos::Volume_Source_Type >(type_);
}
 void Volume_Source::set_type(::mesos::Volume_Source_Type value) {
  assert(::mesos::Volume_Source_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.Source.type)
}

// optional .mesos.Volume.Source.DockerVolume docker_volume = 2;
bool Volume_Source::has_docker_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Volume_Source::set_has_docker_volume() {
  _has_bits_[0] |= 0x00000002u;
}
void Volume_Source::clear_has_docker_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
void Volume_Source::clear_docker_volume() {
  if (docker_volume_ != NULL) docker_volume_->::mesos::Volume_Source_DockerVolume::Clear();
  clear_has_docker_volume();
}
const ::mesos::Volume_Source_DockerVolume& Volume_Source::docker_volume() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.docker_volume)
  return docker_volume_ != NULL ? *docker_volume_ : *default_instance_->docker_volume_;
}
::mesos::Volume_Source_DockerVolume* Volume_Source::mutable_docker_volume() {
  set_has_docker_volume();
  if (docker_volume_ == NULL) {
    docker_volume_ = new ::mesos::Volume_Source_DockerVolume;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.docker_volume)
  return docker_volume_;
}
::mesos::Volume_Source_DockerVolume* Volume_Source::release_docker_volume() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.docker_volume)
  clear_has_docker_volume();
  ::mesos::Volume_Source_DockerVolume* temp = docker_volume_;
  docker_volume_ = NULL;
  return temp;
}
void Volume_Source::set_allocated_docker_volume(::mesos::Volume_Source_DockerVolume* docker_volume) {
  delete docker_volume_;
  docker_volume_ = docker_volume;
  if (docker_volume) {
    set_has_docker_volume();
  } else {
    clear_has_docker_volume();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.docker_volume)
}

// optional .mesos.Volume.Source.SandboxPath sandbox_path = 3;
bool Volume_Source::has_sandbox_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Volume_Source::set_has_sandbox_path() {
  _has_bits_[0] |= 0x00000004u;
}
void Volume_Source::clear_has_sandbox_path() {
  _has_bits_[0] &= ~0x00000004u;
}
void Volume_Source::clear_sandbox_path() {
  if (sandbox_path_ != NULL) sandbox_path_->::mesos::Volume_Source_SandboxPath::Clear();
  clear_has_sandbox_path();
}
const ::mesos::Volume_Source_SandboxPath& Volume_Source::sandbox_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.Source.sandbox_path)
  return sandbox_path_ != NULL ? *sandbox_path_ : *default_instance_->sandbox_path_;
}
::mesos::Volume_Source_SandboxPath* Volume_Source::mutable_sandbox_path() {
  set_has_sandbox_path();
  if (sandbox_path_ == NULL) {
    sandbox_path_ = new ::mesos::Volume_Source_SandboxPath;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.Source.sandbox_path)
  return sandbox_path_;
}
::mesos::Volume_Source_SandboxPath* Volume_Source::release_sandbox_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.Source.sandbox_path)
  clear_has_sandbox_path();
  ::mesos::Volume_Source_SandboxPath* temp = sandbox_path_;
  sandbox_path_ = NULL;
  return temp;
}
void Volume_Source::set_allocated_sandbox_path(::mesos::Volume_Source_SandboxPath* sandbox_path) {
  delete sandbox_path_;
  sandbox_path_ = sandbox_path;
  if (sandbox_path) {
    set_has_sandbox_path();
  } else {
    clear_has_sandbox_path();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.Source.sandbox_path)
}

// -------------------------------------------------------------------

// Volume

// required .mesos.Volume.Mode mode = 3;
bool Volume::has_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Volume::set_has_mode() {
  _has_bits_[0] |= 0x00000001u;
}
void Volume::clear_has_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
void Volume::clear_mode() {
  mode_ = 1;
  clear_has_mode();
}
 ::mesos::Volume_Mode Volume::mode() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.mode)
  return static_cast< ::mesos::Volume_Mode >(mode_);
}
 void Volume::set_mode(::mesos::Volume_Mode value) {
  assert(::mesos::Volume_Mode_IsValid(value));
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.Volume.mode)
}

// required string container_path = 1;
bool Volume::has_container_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Volume::set_has_container_path() {
  _has_bits_[0] |= 0x00000002u;
}
void Volume::clear_has_container_path() {
  _has_bits_[0] &= ~0x00000002u;
}
void Volume::clear_container_path() {
  container_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_container_path();
}
 const ::std::string& Volume::container_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.container_path)
  return container_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume::set_container_path(const ::std::string& value) {
  set_has_container_path();
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Volume.container_path)
}
 void Volume::set_container_path(const char* value) {
  set_has_container_path();
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Volume.container_path)
}
 void Volume::set_container_path(const char* value, size_t size) {
  set_has_container_path();
  container_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.container_path)
}
 ::std::string* Volume::mutable_container_path() {
  set_has_container_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.container_path)
  return container_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Volume::release_container_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.container_path)
  clear_has_container_path();
  return container_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume::set_allocated_container_path(::std::string* container_path) {
  if (container_path != NULL) {
    set_has_container_path();
  } else {
    clear_has_container_path();
  }
  container_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), container_path);
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.container_path)
}

// optional string host_path = 2;
bool Volume::has_host_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Volume::set_has_host_path() {
  _has_bits_[0] |= 0x00000004u;
}
void Volume::clear_has_host_path() {
  _has_bits_[0] &= ~0x00000004u;
}
void Volume::clear_host_path() {
  host_path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host_path();
}
 const ::std::string& Volume::host_path() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.host_path)
  return host_path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume::set_host_path(const ::std::string& value) {
  set_has_host_path();
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Volume.host_path)
}
 void Volume::set_host_path(const char* value) {
  set_has_host_path();
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Volume.host_path)
}
 void Volume::set_host_path(const char* value, size_t size) {
  set_has_host_path();
  host_path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Volume.host_path)
}
 ::std::string* Volume::mutable_host_path() {
  set_has_host_path();
  // @@protoc_insertion_point(field_mutable:mesos.Volume.host_path)
  return host_path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Volume::release_host_path() {
  // @@protoc_insertion_point(field_release:mesos.Volume.host_path)
  clear_has_host_path();
  return host_path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Volume::set_allocated_host_path(::std::string* host_path) {
  if (host_path != NULL) {
    set_has_host_path();
  } else {
    clear_has_host_path();
  }
  host_path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host_path);
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.host_path)
}

// optional .mesos.Image image = 4;
bool Volume::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Volume::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
void Volume::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
void Volume::clear_image() {
  if (image_ != NULL) image_->::mesos::Image::Clear();
  clear_has_image();
}
const ::mesos::Image& Volume::image() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
::mesos::Image* Volume::mutable_image() {
  set_has_image();
  if (image_ == NULL) {
    image_ = new ::mesos::Image;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.image)
  return image_;
}
::mesos::Image* Volume::release_image() {
  // @@protoc_insertion_point(field_release:mesos.Volume.image)
  clear_has_image();
  ::mesos::Image* temp = image_;
  image_ = NULL;
  return temp;
}
void Volume::set_allocated_image(::mesos::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.image)
}

// optional .mesos.Volume.Source source = 5;
bool Volume::has_source() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Volume::set_has_source() {
  _has_bits_[0] |= 0x00000010u;
}
void Volume::clear_has_source() {
  _has_bits_[0] &= ~0x00000010u;
}
void Volume::clear_source() {
  if (source_ != NULL) source_->::mesos::Volume_Source::Clear();
  clear_has_source();
}
const ::mesos::Volume_Source& Volume::source() const {
  // @@protoc_insertion_point(field_get:mesos.Volume.source)
  return source_ != NULL ? *source_ : *default_instance_->source_;
}
::mesos::Volume_Source* Volume::mutable_source() {
  set_has_source();
  if (source_ == NULL) {
    source_ = new ::mesos::Volume_Source;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Volume.source)
  return source_;
}
::mesos::Volume_Source* Volume::release_source() {
  // @@protoc_insertion_point(field_release:mesos.Volume.source)
  clear_has_source();
  ::mesos::Volume_Source* temp = source_;
  source_ = NULL;
  return temp;
}
void Volume::set_allocated_source(::mesos::Volume_Source* source) {
  delete source_;
  source_ = source;
  if (source) {
    set_has_source();
  } else {
    clear_has_source();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Volume.source)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* NetworkInfo_Protocol_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_Protocol_descriptor_;
}
bool NetworkInfo_Protocol_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const NetworkInfo_Protocol NetworkInfo::IPv4;
const NetworkInfo_Protocol NetworkInfo::IPv6;
const NetworkInfo_Protocol NetworkInfo::Protocol_MIN;
const NetworkInfo_Protocol NetworkInfo::Protocol_MAX;
const int NetworkInfo::Protocol_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NetworkInfo_IPAddress::kProtocolFieldNumber;
const int NetworkInfo_IPAddress::kIpAddressFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NetworkInfo_IPAddress::NetworkInfo_IPAddress()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.NetworkInfo.IPAddress)
}

void NetworkInfo_IPAddress::InitAsDefaultInstance() {
}

NetworkInfo_IPAddress::NetworkInfo_IPAddress(const NetworkInfo_IPAddress& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.NetworkInfo.IPAddress)
}

void NetworkInfo_IPAddress::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  protocol_ = 1;
  ip_address_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkInfo_IPAddress::~NetworkInfo_IPAddress() {
  // @@protoc_insertion_point(destructor:mesos.NetworkInfo.IPAddress)
  SharedDtor();
}

void NetworkInfo_IPAddress::SharedDtor() {
  ip_address_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void NetworkInfo_IPAddress::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkInfo_IPAddress::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_IPAddress_descriptor_;
}

const NetworkInfo_IPAddress& NetworkInfo_IPAddress::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

NetworkInfo_IPAddress* NetworkInfo_IPAddress::default_instance_ = NULL;

NetworkInfo_IPAddress* NetworkInfo_IPAddress::New(::google::protobuf::Arena* arena) const {
  NetworkInfo_IPAddress* n = new NetworkInfo_IPAddress;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NetworkInfo_IPAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.NetworkInfo.IPAddress)
  if (_has_bits_[0 / 32] & 3u) {
    protocol_ = 1;
    if (has_ip_address()) {
      ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NetworkInfo_IPAddress::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.NetworkInfo.IPAddress)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.NetworkInfo.Protocol protocol = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::NetworkInfo_Protocol_IsValid(value)) {
            set_protocol(static_cast< ::mesos::NetworkInfo_Protocol >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_ip_address;
        break;
      }

      // optional string ip_address = 2;
      case 2: {
        if (tag == 18) {
         parse_ip_address:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_ip_address()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->ip_address().data(), this->ip_address().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.NetworkInfo.IPAddress.ip_address");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.NetworkInfo.IPAddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.NetworkInfo.IPAddress)
  return false;
#undef DO_
}

void NetworkInfo_IPAddress::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.NetworkInfo.IPAddress)
  // optional .mesos.NetworkInfo.Protocol protocol = 1;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->protocol(), output);
  }

  // optional string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.IPAddress.ip_address");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->ip_address(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.NetworkInfo.IPAddress)
}

::google::protobuf::uint8* NetworkInfo_IPAddress::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.NetworkInfo.IPAddress)
  // optional .mesos.NetworkInfo.Protocol protocol = 1;
  if (has_protocol()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->protocol(), target);
  }

  // optional string ip_address = 2;
  if (has_ip_address()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->ip_address().data(), this->ip_address().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.IPAddress.ip_address");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->ip_address(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.NetworkInfo.IPAddress)
  return target;
}

int NetworkInfo_IPAddress::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.NetworkInfo.IPAddress)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 3u) {
    // optional .mesos.NetworkInfo.Protocol protocol = 1;
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->protocol());
    }

    // optional string ip_address = 2;
    if (has_ip_address()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->ip_address());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkInfo_IPAddress::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.NetworkInfo.IPAddress)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const NetworkInfo_IPAddress* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NetworkInfo_IPAddress>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.NetworkInfo.IPAddress)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.NetworkInfo.IPAddress)
    MergeFrom(*source);
  }
}

void NetworkInfo_IPAddress::MergeFrom(const NetworkInfo_IPAddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.NetworkInfo.IPAddress)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_protocol()) {
      set_protocol(from.protocol());
    }
    if (from.has_ip_address()) {
      set_has_ip_address();
      ip_address_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.ip_address_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NetworkInfo_IPAddress::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.NetworkInfo.IPAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkInfo_IPAddress::CopyFrom(const NetworkInfo_IPAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.NetworkInfo.IPAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInfo_IPAddress::IsInitialized() const {

  return true;
}

void NetworkInfo_IPAddress::Swap(NetworkInfo_IPAddress* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NetworkInfo_IPAddress::InternalSwap(NetworkInfo_IPAddress* other) {
  std::swap(protocol_, other->protocol_);
  ip_address_.Swap(&other->ip_address_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NetworkInfo_IPAddress::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkInfo_IPAddress_descriptor_;
  metadata.reflection = NetworkInfo_IPAddress_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NetworkInfo_PortMapping::kHostPortFieldNumber;
const int NetworkInfo_PortMapping::kContainerPortFieldNumber;
const int NetworkInfo_PortMapping::kProtocolFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NetworkInfo_PortMapping::NetworkInfo_PortMapping()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.NetworkInfo.PortMapping)
}

void NetworkInfo_PortMapping::InitAsDefaultInstance() {
}

NetworkInfo_PortMapping::NetworkInfo_PortMapping(const NetworkInfo_PortMapping& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.NetworkInfo.PortMapping)
}

void NetworkInfo_PortMapping::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_port_ = 0u;
  container_port_ = 0u;
  protocol_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkInfo_PortMapping::~NetworkInfo_PortMapping() {
  // @@protoc_insertion_point(destructor:mesos.NetworkInfo.PortMapping)
  SharedDtor();
}

void NetworkInfo_PortMapping::SharedDtor() {
  protocol_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void NetworkInfo_PortMapping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkInfo_PortMapping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_PortMapping_descriptor_;
}

const NetworkInfo_PortMapping& NetworkInfo_PortMapping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

NetworkInfo_PortMapping* NetworkInfo_PortMapping::default_instance_ = NULL;

NetworkInfo_PortMapping* NetworkInfo_PortMapping::New(::google::protobuf::Arena* arena) const {
  NetworkInfo_PortMapping* n = new NetworkInfo_PortMapping;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NetworkInfo_PortMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.NetworkInfo.PortMapping)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(NetworkInfo_PortMapping, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<NetworkInfo_PortMapping*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(host_port_, container_port_);
    if (has_protocol()) {
      protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NetworkInfo_PortMapping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.NetworkInfo.PortMapping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_port_)));
          set_has_host_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_container_port;
        break;
      }

      // required uint32 container_port = 2;
      case 2: {
        if (tag == 16) {
         parse_container_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &container_port_)));
          set_has_container_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_protocol;
        break;
      }

      // optional string protocol = 3;
      case 3: {
        if (tag == 26) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->protocol().data(), this->protocol().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.NetworkInfo.PortMapping.protocol");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.NetworkInfo.PortMapping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.NetworkInfo.PortMapping)
  return false;
#undef DO_
}

void NetworkInfo_PortMapping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.NetworkInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_port(), output);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->container_port(), output);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.PortMapping.protocol");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->protocol(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.NetworkInfo.PortMapping)
}

::google::protobuf::uint8* NetworkInfo_PortMapping::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.NetworkInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->host_port(), target);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->container_port(), target);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.PortMapping.protocol");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->protocol(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.NetworkInfo.PortMapping)
  return target;
}

int NetworkInfo_PortMapping::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.NetworkInfo.PortMapping)
  int total_size = 0;

  if (has_host_port()) {
    // required uint32 host_port = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->host_port());
  }

  if (has_container_port()) {
    // required uint32 container_port = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->container_port());
  }

  return total_size;
}
int NetworkInfo_PortMapping::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.NetworkInfo.PortMapping)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 host_port = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->host_port());

    // required uint32 container_port = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->container_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string protocol = 3;
  if (has_protocol()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->protocol());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkInfo_PortMapping::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.NetworkInfo.PortMapping)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const NetworkInfo_PortMapping* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NetworkInfo_PortMapping>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.NetworkInfo.PortMapping)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.NetworkInfo.PortMapping)
    MergeFrom(*source);
  }
}

void NetworkInfo_PortMapping::MergeFrom(const NetworkInfo_PortMapping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.NetworkInfo.PortMapping)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_port()) {
      set_host_port(from.host_port());
    }
    if (from.has_container_port()) {
      set_container_port(from.container_port());
    }
    if (from.has_protocol()) {
      set_has_protocol();
      protocol_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.protocol_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NetworkInfo_PortMapping::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.NetworkInfo.PortMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkInfo_PortMapping::CopyFrom(const NetworkInfo_PortMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.NetworkInfo.PortMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInfo_PortMapping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NetworkInfo_PortMapping::Swap(NetworkInfo_PortMapping* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NetworkInfo_PortMapping::InternalSwap(NetworkInfo_PortMapping* other) {
  std::swap(host_port_, other->host_port_);
  std::swap(container_port_, other->container_port_);
  protocol_.Swap(&other->protocol_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NetworkInfo_PortMapping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkInfo_PortMapping_descriptor_;
  metadata.reflection = NetworkInfo_PortMapping_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NetworkInfo::kIpAddressesFieldNumber;
const int NetworkInfo::kNameFieldNumber;
const int NetworkInfo::kGroupsFieldNumber;
const int NetworkInfo::kLabelsFieldNumber;
const int NetworkInfo::kPortMappingsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NetworkInfo::NetworkInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.NetworkInfo)
}

void NetworkInfo::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

NetworkInfo::NetworkInfo(const NetworkInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.NetworkInfo)
}

void NetworkInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetworkInfo::~NetworkInfo() {
  // @@protoc_insertion_point(destructor:mesos.NetworkInfo)
  SharedDtor();
}

void NetworkInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete labels_;
  }
}

void NetworkInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetworkInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetworkInfo_descriptor_;
}

const NetworkInfo& NetworkInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

NetworkInfo* NetworkInfo::default_instance_ = NULL;

NetworkInfo* NetworkInfo::New(::google::protobuf::Arena* arena) const {
  NetworkInfo* n = new NetworkInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NetworkInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.NetworkInfo)
  if (_has_bits_[0 / 32] & 10u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ip_addresses_.Clear();
  groups_.Clear();
  port_mappings_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool NetworkInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.NetworkInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string groups = 3;
      case 3: {
        if (tag == 26) {
         parse_groups:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_groups()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->groups(this->groups_size() - 1).data(),
            this->groups(this->groups_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.NetworkInfo.groups");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_groups;
        if (input->ExpectTag(34)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 4;
      case 4: {
        if (tag == 34) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_ip_addresses;
        break;
      }

      // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
      case 5: {
        if (tag == 42) {
         parse_ip_addresses:
          DO_(input->IncrementRecursionDepth());
         parse_loop_ip_addresses:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_ip_addresses()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_ip_addresses;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(50)) goto parse_name;
        break;
      }

      // optional string name = 6;
      case 6: {
        if (tag == 50) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.NetworkInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_port_mappings;
        break;
      }

      // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
      case 7: {
        if (tag == 58) {
         parse_port_mappings:
          DO_(input->IncrementRecursionDepth());
         parse_loop_port_mappings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_port_mappings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_port_mappings;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.NetworkInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.NetworkInfo)
  return false;
#undef DO_
}

void NetworkInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.NetworkInfo)
  // repeated string groups = 3;
  for (int i = 0; i < this->groups_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->groups(i).data(), this->groups(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.groups");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->groups(i), output);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->labels_, output);
  }

  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  for (unsigned int i = 0, n = this->ip_addresses_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->ip_addresses(i), output);
  }

  // optional string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->name(), output);
  }

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  for (unsigned int i = 0, n = this->port_mappings_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->port_mappings(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.NetworkInfo)
}

::google::protobuf::uint8* NetworkInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.NetworkInfo)
  // repeated string groups = 3;
  for (int i = 0; i < this->groups_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->groups(i).data(), this->groups(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.groups");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(3, this->groups(i), target);
  }

  // optional .mesos.Labels labels = 4;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->labels_, false, target);
  }

  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  for (unsigned int i = 0, n = this->ip_addresses_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->ip_addresses(i), false, target);
  }

  // optional string name = 6;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.NetworkInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->name(), target);
  }

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  for (unsigned int i = 0, n = this->port_mappings_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->port_mappings(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.NetworkInfo)
  return target;
}

int NetworkInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.NetworkInfo)
  int total_size = 0;

  if (_has_bits_[1 / 32] & 10u) {
    // optional string name = 6;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .mesos.Labels labels = 4;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  // repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
  total_size += 1 * this->ip_addresses_size();
  for (int i = 0; i < this->ip_addresses_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ip_addresses(i));
  }

  // repeated string groups = 3;
  total_size += 1 * this->groups_size();
  for (int i = 0; i < this->groups_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->groups(i));
  }

  // repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
  total_size += 1 * this->port_mappings_size();
  for (int i = 0; i < this->port_mappings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port_mappings(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetworkInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.NetworkInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const NetworkInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const NetworkInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.NetworkInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.NetworkInfo)
    MergeFrom(*source);
  }
}

void NetworkInfo::MergeFrom(const NetworkInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.NetworkInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  ip_addresses_.MergeFrom(from.ip_addresses_);
  groups_.MergeFrom(from.groups_);
  port_mappings_.MergeFrom(from.port_mappings_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void NetworkInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.NetworkInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetworkInfo::CopyFrom(const NetworkInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.NetworkInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetworkInfo::IsInitialized() const {

  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->port_mappings())) return false;
  return true;
}

void NetworkInfo::Swap(NetworkInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NetworkInfo::InternalSwap(NetworkInfo* other) {
  ip_addresses_.UnsafeArenaSwap(&other->ip_addresses_);
  name_.Swap(&other->name_);
  groups_.UnsafeArenaSwap(&other->groups_);
  std::swap(labels_, other->labels_);
  port_mappings_.UnsafeArenaSwap(&other->port_mappings_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NetworkInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetworkInfo_descriptor_;
  metadata.reflection = NetworkInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NetworkInfo_IPAddress

// optional .mesos.NetworkInfo.Protocol protocol = 1;
bool NetworkInfo_IPAddress::has_protocol() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NetworkInfo_IPAddress::set_has_protocol() {
  _has_bits_[0] |= 0x00000001u;
}
void NetworkInfo_IPAddress::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000001u;
}
void NetworkInfo_IPAddress::clear_protocol() {
  protocol_ = 1;
  clear_has_protocol();
}
 ::mesos::NetworkInfo_Protocol NetworkInfo_IPAddress::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.IPAddress.protocol)
  return static_cast< ::mesos::NetworkInfo_Protocol >(protocol_);
}
 void NetworkInfo_IPAddress::set_protocol(::mesos::NetworkInfo_Protocol value) {
  assert(::mesos::NetworkInfo_Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.IPAddress.protocol)
}

// optional string ip_address = 2;
bool NetworkInfo_IPAddress::has_ip_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NetworkInfo_IPAddress::set_has_ip_address() {
  _has_bits_[0] |= 0x00000002u;
}
void NetworkInfo_IPAddress::clear_has_ip_address() {
  _has_bits_[0] &= ~0x00000002u;
}
void NetworkInfo_IPAddress::clear_ip_address() {
  ip_address_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_ip_address();
}
 const ::std::string& NetworkInfo_IPAddress::ip_address() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.IPAddress.ip_address)
  return ip_address_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NetworkInfo_IPAddress::set_ip_address(const ::std::string& value) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.IPAddress.ip_address)
}
 void NetworkInfo_IPAddress::set_ip_address(const char* value) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.IPAddress.ip_address)
}
 void NetworkInfo_IPAddress::set_ip_address(const char* value, size_t size) {
  set_has_ip_address();
  ip_address_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.IPAddress.ip_address)
}
 ::std::string* NetworkInfo_IPAddress::mutable_ip_address() {
  set_has_ip_address();
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.IPAddress.ip_address)
  return ip_address_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NetworkInfo_IPAddress::release_ip_address() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.IPAddress.ip_address)
  clear_has_ip_address();
  return ip_address_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NetworkInfo_IPAddress::set_allocated_ip_address(::std::string* ip_address) {
  if (ip_address != NULL) {
    set_has_ip_address();
  } else {
    clear_has_ip_address();
  }
  ip_address_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ip_address);
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.IPAddress.ip_address)
}

// -------------------------------------------------------------------

// NetworkInfo_PortMapping

// required uint32 host_port = 1;
bool NetworkInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void NetworkInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000001u;
}
void NetworkInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000001u;
}
void NetworkInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
 ::google::protobuf::uint32 NetworkInfo_PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.host_port)
  return host_port_;
}
 void NetworkInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.host_port)
}

// required uint32 container_port = 2;
bool NetworkInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NetworkInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000002u;
}
void NetworkInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000002u;
}
void NetworkInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
 ::google::protobuf::uint32 NetworkInfo_PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.container_port)
  return container_port_;
}
 void NetworkInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.container_port)
}

// optional string protocol = 3;
bool NetworkInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void NetworkInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
void NetworkInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
void NetworkInfo_PortMapping::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
 const ::std::string& NetworkInfo_PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.PortMapping.protocol)
  return protocol_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NetworkInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.PortMapping.protocol)
}
 void NetworkInfo_PortMapping::set_protocol(const char* value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.PortMapping.protocol)
}
 void NetworkInfo_PortMapping::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.PortMapping.protocol)
}
 ::std::string* NetworkInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.PortMapping.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NetworkInfo_PortMapping::release_protocol() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.PortMapping.protocol)
  clear_has_protocol();
  return protocol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NetworkInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.PortMapping.protocol)
}

// -------------------------------------------------------------------

// NetworkInfo

// repeated .mesos.NetworkInfo.IPAddress ip_addresses = 5;
int NetworkInfo::ip_addresses_size() const {
  return ip_addresses_.size();
}
void NetworkInfo::clear_ip_addresses() {
  ip_addresses_.Clear();
}
const ::mesos::NetworkInfo_IPAddress& NetworkInfo::ip_addresses(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Get(index);
}
::mesos::NetworkInfo_IPAddress* NetworkInfo::mutable_ip_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Mutable(index);
}
::mesos::NetworkInfo_IPAddress* NetworkInfo::add_ip_addresses() {
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >*
NetworkInfo::mutable_ip_addresses() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.ip_addresses)
  return &ip_addresses_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_IPAddress >&
NetworkInfo::ip_addresses() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.ip_addresses)
  return ip_addresses_;
}

// optional string name = 6;
bool NetworkInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void NetworkInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void NetworkInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void NetworkInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& NetworkInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NetworkInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.name)
}
 void NetworkInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.name)
}
 void NetworkInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.name)
}
 ::std::string* NetworkInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* NetworkInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void NetworkInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.name)
}

// repeated string groups = 3;
int NetworkInfo::groups_size() const {
  return groups_.size();
}
void NetworkInfo::clear_groups() {
  groups_.Clear();
}
 const ::std::string& NetworkInfo::groups(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.groups)
  return groups_.Get(index);
}
 ::std::string* NetworkInfo::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.groups)
  return groups_.Mutable(index);
}
 void NetworkInfo::set_groups(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:mesos.NetworkInfo.groups)
  groups_.Mutable(index)->assign(value);
}
 void NetworkInfo::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:mesos.NetworkInfo.groups)
}
 void NetworkInfo::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:mesos.NetworkInfo.groups)
}
 ::std::string* NetworkInfo::add_groups() {
  // @@protoc_insertion_point(field_add_mutable:mesos.NetworkInfo.groups)
  return groups_.Add();
}
 void NetworkInfo::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.groups)
}
 void NetworkInfo::add_groups(const char* value) {
  groups_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:mesos.NetworkInfo.groups)
}
 void NetworkInfo::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:mesos.NetworkInfo.groups)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
NetworkInfo::groups() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.groups)
  return groups_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
NetworkInfo::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.groups)
  return &groups_;
}

// optional .mesos.Labels labels = 4;
bool NetworkInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void NetworkInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000008u;
}
void NetworkInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000008u;
}
void NetworkInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& NetworkInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* NetworkInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.labels)
  return labels_;
}
::mesos::Labels* NetworkInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.NetworkInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void NetworkInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.NetworkInfo.labels)
}

// repeated .mesos.NetworkInfo.PortMapping port_mappings = 7;
int NetworkInfo::port_mappings_size() const {
  return port_mappings_.size();
}
void NetworkInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
const ::mesos::NetworkInfo_PortMapping& NetworkInfo::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Get(index);
}
::mesos::NetworkInfo_PortMapping* NetworkInfo::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Mutable(index);
}
::mesos::NetworkInfo_PortMapping* NetworkInfo::add_port_mappings() {
  // @@protoc_insertion_point(field_add:mesos.NetworkInfo.port_mappings)
  return port_mappings_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >*
NetworkInfo::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:mesos.NetworkInfo.port_mappings)
  return &port_mappings_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo_PortMapping >&
NetworkInfo::port_mappings() const {
  // @@protoc_insertion_point(field_list:mesos.NetworkInfo.port_mappings)
  return port_mappings_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* CapabilityInfo_Capability_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CapabilityInfo_Capability_descriptor_;
}
bool CapabilityInfo_Capability_IsValid(int value) {
  switch(value) {
    case 0:
    case 1000:
    case 1001:
    case 1002:
    case 1003:
    case 1004:
    case 1005:
    case 1006:
    case 1007:
    case 1008:
    case 1009:
    case 1010:
    case 1011:
    case 1012:
    case 1013:
    case 1014:
    case 1015:
    case 1016:
    case 1017:
    case 1018:
    case 1019:
    case 1020:
    case 1021:
    case 1022:
    case 1023:
    case 1024:
    case 1025:
    case 1026:
    case 1027:
    case 1028:
    case 1029:
    case 1030:
    case 1031:
    case 1032:
    case 1033:
    case 1034:
    case 1035:
    case 1036:
    case 1037:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const CapabilityInfo_Capability CapabilityInfo::UNKNOWN;
const CapabilityInfo_Capability CapabilityInfo::CHOWN;
const CapabilityInfo_Capability CapabilityInfo::DAC_OVERRIDE;
const CapabilityInfo_Capability CapabilityInfo::DAC_READ_SEARCH;
const CapabilityInfo_Capability CapabilityInfo::FOWNER;
const CapabilityInfo_Capability CapabilityInfo::FSETID;
const CapabilityInfo_Capability CapabilityInfo::KILL;
const CapabilityInfo_Capability CapabilityInfo::SETGID;
const CapabilityInfo_Capability CapabilityInfo::SETUID;
const CapabilityInfo_Capability CapabilityInfo::SETPCAP;
const CapabilityInfo_Capability CapabilityInfo::LINUX_IMMUTABLE;
const CapabilityInfo_Capability CapabilityInfo::NET_BIND_SERVICE;
const CapabilityInfo_Capability CapabilityInfo::NET_BROADCAST;
const CapabilityInfo_Capability CapabilityInfo::NET_ADMIN;
const CapabilityInfo_Capability CapabilityInfo::NET_RAW;
const CapabilityInfo_Capability CapabilityInfo::IPC_LOCK;
const CapabilityInfo_Capability CapabilityInfo::IPC_OWNER;
const CapabilityInfo_Capability CapabilityInfo::SYS_MODULE;
const CapabilityInfo_Capability CapabilityInfo::SYS_RAWIO;
const CapabilityInfo_Capability CapabilityInfo::SYS_CHROOT;
const CapabilityInfo_Capability CapabilityInfo::SYS_PTRACE;
const CapabilityInfo_Capability CapabilityInfo::SYS_PACCT;
const CapabilityInfo_Capability CapabilityInfo::SYS_ADMIN;
const CapabilityInfo_Capability CapabilityInfo::SYS_BOOT;
const CapabilityInfo_Capability CapabilityInfo::SYS_NICE;
const CapabilityInfo_Capability CapabilityInfo::SYS_RESOURCE;
const CapabilityInfo_Capability CapabilityInfo::SYS_TIME;
const CapabilityInfo_Capability CapabilityInfo::SYS_TTY_CONFIG;
const CapabilityInfo_Capability CapabilityInfo::MKNOD;
const CapabilityInfo_Capability CapabilityInfo::LEASE;
const CapabilityInfo_Capability CapabilityInfo::AUDIT_WRITE;
const CapabilityInfo_Capability CapabilityInfo::AUDIT_CONTROL;
const CapabilityInfo_Capability CapabilityInfo::SETFCAP;
const CapabilityInfo_Capability CapabilityInfo::MAC_OVERRIDE;
const CapabilityInfo_Capability CapabilityInfo::MAC_ADMIN;
const CapabilityInfo_Capability CapabilityInfo::SYSLOG;
const CapabilityInfo_Capability CapabilityInfo::WAKE_ALARM;
const CapabilityInfo_Capability CapabilityInfo::BLOCK_SUSPEND;
const CapabilityInfo_Capability CapabilityInfo::AUDIT_READ;
const CapabilityInfo_Capability CapabilityInfo::Capability_MIN;
const CapabilityInfo_Capability CapabilityInfo::Capability_MAX;
const int CapabilityInfo::Capability_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CapabilityInfo::kCapabilitiesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CapabilityInfo::CapabilityInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CapabilityInfo)
}

void CapabilityInfo::InitAsDefaultInstance() {
}

CapabilityInfo::CapabilityInfo(const CapabilityInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CapabilityInfo)
}

void CapabilityInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CapabilityInfo::~CapabilityInfo() {
  // @@protoc_insertion_point(destructor:mesos.CapabilityInfo)
  SharedDtor();
}

void CapabilityInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CapabilityInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CapabilityInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CapabilityInfo_descriptor_;
}

const CapabilityInfo& CapabilityInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CapabilityInfo* CapabilityInfo::default_instance_ = NULL;

CapabilityInfo* CapabilityInfo::New(::google::protobuf::Arena* arena) const {
  CapabilityInfo* n = new CapabilityInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CapabilityInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CapabilityInfo)
  capabilities_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CapabilityInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CapabilityInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
      case 1: {
        if (tag == 8) {
         parse_capabilities:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::CapabilityInfo_Capability_IsValid(value)) {
            add_capabilities(static_cast< ::mesos::CapabilityInfo_Capability >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormat::ReadPackedEnumPreserveUnknowns(
                 input,
                 1,
                 ::mesos::CapabilityInfo_Capability_IsValid,
                 mutable_unknown_fields(),
                 this->mutable_capabilities())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(8)) goto parse_capabilities;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CapabilityInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CapabilityInfo)
  return false;
#undef DO_
}

void CapabilityInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CapabilityInfo)
  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  for (int i = 0; i < this->capabilities_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->capabilities(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CapabilityInfo)
}

::google::protobuf::uint8* CapabilityInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CapabilityInfo)
  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  for (int i = 0; i < this->capabilities_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->capabilities(i), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CapabilityInfo)
  return target;
}

int CapabilityInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CapabilityInfo)
  int total_size = 0;

  // repeated .mesos.CapabilityInfo.Capability capabilities = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->capabilities_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::EnumSize(
        this->capabilities(i));
    }
    total_size += 1 * this->capabilities_size() + data_size;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CapabilityInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CapabilityInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CapabilityInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CapabilityInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CapabilityInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CapabilityInfo)
    MergeFrom(*source);
  }
}

void CapabilityInfo::MergeFrom(const CapabilityInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CapabilityInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  capabilities_.MergeFrom(from.capabilities_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CapabilityInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CapabilityInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CapabilityInfo::CopyFrom(const CapabilityInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CapabilityInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CapabilityInfo::IsInitialized() const {

  return true;
}

void CapabilityInfo::Swap(CapabilityInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CapabilityInfo::InternalSwap(CapabilityInfo* other) {
  capabilities_.UnsafeArenaSwap(&other->capabilities_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CapabilityInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CapabilityInfo_descriptor_;
  metadata.reflection = CapabilityInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CapabilityInfo

// repeated .mesos.CapabilityInfo.Capability capabilities = 1;
int CapabilityInfo::capabilities_size() const {
  return capabilities_.size();
}
void CapabilityInfo::clear_capabilities() {
  capabilities_.Clear();
}
 ::mesos::CapabilityInfo_Capability CapabilityInfo::capabilities(int index) const {
  // @@protoc_insertion_point(field_get:mesos.CapabilityInfo.capabilities)
  return static_cast< ::mesos::CapabilityInfo_Capability >(capabilities_.Get(index));
}
 void CapabilityInfo::set_capabilities(int index, ::mesos::CapabilityInfo_Capability value) {
  assert(::mesos::CapabilityInfo_Capability_IsValid(value));
  capabilities_.Set(index, value);
  // @@protoc_insertion_point(field_set:mesos.CapabilityInfo.capabilities)
}
 void CapabilityInfo::add_capabilities(::mesos::CapabilityInfo_Capability value) {
  assert(::mesos::CapabilityInfo_Capability_IsValid(value));
  capabilities_.Add(value);
  // @@protoc_insertion_point(field_add:mesos.CapabilityInfo.capabilities)
}
 const ::google::protobuf::RepeatedField<int>&
CapabilityInfo::capabilities() const {
  // @@protoc_insertion_point(field_list:mesos.CapabilityInfo.capabilities)
  return capabilities_;
}
 ::google::protobuf::RepeatedField<int>*
CapabilityInfo::mutable_capabilities() {
  // @@protoc_insertion_point(field_mutable_list:mesos.CapabilityInfo.capabilities)
  return &capabilities_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int LinuxInfo::kCapabilityInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

LinuxInfo::LinuxInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.LinuxInfo)
}

void LinuxInfo::InitAsDefaultInstance() {
  capability_info_ = const_cast< ::mesos::CapabilityInfo*>(&::mesos::CapabilityInfo::default_instance());
}

LinuxInfo::LinuxInfo(const LinuxInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.LinuxInfo)
}

void LinuxInfo::SharedCtor() {
  _cached_size_ = 0;
  capability_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LinuxInfo::~LinuxInfo() {
  // @@protoc_insertion_point(destructor:mesos.LinuxInfo)
  SharedDtor();
}

void LinuxInfo::SharedDtor() {
  if (this != default_instance_) {
    delete capability_info_;
  }
}

void LinuxInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LinuxInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LinuxInfo_descriptor_;
}

const LinuxInfo& LinuxInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

LinuxInfo* LinuxInfo::default_instance_ = NULL;

LinuxInfo* LinuxInfo::New(::google::protobuf::Arena* arena) const {
  LinuxInfo* n = new LinuxInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void LinuxInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.LinuxInfo)
  if (has_capability_info()) {
    if (capability_info_ != NULL) capability_info_->::mesos::CapabilityInfo::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool LinuxInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.LinuxInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CapabilityInfo capability_info = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_capability_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.LinuxInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.LinuxInfo)
  return false;
#undef DO_
}

void LinuxInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.LinuxInfo)
  // optional .mesos.CapabilityInfo capability_info = 1;
  if (has_capability_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->capability_info_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.LinuxInfo)
}

::google::protobuf::uint8* LinuxInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.LinuxInfo)
  // optional .mesos.CapabilityInfo capability_info = 1;
  if (has_capability_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->capability_info_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.LinuxInfo)
  return target;
}

int LinuxInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.LinuxInfo)
  int total_size = 0;

  // optional .mesos.CapabilityInfo capability_info = 1;
  if (has_capability_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->capability_info_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LinuxInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.LinuxInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const LinuxInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const LinuxInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.LinuxInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.LinuxInfo)
    MergeFrom(*source);
  }
}

void LinuxInfo::MergeFrom(const LinuxInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.LinuxInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_capability_info()) {
      mutable_capability_info()->::mesos::CapabilityInfo::MergeFrom(from.capability_info());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void LinuxInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.LinuxInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LinuxInfo::CopyFrom(const LinuxInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.LinuxInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LinuxInfo::IsInitialized() const {

  return true;
}

void LinuxInfo::Swap(LinuxInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void LinuxInfo::InternalSwap(LinuxInfo* other) {
  std::swap(capability_info_, other->capability_info_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata LinuxInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LinuxInfo_descriptor_;
  metadata.reflection = LinuxInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// LinuxInfo

// optional .mesos.CapabilityInfo capability_info = 1;
bool LinuxInfo::has_capability_info() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void LinuxInfo::set_has_capability_info() {
  _has_bits_[0] |= 0x00000001u;
}
void LinuxInfo::clear_has_capability_info() {
  _has_bits_[0] &= ~0x00000001u;
}
void LinuxInfo::clear_capability_info() {
  if (capability_info_ != NULL) capability_info_->::mesos::CapabilityInfo::Clear();
  clear_has_capability_info();
}
const ::mesos::CapabilityInfo& LinuxInfo::capability_info() const {
  // @@protoc_insertion_point(field_get:mesos.LinuxInfo.capability_info)
  return capability_info_ != NULL ? *capability_info_ : *default_instance_->capability_info_;
}
::mesos::CapabilityInfo* LinuxInfo::mutable_capability_info() {
  set_has_capability_info();
  if (capability_info_ == NULL) {
    capability_info_ = new ::mesos::CapabilityInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.LinuxInfo.capability_info)
  return capability_info_;
}
::mesos::CapabilityInfo* LinuxInfo::release_capability_info() {
  // @@protoc_insertion_point(field_release:mesos.LinuxInfo.capability_info)
  clear_has_capability_info();
  ::mesos::CapabilityInfo* temp = capability_info_;
  capability_info_ = NULL;
  return temp;
}
void LinuxInfo::set_allocated_capability_info(::mesos::CapabilityInfo* capability_info) {
  delete capability_info_;
  capability_info_ = capability_info;
  if (capability_info) {
    set_has_capability_info();
  } else {
    clear_has_capability_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.LinuxInfo.capability_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* RLimitInfo_RLimit_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RLimitInfo_RLimit_Type_descriptor_;
}
bool RLimitInfo_RLimit_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::UNKNOWN;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_AS;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_CORE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_CPU;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_DATA;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_FSIZE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_LOCKS;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_MEMLOCK;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_MSGQUEUE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_NICE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_NOFILE;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_NPROC;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_RSS;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_RTPRIO;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_RTTIME;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_SIGPENDING;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::RLMT_STACK;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::Type_MIN;
const RLimitInfo_RLimit_Type RLimitInfo_RLimit::Type_MAX;
const int RLimitInfo_RLimit::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RLimitInfo_RLimit::kTypeFieldNumber;
const int RLimitInfo_RLimit::kHardFieldNumber;
const int RLimitInfo_RLimit::kSoftFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RLimitInfo_RLimit::RLimitInfo_RLimit()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RLimitInfo.RLimit)
}

void RLimitInfo_RLimit::InitAsDefaultInstance() {
}

RLimitInfo_RLimit::RLimitInfo_RLimit(const RLimitInfo_RLimit& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RLimitInfo.RLimit)
}

void RLimitInfo_RLimit::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  hard_ = GOOGLE_ULONGLONG(0);
  soft_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RLimitInfo_RLimit::~RLimitInfo_RLimit() {
  // @@protoc_insertion_point(destructor:mesos.RLimitInfo.RLimit)
  SharedDtor();
}

void RLimitInfo_RLimit::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RLimitInfo_RLimit::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RLimitInfo_RLimit::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RLimitInfo_RLimit_descriptor_;
}

const RLimitInfo_RLimit& RLimitInfo_RLimit::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RLimitInfo_RLimit* RLimitInfo_RLimit::default_instance_ = NULL;

RLimitInfo_RLimit* RLimitInfo_RLimit::New(::google::protobuf::Arena* arena) const {
  RLimitInfo_RLimit* n = new RLimitInfo_RLimit;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RLimitInfo_RLimit::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.RLimitInfo.RLimit)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(RLimitInfo_RLimit, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<RLimitInfo_RLimit*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(hard_, type_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RLimitInfo_RLimit::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RLimitInfo.RLimit)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.RLimitInfo.RLimit.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::RLimitInfo_RLimit_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::RLimitInfo_RLimit_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_hard;
        break;
      }

      // optional uint64 hard = 2;
      case 2: {
        if (tag == 16) {
         parse_hard:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &hard_)));
          set_has_hard();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_soft;
        break;
      }

      // optional uint64 soft = 3;
      case 3: {
        if (tag == 24) {
         parse_soft:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &soft_)));
          set_has_soft();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RLimitInfo.RLimit)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RLimitInfo.RLimit)
  return false;
#undef DO_
}

void RLimitInfo_RLimit::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RLimitInfo.RLimit)
  // optional .mesos.RLimitInfo.RLimit.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional uint64 hard = 2;
  if (has_hard()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(2, this->hard(), output);
  }

  // optional uint64 soft = 3;
  if (has_soft()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->soft(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RLimitInfo.RLimit)
}

::google::protobuf::uint8* RLimitInfo_RLimit::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RLimitInfo.RLimit)
  // optional .mesos.RLimitInfo.RLimit.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional uint64 hard = 2;
  if (has_hard()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(2, this->hard(), target);
  }

  // optional uint64 soft = 3;
  if (has_soft()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->soft(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RLimitInfo.RLimit)
  return target;
}

int RLimitInfo_RLimit::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.RLimitInfo.RLimit)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 7u) {
    // optional .mesos.RLimitInfo.RLimit.Type type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional uint64 hard = 2;
    if (has_hard()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->hard());
    }

    // optional uint64 soft = 3;
    if (has_soft()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->soft());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RLimitInfo_RLimit::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.RLimitInfo.RLimit)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RLimitInfo_RLimit* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RLimitInfo_RLimit>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.RLimitInfo.RLimit)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.RLimitInfo.RLimit)
    MergeFrom(*source);
  }
}

void RLimitInfo_RLimit::MergeFrom(const RLimitInfo_RLimit& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.RLimitInfo.RLimit)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_hard()) {
      set_hard(from.hard());
    }
    if (from.has_soft()) {
      set_soft(from.soft());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RLimitInfo_RLimit::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.RLimitInfo.RLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RLimitInfo_RLimit::CopyFrom(const RLimitInfo_RLimit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.RLimitInfo.RLimit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RLimitInfo_RLimit::IsInitialized() const {

  return true;
}

void RLimitInfo_RLimit::Swap(RLimitInfo_RLimit* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RLimitInfo_RLimit::InternalSwap(RLimitInfo_RLimit* other) {
  std::swap(type_, other->type_);
  std::swap(hard_, other->hard_);
  std::swap(soft_, other->soft_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RLimitInfo_RLimit::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RLimitInfo_RLimit_descriptor_;
  metadata.reflection = RLimitInfo_RLimit_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RLimitInfo::kRlimitsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RLimitInfo::RLimitInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.RLimitInfo)
}

void RLimitInfo::InitAsDefaultInstance() {
}

RLimitInfo::RLimitInfo(const RLimitInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.RLimitInfo)
}

void RLimitInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RLimitInfo::~RLimitInfo() {
  // @@protoc_insertion_point(destructor:mesos.RLimitInfo)
  SharedDtor();
}

void RLimitInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RLimitInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RLimitInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RLimitInfo_descriptor_;
}

const RLimitInfo& RLimitInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

RLimitInfo* RLimitInfo::default_instance_ = NULL;

RLimitInfo* RLimitInfo::New(::google::protobuf::Arena* arena) const {
  RLimitInfo* n = new RLimitInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RLimitInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.RLimitInfo)
  rlimits_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool RLimitInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.RLimitInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_rlimits:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_rlimits()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_rlimits;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.RLimitInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.RLimitInfo)
  return false;
#undef DO_
}

void RLimitInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.RLimitInfo)
  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  for (unsigned int i = 0, n = this->rlimits_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rlimits(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.RLimitInfo)
}

::google::protobuf::uint8* RLimitInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.RLimitInfo)
  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  for (unsigned int i = 0, n = this->rlimits_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->rlimits(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.RLimitInfo)
  return target;
}

int RLimitInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.RLimitInfo)
  int total_size = 0;

  // repeated .mesos.RLimitInfo.RLimit rlimits = 1;
  total_size += 1 * this->rlimits_size();
  for (int i = 0; i < this->rlimits_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rlimits(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RLimitInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.RLimitInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RLimitInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RLimitInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.RLimitInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.RLimitInfo)
    MergeFrom(*source);
  }
}

void RLimitInfo::MergeFrom(const RLimitInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.RLimitInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  rlimits_.MergeFrom(from.rlimits_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void RLimitInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.RLimitInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RLimitInfo::CopyFrom(const RLimitInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.RLimitInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RLimitInfo::IsInitialized() const {

  return true;
}

void RLimitInfo::Swap(RLimitInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RLimitInfo::InternalSwap(RLimitInfo* other) {
  rlimits_.UnsafeArenaSwap(&other->rlimits_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RLimitInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RLimitInfo_descriptor_;
  metadata.reflection = RLimitInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RLimitInfo_RLimit

// optional .mesos.RLimitInfo.RLimit.Type type = 1;
bool RLimitInfo_RLimit::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void RLimitInfo_RLimit::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void RLimitInfo_RLimit::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void RLimitInfo_RLimit::clear_type() {
  type_ = 0;
  clear_has_type();
}
 ::mesos::RLimitInfo_RLimit_Type RLimitInfo_RLimit::type() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.type)
  return static_cast< ::mesos::RLimitInfo_RLimit_Type >(type_);
}
 void RLimitInfo_RLimit::set_type(::mesos::RLimitInfo_RLimit_Type value) {
  assert(::mesos::RLimitInfo_RLimit_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.type)
}

// optional uint64 hard = 2;
bool RLimitInfo_RLimit::has_hard() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void RLimitInfo_RLimit::set_has_hard() {
  _has_bits_[0] |= 0x00000002u;
}
void RLimitInfo_RLimit::clear_has_hard() {
  _has_bits_[0] &= ~0x00000002u;
}
void RLimitInfo_RLimit::clear_hard() {
  hard_ = GOOGLE_ULONGLONG(0);
  clear_has_hard();
}
 ::google::protobuf::uint64 RLimitInfo_RLimit::hard() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.hard)
  return hard_;
}
 void RLimitInfo_RLimit::set_hard(::google::protobuf::uint64 value) {
  set_has_hard();
  hard_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.hard)
}

// optional uint64 soft = 3;
bool RLimitInfo_RLimit::has_soft() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void RLimitInfo_RLimit::set_has_soft() {
  _has_bits_[0] |= 0x00000004u;
}
void RLimitInfo_RLimit::clear_has_soft() {
  _has_bits_[0] &= ~0x00000004u;
}
void RLimitInfo_RLimit::clear_soft() {
  soft_ = GOOGLE_ULONGLONG(0);
  clear_has_soft();
}
 ::google::protobuf::uint64 RLimitInfo_RLimit::soft() const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.RLimit.soft)
  return soft_;
}
 void RLimitInfo_RLimit::set_soft(::google::protobuf::uint64 value) {
  set_has_soft();
  soft_ = value;
  // @@protoc_insertion_point(field_set:mesos.RLimitInfo.RLimit.soft)
}

// -------------------------------------------------------------------

// RLimitInfo

// repeated .mesos.RLimitInfo.RLimit rlimits = 1;
int RLimitInfo::rlimits_size() const {
  return rlimits_.size();
}
void RLimitInfo::clear_rlimits() {
  rlimits_.Clear();
}
const ::mesos::RLimitInfo_RLimit& RLimitInfo::rlimits(int index) const {
  // @@protoc_insertion_point(field_get:mesos.RLimitInfo.rlimits)
  return rlimits_.Get(index);
}
::mesos::RLimitInfo_RLimit* RLimitInfo::mutable_rlimits(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.RLimitInfo.rlimits)
  return rlimits_.Mutable(index);
}
::mesos::RLimitInfo_RLimit* RLimitInfo::add_rlimits() {
  // @@protoc_insertion_point(field_add:mesos.RLimitInfo.rlimits)
  return rlimits_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >*
RLimitInfo::mutable_rlimits() {
  // @@protoc_insertion_point(field_mutable_list:mesos.RLimitInfo.rlimits)
  return &rlimits_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::RLimitInfo_RLimit >&
RLimitInfo::rlimits() const {
  // @@protoc_insertion_point(field_list:mesos.RLimitInfo.rlimits)
  return rlimits_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TTYInfo_WindowSize::kRowsFieldNumber;
const int TTYInfo_WindowSize::kColumnsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TTYInfo_WindowSize::TTYInfo_WindowSize()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TTYInfo.WindowSize)
}

void TTYInfo_WindowSize::InitAsDefaultInstance() {
}

TTYInfo_WindowSize::TTYInfo_WindowSize(const TTYInfo_WindowSize& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TTYInfo.WindowSize)
}

void TTYInfo_WindowSize::SharedCtor() {
  _cached_size_ = 0;
  rows_ = 0u;
  columns_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TTYInfo_WindowSize::~TTYInfo_WindowSize() {
  // @@protoc_insertion_point(destructor:mesos.TTYInfo.WindowSize)
  SharedDtor();
}

void TTYInfo_WindowSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TTYInfo_WindowSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TTYInfo_WindowSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TTYInfo_WindowSize_descriptor_;
}

const TTYInfo_WindowSize& TTYInfo_WindowSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TTYInfo_WindowSize* TTYInfo_WindowSize::default_instance_ = NULL;

TTYInfo_WindowSize* TTYInfo_WindowSize::New(::google::protobuf::Arena* arena) const {
  TTYInfo_WindowSize* n = new TTYInfo_WindowSize;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TTYInfo_WindowSize::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TTYInfo.WindowSize)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(TTYInfo_WindowSize, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<TTYInfo_WindowSize*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(rows_, columns_);

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TTYInfo_WindowSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TTYInfo.WindowSize)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 rows = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &rows_)));
          set_has_rows();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_columns;
        break;
      }

      // required uint32 columns = 2;
      case 2: {
        if (tag == 16) {
         parse_columns:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &columns_)));
          set_has_columns();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TTYInfo.WindowSize)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TTYInfo.WindowSize)
  return false;
#undef DO_
}

void TTYInfo_WindowSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TTYInfo.WindowSize)
  // required uint32 rows = 1;
  if (has_rows()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->rows(), output);
  }

  // required uint32 columns = 2;
  if (has_columns()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->columns(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TTYInfo.WindowSize)
}

::google::protobuf::uint8* TTYInfo_WindowSize::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TTYInfo.WindowSize)
  // required uint32 rows = 1;
  if (has_rows()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->rows(), target);
  }

  // required uint32 columns = 2;
  if (has_columns()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->columns(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TTYInfo.WindowSize)
  return target;
}

int TTYInfo_WindowSize::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.TTYInfo.WindowSize)
  int total_size = 0;

  if (has_rows()) {
    // required uint32 rows = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->rows());
  }

  if (has_columns()) {
    // required uint32 columns = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->columns());
  }

  return total_size;
}
int TTYInfo_WindowSize::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TTYInfo.WindowSize)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 rows = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->rows());

    // required uint32 columns = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->columns());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TTYInfo_WindowSize::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TTYInfo.WindowSize)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TTYInfo_WindowSize* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TTYInfo_WindowSize>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TTYInfo.WindowSize)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TTYInfo.WindowSize)
    MergeFrom(*source);
  }
}

void TTYInfo_WindowSize::MergeFrom(const TTYInfo_WindowSize& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TTYInfo.WindowSize)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_rows()) {
      set_rows(from.rows());
    }
    if (from.has_columns()) {
      set_columns(from.columns());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TTYInfo_WindowSize::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TTYInfo.WindowSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TTYInfo_WindowSize::CopyFrom(const TTYInfo_WindowSize& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TTYInfo.WindowSize)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTYInfo_WindowSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void TTYInfo_WindowSize::Swap(TTYInfo_WindowSize* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TTYInfo_WindowSize::InternalSwap(TTYInfo_WindowSize* other) {
  std::swap(rows_, other->rows_);
  std::swap(columns_, other->columns_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TTYInfo_WindowSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TTYInfo_WindowSize_descriptor_;
  metadata.reflection = TTYInfo_WindowSize_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TTYInfo::kWindowSizeFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TTYInfo::TTYInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.TTYInfo)
}

void TTYInfo::InitAsDefaultInstance() {
  window_size_ = const_cast< ::mesos::TTYInfo_WindowSize*>(&::mesos::TTYInfo_WindowSize::default_instance());
}

TTYInfo::TTYInfo(const TTYInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.TTYInfo)
}

void TTYInfo::SharedCtor() {
  _cached_size_ = 0;
  window_size_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TTYInfo::~TTYInfo() {
  // @@protoc_insertion_point(destructor:mesos.TTYInfo)
  SharedDtor();
}

void TTYInfo::SharedDtor() {
  if (this != default_instance_) {
    delete window_size_;
  }
}

void TTYInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TTYInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TTYInfo_descriptor_;
}

const TTYInfo& TTYInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

TTYInfo* TTYInfo::default_instance_ = NULL;

TTYInfo* TTYInfo::New(::google::protobuf::Arena* arena) const {
  TTYInfo* n = new TTYInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TTYInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.TTYInfo)
  if (has_window_size()) {
    if (window_size_ != NULL) window_size_->::mesos::TTYInfo_WindowSize::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool TTYInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.TTYInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.TTYInfo.WindowSize window_size = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_window_size()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.TTYInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.TTYInfo)
  return false;
#undef DO_
}

void TTYInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.TTYInfo)
  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  if (has_window_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->window_size_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.TTYInfo)
}

::google::protobuf::uint8* TTYInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.TTYInfo)
  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  if (has_window_size()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->window_size_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.TTYInfo)
  return target;
}

int TTYInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.TTYInfo)
  int total_size = 0;

  // optional .mesos.TTYInfo.WindowSize window_size = 1;
  if (has_window_size()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->window_size_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TTYInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.TTYInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const TTYInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const TTYInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.TTYInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.TTYInfo)
    MergeFrom(*source);
  }
}

void TTYInfo::MergeFrom(const TTYInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.TTYInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_window_size()) {
      mutable_window_size()->::mesos::TTYInfo_WindowSize::MergeFrom(from.window_size());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void TTYInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.TTYInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TTYInfo::CopyFrom(const TTYInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.TTYInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TTYInfo::IsInitialized() const {

  if (has_window_size()) {
    if (!this->window_size_->IsInitialized()) return false;
  }
  return true;
}

void TTYInfo::Swap(TTYInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TTYInfo::InternalSwap(TTYInfo* other) {
  std::swap(window_size_, other->window_size_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TTYInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TTYInfo_descriptor_;
  metadata.reflection = TTYInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TTYInfo_WindowSize

// required uint32 rows = 1;
bool TTYInfo_WindowSize::has_rows() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TTYInfo_WindowSize::set_has_rows() {
  _has_bits_[0] |= 0x00000001u;
}
void TTYInfo_WindowSize::clear_has_rows() {
  _has_bits_[0] &= ~0x00000001u;
}
void TTYInfo_WindowSize::clear_rows() {
  rows_ = 0u;
  clear_has_rows();
}
 ::google::protobuf::uint32 TTYInfo_WindowSize::rows() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.WindowSize.rows)
  return rows_;
}
 void TTYInfo_WindowSize::set_rows(::google::protobuf::uint32 value) {
  set_has_rows();
  rows_ = value;
  // @@protoc_insertion_point(field_set:mesos.TTYInfo.WindowSize.rows)
}

// required uint32 columns = 2;
bool TTYInfo_WindowSize::has_columns() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void TTYInfo_WindowSize::set_has_columns() {
  _has_bits_[0] |= 0x00000002u;
}
void TTYInfo_WindowSize::clear_has_columns() {
  _has_bits_[0] &= ~0x00000002u;
}
void TTYInfo_WindowSize::clear_columns() {
  columns_ = 0u;
  clear_has_columns();
}
 ::google::protobuf::uint32 TTYInfo_WindowSize::columns() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.WindowSize.columns)
  return columns_;
}
 void TTYInfo_WindowSize::set_columns(::google::protobuf::uint32 value) {
  set_has_columns();
  columns_ = value;
  // @@protoc_insertion_point(field_set:mesos.TTYInfo.WindowSize.columns)
}

// -------------------------------------------------------------------

// TTYInfo

// optional .mesos.TTYInfo.WindowSize window_size = 1;
bool TTYInfo::has_window_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void TTYInfo::set_has_window_size() {
  _has_bits_[0] |= 0x00000001u;
}
void TTYInfo::clear_has_window_size() {
  _has_bits_[0] &= ~0x00000001u;
}
void TTYInfo::clear_window_size() {
  if (window_size_ != NULL) window_size_->::mesos::TTYInfo_WindowSize::Clear();
  clear_has_window_size();
}
const ::mesos::TTYInfo_WindowSize& TTYInfo::window_size() const {
  // @@protoc_insertion_point(field_get:mesos.TTYInfo.window_size)
  return window_size_ != NULL ? *window_size_ : *default_instance_->window_size_;
}
::mesos::TTYInfo_WindowSize* TTYInfo::mutable_window_size() {
  set_has_window_size();
  if (window_size_ == NULL) {
    window_size_ = new ::mesos::TTYInfo_WindowSize;
  }
  // @@protoc_insertion_point(field_mutable:mesos.TTYInfo.window_size)
  return window_size_;
}
::mesos::TTYInfo_WindowSize* TTYInfo::release_window_size() {
  // @@protoc_insertion_point(field_release:mesos.TTYInfo.window_size)
  clear_has_window_size();
  ::mesos::TTYInfo_WindowSize* temp = window_size_;
  window_size_ = NULL;
  return temp;
}
void TTYInfo::set_allocated_window_size(::mesos::TTYInfo_WindowSize* window_size) {
  delete window_size_;
  window_size_ = window_size;
  if (window_size) {
    set_has_window_size();
  } else {
    clear_has_window_size();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.TTYInfo.window_size)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* ContainerInfo_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_Type_descriptor_;
}
bool ContainerInfo_Type_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ContainerInfo_Type ContainerInfo::DOCKER;
const ContainerInfo_Type ContainerInfo::MESOS;
const ContainerInfo_Type ContainerInfo::Type_MIN;
const ContainerInfo_Type ContainerInfo::Type_MAX;
const int ContainerInfo::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
const ::google::protobuf::EnumDescriptor* ContainerInfo_DockerInfo_Network_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_DockerInfo_Network_descriptor_;
}
bool ContainerInfo_DockerInfo_Network_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::HOST;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::BRIDGE;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::NONE;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::USER;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::Network_MIN;
const ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::Network_MAX;
const int ContainerInfo_DockerInfo::Network_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContainerInfo_DockerInfo_PortMapping::kHostPortFieldNumber;
const int ContainerInfo_DockerInfo_PortMapping::kContainerPortFieldNumber;
const int ContainerInfo_DockerInfo_PortMapping::kProtocolFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContainerInfo_DockerInfo_PortMapping::ContainerInfo_DockerInfo_PortMapping()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo.DockerInfo.PortMapping)
}

void ContainerInfo_DockerInfo_PortMapping::InitAsDefaultInstance() {
}

ContainerInfo_DockerInfo_PortMapping::ContainerInfo_DockerInfo_PortMapping(const ContainerInfo_DockerInfo_PortMapping& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo.DockerInfo.PortMapping)
}

void ContainerInfo_DockerInfo_PortMapping::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  host_port_ = 0u;
  container_port_ = 0u;
  protocol_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo_DockerInfo_PortMapping::~ContainerInfo_DockerInfo_PortMapping() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo.DockerInfo.PortMapping)
  SharedDtor();
}

void ContainerInfo_DockerInfo_PortMapping::SharedDtor() {
  protocol_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ContainerInfo_DockerInfo_PortMapping::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo_PortMapping::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_DockerInfo_PortMapping_descriptor_;
}

const ContainerInfo_DockerInfo_PortMapping& ContainerInfo_DockerInfo_PortMapping::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo_PortMapping::default_instance_ = NULL;

ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo_PortMapping::New(::google::protobuf::Arena* arena) const {
  ContainerInfo_DockerInfo_PortMapping* n = new ContainerInfo_DockerInfo_PortMapping;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ContainerInfo_DockerInfo_PortMapping::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ContainerInfo.DockerInfo.PortMapping)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ContainerInfo_DockerInfo_PortMapping, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ContainerInfo_DockerInfo_PortMapping*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 7u) {
    ZR_(host_port_, container_port_);
    if (has_protocol()) {
      protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ContainerInfo_DockerInfo_PortMapping::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 host_port = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &host_port_)));
          set_has_host_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_container_port;
        break;
      }

      // required uint32 container_port = 2;
      case 2: {
        if (tag == 16) {
         parse_container_port:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &container_port_)));
          set_has_container_port();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_protocol;
        break;
      }

      // optional string protocol = 3;
      case 3: {
        if (tag == 26) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->protocol().data(), this->protocol().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ContainerInfo.DockerInfo.PortMapping.protocol");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo.DockerInfo.PortMapping)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo.DockerInfo.PortMapping)
  return false;
#undef DO_
}

void ContainerInfo_DockerInfo_PortMapping::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->host_port(), output);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(2, this->container_port(), output);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.DockerInfo.PortMapping.protocol");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->protocol(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo.DockerInfo.PortMapping)
}

::google::protobuf::uint8* ContainerInfo_DockerInfo_PortMapping::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  // required uint32 host_port = 1;
  if (has_host_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->host_port(), target);
  }

  // required uint32 container_port = 2;
  if (has_container_port()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(2, this->container_port(), target);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.DockerInfo.PortMapping.protocol");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->protocol(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo.DockerInfo.PortMapping)
  return target;
}

int ContainerInfo_DockerInfo_PortMapping::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  int total_size = 0;

  if (has_host_port()) {
    // required uint32 host_port = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->host_port());
  }

  if (has_container_port()) {
    // required uint32 container_port = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->container_port());
  }

  return total_size;
}
int ContainerInfo_DockerInfo_PortMapping::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint32 host_port = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->host_port());

    // required uint32 container_port = 2;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->container_port());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // optional string protocol = 3;
  if (has_protocol()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->protocol());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo_DockerInfo_PortMapping::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ContainerInfo_DockerInfo_PortMapping* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ContainerInfo_DockerInfo_PortMapping>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ContainerInfo.DockerInfo.PortMapping)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ContainerInfo.DockerInfo.PortMapping)
    MergeFrom(*source);
  }
}

void ContainerInfo_DockerInfo_PortMapping::MergeFrom(const ContainerInfo_DockerInfo_PortMapping& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_host_port()) {
      set_host_port(from.host_port());
    }
    if (from.has_container_port()) {
      set_container_port(from.container_port());
    }
    if (from.has_protocol()) {
      set_has_protocol();
      protocol_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.protocol_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ContainerInfo_DockerInfo_PortMapping::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo_DockerInfo_PortMapping::CopyFrom(const ContainerInfo_DockerInfo_PortMapping& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ContainerInfo.DockerInfo.PortMapping)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo_DockerInfo_PortMapping::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void ContainerInfo_DockerInfo_PortMapping::Swap(ContainerInfo_DockerInfo_PortMapping* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContainerInfo_DockerInfo_PortMapping::InternalSwap(ContainerInfo_DockerInfo_PortMapping* other) {
  std::swap(host_port_, other->host_port_);
  std::swap(container_port_, other->container_port_);
  protocol_.Swap(&other->protocol_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ContainerInfo_DockerInfo_PortMapping::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_DockerInfo_PortMapping_descriptor_;
  metadata.reflection = ContainerInfo_DockerInfo_PortMapping_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContainerInfo_DockerInfo::kImageFieldNumber;
const int ContainerInfo_DockerInfo::kNetworkFieldNumber;
const int ContainerInfo_DockerInfo::kPortMappingsFieldNumber;
const int ContainerInfo_DockerInfo::kPrivilegedFieldNumber;
const int ContainerInfo_DockerInfo::kParametersFieldNumber;
const int ContainerInfo_DockerInfo::kForcePullImageFieldNumber;
const int ContainerInfo_DockerInfo::kVolumeDriverFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContainerInfo_DockerInfo::ContainerInfo_DockerInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo.DockerInfo)
}

void ContainerInfo_DockerInfo::InitAsDefaultInstance() {
}

ContainerInfo_DockerInfo::ContainerInfo_DockerInfo(const ContainerInfo_DockerInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo.DockerInfo)
}

void ContainerInfo_DockerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  image_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  network_ = 1;
  privileged_ = false;
  force_pull_image_ = false;
  volume_driver_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo_DockerInfo::~ContainerInfo_DockerInfo() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo.DockerInfo)
  SharedDtor();
}

void ContainerInfo_DockerInfo::SharedDtor() {
  image_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  volume_driver_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ContainerInfo_DockerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo_DockerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_DockerInfo_descriptor_;
}

const ContainerInfo_DockerInfo& ContainerInfo_DockerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo_DockerInfo* ContainerInfo_DockerInfo::default_instance_ = NULL;

ContainerInfo_DockerInfo* ContainerInfo_DockerInfo::New(::google::protobuf::Arena* arena) const {
  ContainerInfo_DockerInfo* n = new ContainerInfo_DockerInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ContainerInfo_DockerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ContainerInfo.DockerInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(ContainerInfo_DockerInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<ContainerInfo_DockerInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 107u) {
    ZR_(privileged_, force_pull_image_);
    if (has_image()) {
      image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    network_ = 1;
    if (has_volume_driver()) {
      volume_driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  port_mappings_.Clear();
  parameters_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ContainerInfo_DockerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo.DockerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string image = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_image()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->image().data(), this->image().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ContainerInfo.DockerInfo.image");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_network;
        break;
      }

      // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
      case 2: {
        if (tag == 16) {
         parse_network:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::ContainerInfo_DockerInfo_Network_IsValid(value)) {
            set_network(static_cast< ::mesos::ContainerInfo_DockerInfo_Network >(value));
          } else {
            mutable_unknown_fields()->AddVarint(2, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_port_mappings;
        break;
      }

      // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
      case 3: {
        if (tag == 26) {
         parse_port_mappings:
          DO_(input->IncrementRecursionDepth());
         parse_loop_port_mappings:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_port_mappings()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_port_mappings;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(32)) goto parse_privileged;
        break;
      }

      // optional bool privileged = 4 [default = false];
      case 4: {
        if (tag == 32) {
         parse_privileged:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &privileged_)));
          set_has_privileged();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_parameters;
        break;
      }

      // repeated .mesos.Parameter parameters = 5;
      case 5: {
        if (tag == 42) {
         parse_parameters:
          DO_(input->IncrementRecursionDepth());
         parse_loop_parameters:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_parameters()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_loop_parameters;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(48)) goto parse_force_pull_image;
        break;
      }

      // optional bool force_pull_image = 6;
      case 6: {
        if (tag == 48) {
         parse_force_pull_image:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &force_pull_image_)));
          set_has_force_pull_image();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_volume_driver;
        break;
      }

      // optional string volume_driver = 7 [deprecated = true];
      case 7: {
        if (tag == 58) {
         parse_volume_driver:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_volume_driver()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->volume_driver().data(), this->volume_driver().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ContainerInfo.DockerInfo.volume_driver");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo.DockerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo.DockerInfo)
  return false;
#undef DO_
}

void ContainerInfo_DockerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo.DockerInfo)
  // required string image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->image().data(), this->image().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.DockerInfo.image");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->image(), output);
  }

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  if (has_network()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      2, this->network(), output);
  }

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  for (unsigned int i = 0, n = this->port_mappings_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->port_mappings(i), output);
  }

  // optional bool privileged = 4 [default = false];
  if (has_privileged()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(4, this->privileged(), output);
  }

  // repeated .mesos.Parameter parameters = 5;
  for (unsigned int i = 0, n = this->parameters_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->parameters(i), output);
  }

  // optional bool force_pull_image = 6;
  if (has_force_pull_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->force_pull_image(), output);
  }

  // optional string volume_driver = 7 [deprecated = true];
  if (has_volume_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->volume_driver().data(), this->volume_driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.DockerInfo.volume_driver");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->volume_driver(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo.DockerInfo)
}

::google::protobuf::uint8* ContainerInfo_DockerInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo.DockerInfo)
  // required string image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->image().data(), this->image().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.DockerInfo.image");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->image(), target);
  }

  // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
  if (has_network()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      2, this->network(), target);
  }

  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  for (unsigned int i = 0, n = this->port_mappings_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->port_mappings(i), false, target);
  }

  // optional bool privileged = 4 [default = false];
  if (has_privileged()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(4, this->privileged(), target);
  }

  // repeated .mesos.Parameter parameters = 5;
  for (unsigned int i = 0, n = this->parameters_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, this->parameters(i), false, target);
  }

  // optional bool force_pull_image = 6;
  if (has_force_pull_image()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->force_pull_image(), target);
  }

  // optional string volume_driver = 7 [deprecated = true];
  if (has_volume_driver()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->volume_driver().data(), this->volume_driver().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.DockerInfo.volume_driver");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->volume_driver(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo.DockerInfo)
  return target;
}

int ContainerInfo_DockerInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ContainerInfo.DockerInfo)
  int total_size = 0;

  // required string image = 1;
  if (has_image()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->image());
  }
  if (_has_bits_[1 / 32] & 106u) {
    // optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
    if (has_network()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->network());
    }

    // optional bool privileged = 4 [default = false];
    if (has_privileged()) {
      total_size += 1 + 1;
    }

    // optional bool force_pull_image = 6;
    if (has_force_pull_image()) {
      total_size += 1 + 1;
    }

    // optional string volume_driver = 7 [deprecated = true];
    if (has_volume_driver()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->volume_driver());
    }

  }
  // repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
  total_size += 1 * this->port_mappings_size();
  for (int i = 0; i < this->port_mappings_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->port_mappings(i));
  }

  // repeated .mesos.Parameter parameters = 5;
  total_size += 1 * this->parameters_size();
  for (int i = 0; i < this->parameters_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->parameters(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo_DockerInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ContainerInfo.DockerInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ContainerInfo_DockerInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ContainerInfo_DockerInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ContainerInfo.DockerInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ContainerInfo.DockerInfo)
    MergeFrom(*source);
  }
}

void ContainerInfo_DockerInfo::MergeFrom(const ContainerInfo_DockerInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ContainerInfo.DockerInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  port_mappings_.MergeFrom(from.port_mappings_);
  parameters_.MergeFrom(from.parameters_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      set_has_image();
      image_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.image_);
    }
    if (from.has_network()) {
      set_network(from.network());
    }
    if (from.has_privileged()) {
      set_privileged(from.privileged());
    }
    if (from.has_force_pull_image()) {
      set_force_pull_image(from.force_pull_image());
    }
    if (from.has_volume_driver()) {
      set_has_volume_driver();
      volume_driver_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.volume_driver_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ContainerInfo_DockerInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ContainerInfo.DockerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo_DockerInfo::CopyFrom(const ContainerInfo_DockerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ContainerInfo.DockerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo_DockerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->port_mappings())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->parameters())) return false;
  return true;
}

void ContainerInfo_DockerInfo::Swap(ContainerInfo_DockerInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContainerInfo_DockerInfo::InternalSwap(ContainerInfo_DockerInfo* other) {
  image_.Swap(&other->image_);
  std::swap(network_, other->network_);
  port_mappings_.UnsafeArenaSwap(&other->port_mappings_);
  std::swap(privileged_, other->privileged_);
  parameters_.UnsafeArenaSwap(&other->parameters_);
  std::swap(force_pull_image_, other->force_pull_image_);
  volume_driver_.Swap(&other->volume_driver_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ContainerInfo_DockerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_DockerInfo_descriptor_;
  metadata.reflection = ContainerInfo_DockerInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContainerInfo_MesosInfo::kImageFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContainerInfo_MesosInfo::ContainerInfo_MesosInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo.MesosInfo)
}

void ContainerInfo_MesosInfo::InitAsDefaultInstance() {
  image_ = const_cast< ::mesos::Image*>(&::mesos::Image::default_instance());
}

ContainerInfo_MesosInfo::ContainerInfo_MesosInfo(const ContainerInfo_MesosInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo.MesosInfo)
}

void ContainerInfo_MesosInfo::SharedCtor() {
  _cached_size_ = 0;
  image_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo_MesosInfo::~ContainerInfo_MesosInfo() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo.MesosInfo)
  SharedDtor();
}

void ContainerInfo_MesosInfo::SharedDtor() {
  if (this != default_instance_) {
    delete image_;
  }
}

void ContainerInfo_MesosInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo_MesosInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_MesosInfo_descriptor_;
}

const ContainerInfo_MesosInfo& ContainerInfo_MesosInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo_MesosInfo* ContainerInfo_MesosInfo::default_instance_ = NULL;

ContainerInfo_MesosInfo* ContainerInfo_MesosInfo::New(::google::protobuf::Arena* arena) const {
  ContainerInfo_MesosInfo* n = new ContainerInfo_MesosInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ContainerInfo_MesosInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ContainerInfo.MesosInfo)
  if (has_image()) {
    if (image_ != NULL) image_->::mesos::Image::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ContainerInfo_MesosInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo.MesosInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.Image image = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo.MesosInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo.MesosInfo)
  return false;
#undef DO_
}

void ContainerInfo_MesosInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo.MesosInfo)
  // optional .mesos.Image image = 1;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->image_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo.MesosInfo)
}

::google::protobuf::uint8* ContainerInfo_MesosInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo.MesosInfo)
  // optional .mesos.Image image = 1;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->image_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo.MesosInfo)
  return target;
}

int ContainerInfo_MesosInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ContainerInfo.MesosInfo)
  int total_size = 0;

  // optional .mesos.Image image = 1;
  if (has_image()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->image_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo_MesosInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ContainerInfo.MesosInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ContainerInfo_MesosInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ContainerInfo_MesosInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ContainerInfo.MesosInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ContainerInfo.MesosInfo)
    MergeFrom(*source);
  }
}

void ContainerInfo_MesosInfo::MergeFrom(const ContainerInfo_MesosInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ContainerInfo.MesosInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_image()) {
      mutable_image()->::mesos::Image::MergeFrom(from.image());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ContainerInfo_MesosInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ContainerInfo.MesosInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo_MesosInfo::CopyFrom(const ContainerInfo_MesosInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ContainerInfo.MesosInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo_MesosInfo::IsInitialized() const {

  if (has_image()) {
    if (!this->image_->IsInitialized()) return false;
  }
  return true;
}

void ContainerInfo_MesosInfo::Swap(ContainerInfo_MesosInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContainerInfo_MesosInfo::InternalSwap(ContainerInfo_MesosInfo* other) {
  std::swap(image_, other->image_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ContainerInfo_MesosInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_MesosInfo_descriptor_;
  metadata.reflection = ContainerInfo_MesosInfo_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContainerInfo::kTypeFieldNumber;
const int ContainerInfo::kVolumesFieldNumber;
const int ContainerInfo::kHostnameFieldNumber;
const int ContainerInfo::kDockerFieldNumber;
const int ContainerInfo::kMesosFieldNumber;
const int ContainerInfo::kNetworkInfosFieldNumber;
const int ContainerInfo::kLinuxInfoFieldNumber;
const int ContainerInfo::kRlimitInfoFieldNumber;
const int ContainerInfo::kTtyInfoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContainerInfo::ContainerInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerInfo)
}

void ContainerInfo::InitAsDefaultInstance() {
  docker_ = const_cast< ::mesos::ContainerInfo_DockerInfo*>(&::mesos::ContainerInfo_DockerInfo::default_instance());
  mesos_ = const_cast< ::mesos::ContainerInfo_MesosInfo*>(&::mesos::ContainerInfo_MesosInfo::default_instance());
  linux_info_ = const_cast< ::mesos::LinuxInfo*>(&::mesos::LinuxInfo::default_instance());
  rlimit_info_ = const_cast< ::mesos::RLimitInfo*>(&::mesos::RLimitInfo::default_instance());
  tty_info_ = const_cast< ::mesos::TTYInfo*>(&::mesos::TTYInfo::default_instance());
}

ContainerInfo::ContainerInfo(const ContainerInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerInfo)
}

void ContainerInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 1;
  hostname_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  docker_ = NULL;
  mesos_ = NULL;
  linux_info_ = NULL;
  rlimit_info_ = NULL;
  tty_info_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerInfo::~ContainerInfo() {
  // @@protoc_insertion_point(destructor:mesos.ContainerInfo)
  SharedDtor();
}

void ContainerInfo::SharedDtor() {
  hostname_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete docker_;
    delete mesos_;
    delete linux_info_;
    delete rlimit_info_;
    delete tty_info_;
  }
}

void ContainerInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerInfo_descriptor_;
}

const ContainerInfo& ContainerInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerInfo* ContainerInfo::default_instance_ = NULL;

ContainerInfo* ContainerInfo::New(::google::protobuf::Arena* arena) const {
  ContainerInfo* n = new ContainerInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ContainerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ContainerInfo)
  if (_has_bits_[0 / 32] & 221u) {
    type_ = 1;
    if (has_hostname()) {
      hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_docker()) {
      if (docker_ != NULL) docker_->::mesos::ContainerInfo_DockerInfo::Clear();
    }
    if (has_mesos()) {
      if (mesos_ != NULL) mesos_->::mesos::ContainerInfo_MesosInfo::Clear();
    }
    if (has_linux_info()) {
      if (linux_info_ != NULL) linux_info_->::mesos::LinuxInfo::Clear();
    }
    if (has_rlimit_info()) {
      if (rlimit_info_ != NULL) rlimit_info_->::mesos::RLimitInfo::Clear();
    }
  }
  if (has_tty_info()) {
    if (tty_info_ != NULL) tty_info_->::mesos::TTYInfo::Clear();
  }
  volumes_.Clear();
  network_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ContainerInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.ContainerInfo.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::ContainerInfo_Type_IsValid(value)) {
            set_type(static_cast< ::mesos::ContainerInfo_Type >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_volumes;
        break;
      }

      // repeated .mesos.Volume volumes = 2;
      case 2: {
        if (tag == 18) {
         parse_volumes:
          DO_(input->IncrementRecursionDepth());
         parse_loop_volumes:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_volumes()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_volumes;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(26)) goto parse_docker;
        break;
      }

      // optional .mesos.ContainerInfo.DockerInfo docker = 3;
      case 3: {
        if (tag == 26) {
         parse_docker:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_docker()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_hostname;
        break;
      }

      // optional string hostname = 4;
      case 4: {
        if (tag == 34) {
         parse_hostname:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_hostname()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->hostname().data(), this->hostname().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.ContainerInfo.hostname");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_mesos;
        break;
      }

      // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
      case 5: {
        if (tag == 42) {
         parse_mesos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mesos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_network_infos;
        break;
      }

      // repeated .mesos.NetworkInfo network_infos = 7;
      case 7: {
        if (tag == 58) {
         parse_network_infos:
          DO_(input->IncrementRecursionDepth());
         parse_loop_network_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_network_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_loop_network_infos;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(66)) goto parse_linux_info;
        break;
      }

      // optional .mesos.LinuxInfo linux_info = 8;
      case 8: {
        if (tag == 66) {
         parse_linux_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_linux_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_rlimit_info;
        break;
      }

      // optional .mesos.RLimitInfo rlimit_info = 9;
      case 9: {
        if (tag == 74) {
         parse_rlimit_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rlimit_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(82)) goto parse_tty_info;
        break;
      }

      // optional .mesos.TTYInfo tty_info = 10;
      case 10: {
        if (tag == 82) {
         parse_tty_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_tty_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerInfo)
  return false;
#undef DO_
}

void ContainerInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerInfo)
  // required .mesos.ContainerInfo.Type type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // repeated .mesos.Volume volumes = 2;
  for (unsigned int i = 0, n = this->volumes_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->volumes(i), output);
  }

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  if (has_docker()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, *this->docker_, output);
  }

  // optional string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.hostname");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->hostname(), output);
  }

  // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
  if (has_mesos()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->mesos_, output);
  }

  // repeated .mesos.NetworkInfo network_infos = 7;
  for (unsigned int i = 0, n = this->network_infos_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->network_infos(i), output);
  }

  // optional .mesos.LinuxInfo linux_info = 8;
  if (has_linux_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, *this->linux_info_, output);
  }

  // optional .mesos.RLimitInfo rlimit_info = 9;
  if (has_rlimit_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, *this->rlimit_info_, output);
  }

  // optional .mesos.TTYInfo tty_info = 10;
  if (has_tty_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, *this->tty_info_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerInfo)
}

::google::protobuf::uint8* ContainerInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerInfo)
  // required .mesos.ContainerInfo.Type type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // repeated .mesos.Volume volumes = 2;
  for (unsigned int i = 0, n = this->volumes_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, this->volumes(i), false, target);
  }

  // optional .mesos.ContainerInfo.DockerInfo docker = 3;
  if (has_docker()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, *this->docker_, false, target);
  }

  // optional string hostname = 4;
  if (has_hostname()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->hostname().data(), this->hostname().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.ContainerInfo.hostname");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->hostname(), target);
  }

  // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
  if (has_mesos()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->mesos_, false, target);
  }

  // repeated .mesos.NetworkInfo network_infos = 7;
  for (unsigned int i = 0, n = this->network_infos_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, this->network_infos(i), false, target);
  }

  // optional .mesos.LinuxInfo linux_info = 8;
  if (has_linux_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        8, *this->linux_info_, false, target);
  }

  // optional .mesos.RLimitInfo rlimit_info = 9;
  if (has_rlimit_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        9, *this->rlimit_info_, false, target);
  }

  // optional .mesos.TTYInfo tty_info = 10;
  if (has_tty_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        10, *this->tty_info_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerInfo)
  return target;
}

int ContainerInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ContainerInfo)
  int total_size = 0;

  // required .mesos.ContainerInfo.Type type = 1;
  if (has_type()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }
  if (_has_bits_[2 / 32] & 220u) {
    // optional string hostname = 4;
    if (has_hostname()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->hostname());
    }

    // optional .mesos.ContainerInfo.DockerInfo docker = 3;
    if (has_docker()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->docker_);
    }

    // optional .mesos.ContainerInfo.MesosInfo mesos = 5;
    if (has_mesos()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mesos_);
    }

    // optional .mesos.LinuxInfo linux_info = 8;
    if (has_linux_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->linux_info_);
    }

    // optional .mesos.RLimitInfo rlimit_info = 9;
    if (has_rlimit_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->rlimit_info_);
    }

  }
  // optional .mesos.TTYInfo tty_info = 10;
  if (has_tty_info()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->tty_info_);
  }

  // repeated .mesos.Volume volumes = 2;
  total_size += 1 * this->volumes_size();
  for (int i = 0; i < this->volumes_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->volumes(i));
  }

  // repeated .mesos.NetworkInfo network_infos = 7;
  total_size += 1 * this->network_infos_size();
  for (int i = 0; i < this->network_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->network_infos(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ContainerInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ContainerInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ContainerInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ContainerInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ContainerInfo)
    MergeFrom(*source);
  }
}

void ContainerInfo::MergeFrom(const ContainerInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ContainerInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  volumes_.MergeFrom(from.volumes_);
  network_infos_.MergeFrom(from.network_infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_hostname()) {
      set_has_hostname();
      hostname_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.hostname_);
    }
    if (from.has_docker()) {
      mutable_docker()->::mesos::ContainerInfo_DockerInfo::MergeFrom(from.docker());
    }
    if (from.has_mesos()) {
      mutable_mesos()->::mesos::ContainerInfo_MesosInfo::MergeFrom(from.mesos());
    }
    if (from.has_linux_info()) {
      mutable_linux_info()->::mesos::LinuxInfo::MergeFrom(from.linux_info());
    }
    if (from.has_rlimit_info()) {
      mutable_rlimit_info()->::mesos::RLimitInfo::MergeFrom(from.rlimit_info());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tty_info()) {
      mutable_tty_info()->::mesos::TTYInfo::MergeFrom(from.tty_info());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ContainerInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ContainerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerInfo::CopyFrom(const ContainerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ContainerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->volumes())) return false;
  if (has_docker()) {
    if (!this->docker_->IsInitialized()) return false;
  }
  if (has_mesos()) {
    if (!this->mesos_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->network_infos())) return false;
  if (has_tty_info()) {
    if (!this->tty_info_->IsInitialized()) return false;
  }
  return true;
}

void ContainerInfo::Swap(ContainerInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContainerInfo::InternalSwap(ContainerInfo* other) {
  std::swap(type_, other->type_);
  volumes_.UnsafeArenaSwap(&other->volumes_);
  hostname_.Swap(&other->hostname_);
  std::swap(docker_, other->docker_);
  std::swap(mesos_, other->mesos_);
  network_infos_.UnsafeArenaSwap(&other->network_infos_);
  std::swap(linux_info_, other->linux_info_);
  std::swap(rlimit_info_, other->rlimit_info_);
  std::swap(tty_info_, other->tty_info_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ContainerInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerInfo_descriptor_;
  metadata.reflection = ContainerInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ContainerInfo_DockerInfo_PortMapping

// required uint32 host_port = 1;
bool ContainerInfo_DockerInfo_PortMapping::has_host_port() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ContainerInfo_DockerInfo_PortMapping::set_has_host_port() {
  _has_bits_[0] |= 0x00000001u;
}
void ContainerInfo_DockerInfo_PortMapping::clear_has_host_port() {
  _has_bits_[0] &= ~0x00000001u;
}
void ContainerInfo_DockerInfo_PortMapping::clear_host_port() {
  host_port_ = 0u;
  clear_has_host_port();
}
 ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::host_port() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.host_port)
  return host_port_;
}
 void ContainerInfo_DockerInfo_PortMapping::set_host_port(::google::protobuf::uint32 value) {
  set_has_host_port();
  host_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.host_port)
}

// required uint32 container_port = 2;
bool ContainerInfo_DockerInfo_PortMapping::has_container_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ContainerInfo_DockerInfo_PortMapping::set_has_container_port() {
  _has_bits_[0] |= 0x00000002u;
}
void ContainerInfo_DockerInfo_PortMapping::clear_has_container_port() {
  _has_bits_[0] &= ~0x00000002u;
}
void ContainerInfo_DockerInfo_PortMapping::clear_container_port() {
  container_port_ = 0u;
  clear_has_container_port();
}
 ::google::protobuf::uint32 ContainerInfo_DockerInfo_PortMapping::container_port() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.container_port)
  return container_port_;
}
 void ContainerInfo_DockerInfo_PortMapping::set_container_port(::google::protobuf::uint32 value) {
  set_has_container_port();
  container_port_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.container_port)
}

// optional string protocol = 3;
bool ContainerInfo_DockerInfo_PortMapping::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ContainerInfo_DockerInfo_PortMapping::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
void ContainerInfo_DockerInfo_PortMapping::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
void ContainerInfo_DockerInfo_PortMapping::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
 const ::std::string& ContainerInfo_DockerInfo_PortMapping::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  return protocol_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo_DockerInfo_PortMapping::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
 void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
 void ContainerInfo_DockerInfo_PortMapping::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}
 ::std::string* ContainerInfo_DockerInfo_PortMapping::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ContainerInfo_DockerInfo_PortMapping::release_protocol() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
  clear_has_protocol();
  return protocol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo_DockerInfo_PortMapping::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.PortMapping.protocol)
}

// -------------------------------------------------------------------

// ContainerInfo_DockerInfo

// required string image = 1;
bool ContainerInfo_DockerInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ContainerInfo_DockerInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
void ContainerInfo_DockerInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
void ContainerInfo_DockerInfo::clear_image() {
  image_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_image();
}
 const ::std::string& ContainerInfo_DockerInfo::image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.image)
  return image_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo_DockerInfo::set_image(const ::std::string& value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.image)
}
 void ContainerInfo_DockerInfo::set_image(const char* value) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.image)
}
 void ContainerInfo_DockerInfo::set_image(const char* value, size_t size) {
  set_has_image();
  image_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.image)
}
 ::std::string* ContainerInfo_DockerInfo::mutable_image() {
  set_has_image();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.image)
  return image_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ContainerInfo_DockerInfo::release_image() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.DockerInfo.image)
  clear_has_image();
  return image_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo_DockerInfo::set_allocated_image(::std::string* image) {
  if (image != NULL) {
    set_has_image();
  } else {
    clear_has_image();
  }
  image_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), image);
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.image)
}

// optional .mesos.ContainerInfo.DockerInfo.Network network = 2 [default = HOST];
bool ContainerInfo_DockerInfo::has_network() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void ContainerInfo_DockerInfo::set_has_network() {
  _has_bits_[0] |= 0x00000002u;
}
void ContainerInfo_DockerInfo::clear_has_network() {
  _has_bits_[0] &= ~0x00000002u;
}
void ContainerInfo_DockerInfo::clear_network() {
  network_ = 1;
  clear_has_network();
}
 ::mesos::ContainerInfo_DockerInfo_Network ContainerInfo_DockerInfo::network() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.network)
  return static_cast< ::mesos::ContainerInfo_DockerInfo_Network >(network_);
}
 void ContainerInfo_DockerInfo::set_network(::mesos::ContainerInfo_DockerInfo_Network value) {
  assert(::mesos::ContainerInfo_DockerInfo_Network_IsValid(value));
  set_has_network();
  network_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.network)
}

// repeated .mesos.ContainerInfo.DockerInfo.PortMapping port_mappings = 3;
int ContainerInfo_DockerInfo::port_mappings_size() const {
  return port_mappings_.size();
}
void ContainerInfo_DockerInfo::clear_port_mappings() {
  port_mappings_.Clear();
}
const ::mesos::ContainerInfo_DockerInfo_PortMapping& ContainerInfo_DockerInfo::port_mappings(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Get(index);
}
::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::mutable_port_mappings(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Mutable(index);
}
::mesos::ContainerInfo_DockerInfo_PortMapping* ContainerInfo_DockerInfo::add_port_mappings() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >*
ContainerInfo_DockerInfo::mutable_port_mappings() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.DockerInfo.port_mappings)
  return &port_mappings_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::ContainerInfo_DockerInfo_PortMapping >&
ContainerInfo_DockerInfo::port_mappings() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.DockerInfo.port_mappings)
  return port_mappings_;
}

// optional bool privileged = 4 [default = false];
bool ContainerInfo_DockerInfo::has_privileged() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ContainerInfo_DockerInfo::set_has_privileged() {
  _has_bits_[0] |= 0x00000008u;
}
void ContainerInfo_DockerInfo::clear_has_privileged() {
  _has_bits_[0] &= ~0x00000008u;
}
void ContainerInfo_DockerInfo::clear_privileged() {
  privileged_ = false;
  clear_has_privileged();
}
 bool ContainerInfo_DockerInfo::privileged() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.privileged)
  return privileged_;
}
 void ContainerInfo_DockerInfo::set_privileged(bool value) {
  set_has_privileged();
  privileged_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.privileged)
}

// repeated .mesos.Parameter parameters = 5;
int ContainerInfo_DockerInfo::parameters_size() const {
  return parameters_.size();
}
void ContainerInfo_DockerInfo::clear_parameters() {
  parameters_.Clear();
}
const ::mesos::Parameter& ContainerInfo_DockerInfo::parameters(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Get(index);
}
::mesos::Parameter* ContainerInfo_DockerInfo::mutable_parameters(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Mutable(index);
}
::mesos::Parameter* ContainerInfo_DockerInfo::add_parameters() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Parameter >*
ContainerInfo_DockerInfo::mutable_parameters() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.DockerInfo.parameters)
  return &parameters_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Parameter >&
ContainerInfo_DockerInfo::parameters() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.DockerInfo.parameters)
  return parameters_;
}

// optional bool force_pull_image = 6;
bool ContainerInfo_DockerInfo::has_force_pull_image() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void ContainerInfo_DockerInfo::set_has_force_pull_image() {
  _has_bits_[0] |= 0x00000020u;
}
void ContainerInfo_DockerInfo::clear_has_force_pull_image() {
  _has_bits_[0] &= ~0x00000020u;
}
void ContainerInfo_DockerInfo::clear_force_pull_image() {
  force_pull_image_ = false;
  clear_has_force_pull_image();
}
 bool ContainerInfo_DockerInfo::force_pull_image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.force_pull_image)
  return force_pull_image_;
}
 void ContainerInfo_DockerInfo::set_force_pull_image(bool value) {
  set_has_force_pull_image();
  force_pull_image_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.force_pull_image)
}

// optional string volume_driver = 7 [deprecated = true];
bool ContainerInfo_DockerInfo::has_volume_driver() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ContainerInfo_DockerInfo::set_has_volume_driver() {
  _has_bits_[0] |= 0x00000040u;
}
void ContainerInfo_DockerInfo::clear_has_volume_driver() {
  _has_bits_[0] &= ~0x00000040u;
}
void ContainerInfo_DockerInfo::clear_volume_driver() {
  volume_driver_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_volume_driver();
}
 const ::std::string& ContainerInfo_DockerInfo::volume_driver() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.DockerInfo.volume_driver)
  return volume_driver_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo_DockerInfo::set_volume_driver(const ::std::string& value) {
  set_has_volume_driver();
  volume_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.DockerInfo.volume_driver)
}
 void ContainerInfo_DockerInfo::set_volume_driver(const char* value) {
  set_has_volume_driver();
  volume_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.DockerInfo.volume_driver)
}
 void ContainerInfo_DockerInfo::set_volume_driver(const char* value, size_t size) {
  set_has_volume_driver();
  volume_driver_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.DockerInfo.volume_driver)
}
 ::std::string* ContainerInfo_DockerInfo::mutable_volume_driver() {
  set_has_volume_driver();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.DockerInfo.volume_driver)
  return volume_driver_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ContainerInfo_DockerInfo::release_volume_driver() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.DockerInfo.volume_driver)
  clear_has_volume_driver();
  return volume_driver_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo_DockerInfo::set_allocated_volume_driver(::std::string* volume_driver) {
  if (volume_driver != NULL) {
    set_has_volume_driver();
  } else {
    clear_has_volume_driver();
  }
  volume_driver_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), volume_driver);
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.DockerInfo.volume_driver)
}

// -------------------------------------------------------------------

// ContainerInfo_MesosInfo

// optional .mesos.Image image = 1;
bool ContainerInfo_MesosInfo::has_image() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ContainerInfo_MesosInfo::set_has_image() {
  _has_bits_[0] |= 0x00000001u;
}
void ContainerInfo_MesosInfo::clear_has_image() {
  _has_bits_[0] &= ~0x00000001u;
}
void ContainerInfo_MesosInfo::clear_image() {
  if (image_ != NULL) image_->::mesos::Image::Clear();
  clear_has_image();
}
const ::mesos::Image& ContainerInfo_MesosInfo::image() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.MesosInfo.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
::mesos::Image* ContainerInfo_MesosInfo::mutable_image() {
  set_has_image();
  if (image_ == NULL) {
    image_ = new ::mesos::Image;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.MesosInfo.image)
  return image_;
}
::mesos::Image* ContainerInfo_MesosInfo::release_image() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.MesosInfo.image)
  clear_has_image();
  ::mesos::Image* temp = image_;
  image_ = NULL;
  return temp;
}
void ContainerInfo_MesosInfo::set_allocated_image(::mesos::Image* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.MesosInfo.image)
}

// -------------------------------------------------------------------

// ContainerInfo

// required .mesos.ContainerInfo.Type type = 1;
bool ContainerInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ContainerInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
void ContainerInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
void ContainerInfo::clear_type() {
  type_ = 1;
  clear_has_type();
}
 ::mesos::ContainerInfo_Type ContainerInfo::type() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.type)
  return static_cast< ::mesos::ContainerInfo_Type >(type_);
}
 void ContainerInfo::set_type(::mesos::ContainerInfo_Type value) {
  assert(::mesos::ContainerInfo_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.type)
}

// repeated .mesos.Volume volumes = 2;
int ContainerInfo::volumes_size() const {
  return volumes_.size();
}
void ContainerInfo::clear_volumes() {
  volumes_.Clear();
}
const ::mesos::Volume& ContainerInfo::volumes(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.volumes)
  return volumes_.Get(index);
}
::mesos::Volume* ContainerInfo::mutable_volumes(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.volumes)
  return volumes_.Mutable(index);
}
::mesos::Volume* ContainerInfo::add_volumes() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.volumes)
  return volumes_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Volume >*
ContainerInfo::mutable_volumes() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.volumes)
  return &volumes_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Volume >&
ContainerInfo::volumes() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.volumes)
  return volumes_;
}

// optional string hostname = 4;
bool ContainerInfo::has_hostname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ContainerInfo::set_has_hostname() {
  _has_bits_[0] |= 0x00000004u;
}
void ContainerInfo::clear_has_hostname() {
  _has_bits_[0] &= ~0x00000004u;
}
void ContainerInfo::clear_hostname() {
  hostname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_hostname();
}
 const ::std::string& ContainerInfo::hostname() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.hostname)
  return hostname_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo::set_hostname(const ::std::string& value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.ContainerInfo.hostname)
}
 void ContainerInfo::set_hostname(const char* value) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.ContainerInfo.hostname)
}
 void ContainerInfo::set_hostname(const char* value, size_t size) {
  set_has_hostname();
  hostname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.ContainerInfo.hostname)
}
 ::std::string* ContainerInfo::mutable_hostname() {
  set_has_hostname();
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.hostname)
  return hostname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ContainerInfo::release_hostname() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.hostname)
  clear_has_hostname();
  return hostname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ContainerInfo::set_allocated_hostname(::std::string* hostname) {
  if (hostname != NULL) {
    set_has_hostname();
  } else {
    clear_has_hostname();
  }
  hostname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hostname);
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.hostname)
}

// optional .mesos.ContainerInfo.DockerInfo docker = 3;
bool ContainerInfo::has_docker() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ContainerInfo::set_has_docker() {
  _has_bits_[0] |= 0x00000008u;
}
void ContainerInfo::clear_has_docker() {
  _has_bits_[0] &= ~0x00000008u;
}
void ContainerInfo::clear_docker() {
  if (docker_ != NULL) docker_->::mesos::ContainerInfo_DockerInfo::Clear();
  clear_has_docker();
}
const ::mesos::ContainerInfo_DockerInfo& ContainerInfo::docker() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.docker)
  return docker_ != NULL ? *docker_ : *default_instance_->docker_;
}
::mesos::ContainerInfo_DockerInfo* ContainerInfo::mutable_docker() {
  set_has_docker();
  if (docker_ == NULL) {
    docker_ = new ::mesos::ContainerInfo_DockerInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.docker)
  return docker_;
}
::mesos::ContainerInfo_DockerInfo* ContainerInfo::release_docker() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.docker)
  clear_has_docker();
  ::mesos::ContainerInfo_DockerInfo* temp = docker_;
  docker_ = NULL;
  return temp;
}
void ContainerInfo::set_allocated_docker(::mesos::ContainerInfo_DockerInfo* docker) {
  delete docker_;
  docker_ = docker;
  if (docker) {
    set_has_docker();
  } else {
    clear_has_docker();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.docker)
}

// optional .mesos.ContainerInfo.MesosInfo mesos = 5;
bool ContainerInfo::has_mesos() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void ContainerInfo::set_has_mesos() {
  _has_bits_[0] |= 0x00000010u;
}
void ContainerInfo::clear_has_mesos() {
  _has_bits_[0] &= ~0x00000010u;
}
void ContainerInfo::clear_mesos() {
  if (mesos_ != NULL) mesos_->::mesos::ContainerInfo_MesosInfo::Clear();
  clear_has_mesos();
}
const ::mesos::ContainerInfo_MesosInfo& ContainerInfo::mesos() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.mesos)
  return mesos_ != NULL ? *mesos_ : *default_instance_->mesos_;
}
::mesos::ContainerInfo_MesosInfo* ContainerInfo::mutable_mesos() {
  set_has_mesos();
  if (mesos_ == NULL) {
    mesos_ = new ::mesos::ContainerInfo_MesosInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.mesos)
  return mesos_;
}
::mesos::ContainerInfo_MesosInfo* ContainerInfo::release_mesos() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.mesos)
  clear_has_mesos();
  ::mesos::ContainerInfo_MesosInfo* temp = mesos_;
  mesos_ = NULL;
  return temp;
}
void ContainerInfo::set_allocated_mesos(::mesos::ContainerInfo_MesosInfo* mesos) {
  delete mesos_;
  mesos_ = mesos;
  if (mesos) {
    set_has_mesos();
  } else {
    clear_has_mesos();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.mesos)
}

// repeated .mesos.NetworkInfo network_infos = 7;
int ContainerInfo::network_infos_size() const {
  return network_infos_.size();
}
void ContainerInfo::clear_network_infos() {
  network_infos_.Clear();
}
const ::mesos::NetworkInfo& ContainerInfo::network_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.network_infos)
  return network_infos_.Get(index);
}
::mesos::NetworkInfo* ContainerInfo::mutable_network_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.network_infos)
  return network_infos_.Mutable(index);
}
::mesos::NetworkInfo* ContainerInfo::add_network_infos() {
  // @@protoc_insertion_point(field_add:mesos.ContainerInfo.network_infos)
  return network_infos_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
ContainerInfo::mutable_network_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerInfo.network_infos)
  return &network_infos_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
ContainerInfo::network_infos() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerInfo.network_infos)
  return network_infos_;
}

// optional .mesos.LinuxInfo linux_info = 8;
bool ContainerInfo::has_linux_info() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void ContainerInfo::set_has_linux_info() {
  _has_bits_[0] |= 0x00000040u;
}
void ContainerInfo::clear_has_linux_info() {
  _has_bits_[0] &= ~0x00000040u;
}
void ContainerInfo::clear_linux_info() {
  if (linux_info_ != NULL) linux_info_->::mesos::LinuxInfo::Clear();
  clear_has_linux_info();
}
const ::mesos::LinuxInfo& ContainerInfo::linux_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.linux_info)
  return linux_info_ != NULL ? *linux_info_ : *default_instance_->linux_info_;
}
::mesos::LinuxInfo* ContainerInfo::mutable_linux_info() {
  set_has_linux_info();
  if (linux_info_ == NULL) {
    linux_info_ = new ::mesos::LinuxInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.linux_info)
  return linux_info_;
}
::mesos::LinuxInfo* ContainerInfo::release_linux_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.linux_info)
  clear_has_linux_info();
  ::mesos::LinuxInfo* temp = linux_info_;
  linux_info_ = NULL;
  return temp;
}
void ContainerInfo::set_allocated_linux_info(::mesos::LinuxInfo* linux_info) {
  delete linux_info_;
  linux_info_ = linux_info;
  if (linux_info) {
    set_has_linux_info();
  } else {
    clear_has_linux_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.linux_info)
}

// optional .mesos.RLimitInfo rlimit_info = 9;
bool ContainerInfo::has_rlimit_info() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
void ContainerInfo::set_has_rlimit_info() {
  _has_bits_[0] |= 0x00000080u;
}
void ContainerInfo::clear_has_rlimit_info() {
  _has_bits_[0] &= ~0x00000080u;
}
void ContainerInfo::clear_rlimit_info() {
  if (rlimit_info_ != NULL) rlimit_info_->::mesos::RLimitInfo::Clear();
  clear_has_rlimit_info();
}
const ::mesos::RLimitInfo& ContainerInfo::rlimit_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.rlimit_info)
  return rlimit_info_ != NULL ? *rlimit_info_ : *default_instance_->rlimit_info_;
}
::mesos::RLimitInfo* ContainerInfo::mutable_rlimit_info() {
  set_has_rlimit_info();
  if (rlimit_info_ == NULL) {
    rlimit_info_ = new ::mesos::RLimitInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.rlimit_info)
  return rlimit_info_;
}
::mesos::RLimitInfo* ContainerInfo::release_rlimit_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.rlimit_info)
  clear_has_rlimit_info();
  ::mesos::RLimitInfo* temp = rlimit_info_;
  rlimit_info_ = NULL;
  return temp;
}
void ContainerInfo::set_allocated_rlimit_info(::mesos::RLimitInfo* rlimit_info) {
  delete rlimit_info_;
  rlimit_info_ = rlimit_info;
  if (rlimit_info) {
    set_has_rlimit_info();
  } else {
    clear_has_rlimit_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.rlimit_info)
}

// optional .mesos.TTYInfo tty_info = 10;
bool ContainerInfo::has_tty_info() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
void ContainerInfo::set_has_tty_info() {
  _has_bits_[0] |= 0x00000100u;
}
void ContainerInfo::clear_has_tty_info() {
  _has_bits_[0] &= ~0x00000100u;
}
void ContainerInfo::clear_tty_info() {
  if (tty_info_ != NULL) tty_info_->::mesos::TTYInfo::Clear();
  clear_has_tty_info();
}
const ::mesos::TTYInfo& ContainerInfo::tty_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerInfo.tty_info)
  return tty_info_ != NULL ? *tty_info_ : *default_instance_->tty_info_;
}
::mesos::TTYInfo* ContainerInfo::mutable_tty_info() {
  set_has_tty_info();
  if (tty_info_ == NULL) {
    tty_info_ = new ::mesos::TTYInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerInfo.tty_info)
  return tty_info_;
}
::mesos::TTYInfo* ContainerInfo::release_tty_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerInfo.tty_info)
  clear_has_tty_info();
  ::mesos::TTYInfo* temp = tty_info_;
  tty_info_ = NULL;
  return temp;
}
void ContainerInfo::set_allocated_tty_info(::mesos::TTYInfo* tty_info) {
  delete tty_info_;
  tty_info_ = tty_info;
  if (tty_info) {
    set_has_tty_info();
  } else {
    clear_has_tty_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerInfo.tty_info)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ContainerStatus::kContainerIdFieldNumber;
const int ContainerStatus::kNetworkInfosFieldNumber;
const int ContainerStatus::kCgroupInfoFieldNumber;
const int ContainerStatus::kExecutorPidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ContainerStatus::ContainerStatus()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.ContainerStatus)
}

void ContainerStatus::InitAsDefaultInstance() {
  container_id_ = const_cast< ::mesos::ContainerID*>(&::mesos::ContainerID::default_instance());
  cgroup_info_ = const_cast< ::mesos::CgroupInfo*>(&::mesos::CgroupInfo::default_instance());
}

ContainerStatus::ContainerStatus(const ContainerStatus& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.ContainerStatus)
}

void ContainerStatus::SharedCtor() {
  _cached_size_ = 0;
  container_id_ = NULL;
  cgroup_info_ = NULL;
  executor_pid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ContainerStatus::~ContainerStatus() {
  // @@protoc_insertion_point(destructor:mesos.ContainerStatus)
  SharedDtor();
}

void ContainerStatus::SharedDtor() {
  if (this != default_instance_) {
    delete container_id_;
    delete cgroup_info_;
  }
}

void ContainerStatus::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ContainerStatus::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ContainerStatus_descriptor_;
}

const ContainerStatus& ContainerStatus::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

ContainerStatus* ContainerStatus::default_instance_ = NULL;

ContainerStatus* ContainerStatus::New(::google::protobuf::Arena* arena) const {
  ContainerStatus* n = new ContainerStatus;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ContainerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.ContainerStatus)
  if (_has_bits_[0 / 32] & 13u) {
    if (has_container_id()) {
      if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
    }
    if (has_cgroup_info()) {
      if (cgroup_info_ != NULL) cgroup_info_->::mesos::CgroupInfo::Clear();
    }
    executor_pid_ = 0u;
  }
  network_infos_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool ContainerStatus::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.ContainerStatus)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.NetworkInfo network_infos = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_network_infos:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_network_infos()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_network_infos;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectTag(18)) goto parse_cgroup_info;
        break;
      }

      // optional .mesos.CgroupInfo cgroup_info = 2;
      case 2: {
        if (tag == 18) {
         parse_cgroup_info:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cgroup_info()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_executor_pid;
        break;
      }

      // optional uint32 executor_pid = 3;
      case 3: {
        if (tag == 24) {
         parse_executor_pid:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &executor_pid_)));
          set_has_executor_pid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_container_id;
        break;
      }

      // optional .mesos.ContainerID container_id = 4;
      case 4: {
        if (tag == 34) {
         parse_container_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_container_id()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.ContainerStatus)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.ContainerStatus)
  return false;
#undef DO_
}

void ContainerStatus::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.ContainerStatus)
  // repeated .mesos.NetworkInfo network_infos = 1;
  for (unsigned int i = 0, n = this->network_infos_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->network_infos(i), output);
  }

  // optional .mesos.CgroupInfo cgroup_info = 2;
  if (has_cgroup_info()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->cgroup_info_, output);
  }

  // optional uint32 executor_pid = 3;
  if (has_executor_pid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(3, this->executor_pid(), output);
  }

  // optional .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->container_id_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.ContainerStatus)
}

::google::protobuf::uint8* ContainerStatus::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.ContainerStatus)
  // repeated .mesos.NetworkInfo network_infos = 1;
  for (unsigned int i = 0, n = this->network_infos_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->network_infos(i), false, target);
  }

  // optional .mesos.CgroupInfo cgroup_info = 2;
  if (has_cgroup_info()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->cgroup_info_, false, target);
  }

  // optional uint32 executor_pid = 3;
  if (has_executor_pid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(3, this->executor_pid(), target);
  }

  // optional .mesos.ContainerID container_id = 4;
  if (has_container_id()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->container_id_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.ContainerStatus)
  return target;
}

int ContainerStatus::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.ContainerStatus)
  int total_size = 0;

  if (_has_bits_[0 / 32] & 13u) {
    // optional .mesos.ContainerID container_id = 4;
    if (has_container_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->container_id_);
    }

    // optional .mesos.CgroupInfo cgroup_info = 2;
    if (has_cgroup_info()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->cgroup_info_);
    }

    // optional uint32 executor_pid = 3;
    if (has_executor_pid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->executor_pid());
    }

  }
  // repeated .mesos.NetworkInfo network_infos = 1;
  total_size += 1 * this->network_infos_size();
  for (int i = 0; i < this->network_infos_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->network_infos(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ContainerStatus::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.ContainerStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ContainerStatus* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ContainerStatus>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.ContainerStatus)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.ContainerStatus)
    MergeFrom(*source);
  }
}

void ContainerStatus::MergeFrom(const ContainerStatus& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.ContainerStatus)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  network_infos_.MergeFrom(from.network_infos_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_container_id()) {
      mutable_container_id()->::mesos::ContainerID::MergeFrom(from.container_id());
    }
    if (from.has_cgroup_info()) {
      mutable_cgroup_info()->::mesos::CgroupInfo::MergeFrom(from.cgroup_info());
    }
    if (from.has_executor_pid()) {
      set_executor_pid(from.executor_pid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void ContainerStatus::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.ContainerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ContainerStatus::CopyFrom(const ContainerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.ContainerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ContainerStatus::IsInitialized() const {

  if (has_container_id()) {
    if (!this->container_id_->IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->network_infos())) return false;
  return true;
}

void ContainerStatus::Swap(ContainerStatus* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ContainerStatus::InternalSwap(ContainerStatus* other) {
  std::swap(container_id_, other->container_id_);
  network_infos_.UnsafeArenaSwap(&other->network_infos_);
  std::swap(cgroup_info_, other->cgroup_info_);
  std::swap(executor_pid_, other->executor_pid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ContainerStatus::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ContainerStatus_descriptor_;
  metadata.reflection = ContainerStatus_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ContainerStatus

// optional .mesos.ContainerID container_id = 4;
bool ContainerStatus::has_container_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void ContainerStatus::set_has_container_id() {
  _has_bits_[0] |= 0x00000001u;
}
void ContainerStatus::clear_has_container_id() {
  _has_bits_[0] &= ~0x00000001u;
}
void ContainerStatus::clear_container_id() {
  if (container_id_ != NULL) container_id_->::mesos::ContainerID::Clear();
  clear_has_container_id();
}
const ::mesos::ContainerID& ContainerStatus::container_id() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.container_id)
  return container_id_ != NULL ? *container_id_ : *default_instance_->container_id_;
}
::mesos::ContainerID* ContainerStatus::mutable_container_id() {
  set_has_container_id();
  if (container_id_ == NULL) {
    container_id_ = new ::mesos::ContainerID;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.container_id)
  return container_id_;
}
::mesos::ContainerID* ContainerStatus::release_container_id() {
  // @@protoc_insertion_point(field_release:mesos.ContainerStatus.container_id)
  clear_has_container_id();
  ::mesos::ContainerID* temp = container_id_;
  container_id_ = NULL;
  return temp;
}
void ContainerStatus::set_allocated_container_id(::mesos::ContainerID* container_id) {
  delete container_id_;
  container_id_ = container_id;
  if (container_id) {
    set_has_container_id();
  } else {
    clear_has_container_id();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerStatus.container_id)
}

// repeated .mesos.NetworkInfo network_infos = 1;
int ContainerStatus::network_infos_size() const {
  return network_infos_.size();
}
void ContainerStatus::clear_network_infos() {
  network_infos_.Clear();
}
const ::mesos::NetworkInfo& ContainerStatus::network_infos(int index) const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.network_infos)
  return network_infos_.Get(index);
}
::mesos::NetworkInfo* ContainerStatus::mutable_network_infos(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.network_infos)
  return network_infos_.Mutable(index);
}
::mesos::NetworkInfo* ContainerStatus::add_network_infos() {
  // @@protoc_insertion_point(field_add:mesos.ContainerStatus.network_infos)
  return network_infos_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >*
ContainerStatus::mutable_network_infos() {
  // @@protoc_insertion_point(field_mutable_list:mesos.ContainerStatus.network_infos)
  return &network_infos_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::NetworkInfo >&
ContainerStatus::network_infos() const {
  // @@protoc_insertion_point(field_list:mesos.ContainerStatus.network_infos)
  return network_infos_;
}

// optional .mesos.CgroupInfo cgroup_info = 2;
bool ContainerStatus::has_cgroup_info() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void ContainerStatus::set_has_cgroup_info() {
  _has_bits_[0] |= 0x00000004u;
}
void ContainerStatus::clear_has_cgroup_info() {
  _has_bits_[0] &= ~0x00000004u;
}
void ContainerStatus::clear_cgroup_info() {
  if (cgroup_info_ != NULL) cgroup_info_->::mesos::CgroupInfo::Clear();
  clear_has_cgroup_info();
}
const ::mesos::CgroupInfo& ContainerStatus::cgroup_info() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.cgroup_info)
  return cgroup_info_ != NULL ? *cgroup_info_ : *default_instance_->cgroup_info_;
}
::mesos::CgroupInfo* ContainerStatus::mutable_cgroup_info() {
  set_has_cgroup_info();
  if (cgroup_info_ == NULL) {
    cgroup_info_ = new ::mesos::CgroupInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.ContainerStatus.cgroup_info)
  return cgroup_info_;
}
::mesos::CgroupInfo* ContainerStatus::release_cgroup_info() {
  // @@protoc_insertion_point(field_release:mesos.ContainerStatus.cgroup_info)
  clear_has_cgroup_info();
  ::mesos::CgroupInfo* temp = cgroup_info_;
  cgroup_info_ = NULL;
  return temp;
}
void ContainerStatus::set_allocated_cgroup_info(::mesos::CgroupInfo* cgroup_info) {
  delete cgroup_info_;
  cgroup_info_ = cgroup_info;
  if (cgroup_info) {
    set_has_cgroup_info();
  } else {
    clear_has_cgroup_info();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.ContainerStatus.cgroup_info)
}

// optional uint32 executor_pid = 3;
bool ContainerStatus::has_executor_pid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void ContainerStatus::set_has_executor_pid() {
  _has_bits_[0] |= 0x00000008u;
}
void ContainerStatus::clear_has_executor_pid() {
  _has_bits_[0] &= ~0x00000008u;
}
void ContainerStatus::clear_executor_pid() {
  executor_pid_ = 0u;
  clear_has_executor_pid();
}
 ::google::protobuf::uint32 ContainerStatus::executor_pid() const {
  // @@protoc_insertion_point(field_get:mesos.ContainerStatus.executor_pid)
  return executor_pid_;
}
 void ContainerStatus::set_executor_pid(::google::protobuf::uint32 value) {
  set_has_executor_pid();
  executor_pid_ = value;
  // @@protoc_insertion_point(field_set:mesos.ContainerStatus.executor_pid)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CgroupInfo_NetCls::kClassidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CgroupInfo_NetCls::CgroupInfo_NetCls()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CgroupInfo.NetCls)
}

void CgroupInfo_NetCls::InitAsDefaultInstance() {
}

CgroupInfo_NetCls::CgroupInfo_NetCls(const CgroupInfo_NetCls& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CgroupInfo.NetCls)
}

void CgroupInfo_NetCls::SharedCtor() {
  _cached_size_ = 0;
  classid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CgroupInfo_NetCls::~CgroupInfo_NetCls() {
  // @@protoc_insertion_point(destructor:mesos.CgroupInfo.NetCls)
  SharedDtor();
}

void CgroupInfo_NetCls::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CgroupInfo_NetCls::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CgroupInfo_NetCls::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CgroupInfo_NetCls_descriptor_;
}

const CgroupInfo_NetCls& CgroupInfo_NetCls::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CgroupInfo_NetCls* CgroupInfo_NetCls::default_instance_ = NULL;

CgroupInfo_NetCls* CgroupInfo_NetCls::New(::google::protobuf::Arena* arena) const {
  CgroupInfo_NetCls* n = new CgroupInfo_NetCls;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CgroupInfo_NetCls::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CgroupInfo.NetCls)
  classid_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CgroupInfo_NetCls::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CgroupInfo.NetCls)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional uint32 classid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &classid_)));
          set_has_classid();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CgroupInfo.NetCls)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CgroupInfo.NetCls)
  return false;
#undef DO_
}

void CgroupInfo_NetCls::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CgroupInfo.NetCls)
  // optional uint32 classid = 1;
  if (has_classid()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->classid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CgroupInfo.NetCls)
}

::google::protobuf::uint8* CgroupInfo_NetCls::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CgroupInfo.NetCls)
  // optional uint32 classid = 1;
  if (has_classid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->classid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CgroupInfo.NetCls)
  return target;
}

int CgroupInfo_NetCls::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CgroupInfo.NetCls)
  int total_size = 0;

  // optional uint32 classid = 1;
  if (has_classid()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->classid());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CgroupInfo_NetCls::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CgroupInfo.NetCls)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CgroupInfo_NetCls* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CgroupInfo_NetCls>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CgroupInfo.NetCls)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CgroupInfo.NetCls)
    MergeFrom(*source);
  }
}

void CgroupInfo_NetCls::MergeFrom(const CgroupInfo_NetCls& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CgroupInfo.NetCls)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_classid()) {
      set_classid(from.classid());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CgroupInfo_NetCls::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CgroupInfo.NetCls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CgroupInfo_NetCls::CopyFrom(const CgroupInfo_NetCls& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CgroupInfo.NetCls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CgroupInfo_NetCls::IsInitialized() const {

  return true;
}

void CgroupInfo_NetCls::Swap(CgroupInfo_NetCls* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CgroupInfo_NetCls::InternalSwap(CgroupInfo_NetCls* other) {
  std::swap(classid_, other->classid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CgroupInfo_NetCls::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CgroupInfo_NetCls_descriptor_;
  metadata.reflection = CgroupInfo_NetCls_reflection_;
  return metadata;
}


// -------------------------------------------------------------------

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int CgroupInfo::kNetClsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CgroupInfo::CgroupInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.CgroupInfo)
}

void CgroupInfo::InitAsDefaultInstance() {
  net_cls_ = const_cast< ::mesos::CgroupInfo_NetCls*>(&::mesos::CgroupInfo_NetCls::default_instance());
}

CgroupInfo::CgroupInfo(const CgroupInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.CgroupInfo)
}

void CgroupInfo::SharedCtor() {
  _cached_size_ = 0;
  net_cls_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CgroupInfo::~CgroupInfo() {
  // @@protoc_insertion_point(destructor:mesos.CgroupInfo)
  SharedDtor();
}

void CgroupInfo::SharedDtor() {
  if (this != default_instance_) {
    delete net_cls_;
  }
}

void CgroupInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CgroupInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CgroupInfo_descriptor_;
}

const CgroupInfo& CgroupInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

CgroupInfo* CgroupInfo::default_instance_ = NULL;

CgroupInfo* CgroupInfo::New(::google::protobuf::Arena* arena) const {
  CgroupInfo* n = new CgroupInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CgroupInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.CgroupInfo)
  if (has_net_cls()) {
    if (net_cls_ != NULL) net_cls_->::mesos::CgroupInfo_NetCls::Clear();
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool CgroupInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.CgroupInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .mesos.CgroupInfo.NetCls net_cls = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_net_cls()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.CgroupInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.CgroupInfo)
  return false;
#undef DO_
}

void CgroupInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.CgroupInfo)
  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  if (has_net_cls()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->net_cls_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.CgroupInfo)
}

::google::protobuf::uint8* CgroupInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.CgroupInfo)
  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  if (has_net_cls()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->net_cls_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.CgroupInfo)
  return target;
}

int CgroupInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.CgroupInfo)
  int total_size = 0;

  // optional .mesos.CgroupInfo.NetCls net_cls = 1;
  if (has_net_cls()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->net_cls_);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CgroupInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.CgroupInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CgroupInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CgroupInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.CgroupInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.CgroupInfo)
    MergeFrom(*source);
  }
}

void CgroupInfo::MergeFrom(const CgroupInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.CgroupInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_net_cls()) {
      mutable_net_cls()->::mesos::CgroupInfo_NetCls::MergeFrom(from.net_cls());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void CgroupInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.CgroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CgroupInfo::CopyFrom(const CgroupInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.CgroupInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CgroupInfo::IsInitialized() const {

  return true;
}

void CgroupInfo::Swap(CgroupInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CgroupInfo::InternalSwap(CgroupInfo* other) {
  std::swap(net_cls_, other->net_cls_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CgroupInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CgroupInfo_descriptor_;
  metadata.reflection = CgroupInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CgroupInfo_NetCls

// optional uint32 classid = 1;
bool CgroupInfo_NetCls::has_classid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CgroupInfo_NetCls::set_has_classid() {
  _has_bits_[0] |= 0x00000001u;
}
void CgroupInfo_NetCls::clear_has_classid() {
  _has_bits_[0] &= ~0x00000001u;
}
void CgroupInfo_NetCls::clear_classid() {
  classid_ = 0u;
  clear_has_classid();
}
 ::google::protobuf::uint32 CgroupInfo_NetCls::classid() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.NetCls.classid)
  return classid_;
}
 void CgroupInfo_NetCls::set_classid(::google::protobuf::uint32 value) {
  set_has_classid();
  classid_ = value;
  // @@protoc_insertion_point(field_set:mesos.CgroupInfo.NetCls.classid)
}

// -------------------------------------------------------------------

// CgroupInfo

// optional .mesos.CgroupInfo.NetCls net_cls = 1;
bool CgroupInfo::has_net_cls() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void CgroupInfo::set_has_net_cls() {
  _has_bits_[0] |= 0x00000001u;
}
void CgroupInfo::clear_has_net_cls() {
  _has_bits_[0] &= ~0x00000001u;
}
void CgroupInfo::clear_net_cls() {
  if (net_cls_ != NULL) net_cls_->::mesos::CgroupInfo_NetCls::Clear();
  clear_has_net_cls();
}
const ::mesos::CgroupInfo_NetCls& CgroupInfo::net_cls() const {
  // @@protoc_insertion_point(field_get:mesos.CgroupInfo.net_cls)
  return net_cls_ != NULL ? *net_cls_ : *default_instance_->net_cls_;
}
::mesos::CgroupInfo_NetCls* CgroupInfo::mutable_net_cls() {
  set_has_net_cls();
  if (net_cls_ == NULL) {
    net_cls_ = new ::mesos::CgroupInfo_NetCls;
  }
  // @@protoc_insertion_point(field_mutable:mesos.CgroupInfo.net_cls)
  return net_cls_;
}
::mesos::CgroupInfo_NetCls* CgroupInfo::release_net_cls() {
  // @@protoc_insertion_point(field_release:mesos.CgroupInfo.net_cls)
  clear_has_net_cls();
  ::mesos::CgroupInfo_NetCls* temp = net_cls_;
  net_cls_ = NULL;
  return temp;
}
void CgroupInfo::set_allocated_net_cls(::mesos::CgroupInfo_NetCls* net_cls) {
  delete net_cls_;
  net_cls_ = net_cls;
  if (net_cls) {
    set_has_net_cls();
  } else {
    clear_has_net_cls();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.CgroupInfo.net_cls)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Labels::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Labels::Labels()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Labels)
}

void Labels::InitAsDefaultInstance() {
}

Labels::Labels(const Labels& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Labels)
}

void Labels::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Labels::~Labels() {
  // @@protoc_insertion_point(destructor:mesos.Labels)
  SharedDtor();
}

void Labels::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Labels::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Labels::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Labels_descriptor_;
}

const Labels& Labels::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Labels* Labels::default_instance_ = NULL;

Labels* Labels::New(::google::protobuf::Arena* arena) const {
  Labels* n = new Labels;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Labels::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Labels)
  labels_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Labels::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Labels)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Label labels = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_labels;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Labels)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Labels)
  return false;
#undef DO_
}

void Labels::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Labels)
  // repeated .mesos.Label labels = 1;
  for (unsigned int i = 0, n = this->labels_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->labels(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Labels)
}

::google::protobuf::uint8* Labels::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Labels)
  // repeated .mesos.Label labels = 1;
  for (unsigned int i = 0, n = this->labels_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->labels(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Labels)
  return target;
}

int Labels::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Labels)
  int total_size = 0;

  // repeated .mesos.Label labels = 1;
  total_size += 1 * this->labels_size();
  for (int i = 0; i < this->labels_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->labels(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Labels::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Labels)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Labels* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Labels>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Labels)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Labels)
    MergeFrom(*source);
  }
}

void Labels::MergeFrom(const Labels& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Labels)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  labels_.MergeFrom(from.labels_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Labels::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Labels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Labels::CopyFrom(const Labels& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Labels)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Labels::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->labels())) return false;
  return true;
}

void Labels::Swap(Labels* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Labels::InternalSwap(Labels* other) {
  labels_.UnsafeArenaSwap(&other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Labels::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Labels_descriptor_;
  metadata.reflection = Labels_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Labels

// repeated .mesos.Label labels = 1;
int Labels::labels_size() const {
  return labels_.size();
}
void Labels::clear_labels() {
  labels_.Clear();
}
const ::mesos::Label& Labels::labels(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Labels.labels)
  return labels_.Get(index);
}
::mesos::Label* Labels::mutable_labels(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Labels.labels)
  return labels_.Mutable(index);
}
::mesos::Label* Labels::add_labels() {
  // @@protoc_insertion_point(field_add:mesos.Labels.labels)
  return labels_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Label >*
Labels::mutable_labels() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Labels.labels)
  return &labels_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Label >&
Labels::labels() const {
  // @@protoc_insertion_point(field_list:mesos.Labels.labels)
  return labels_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Label::kKeyFieldNumber;
const int Label::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Label::Label()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Label)
}

void Label::InitAsDefaultInstance() {
}

Label::Label(const Label& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Label)
}

void Label::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Label::~Label() {
  // @@protoc_insertion_point(destructor:mesos.Label)
  SharedDtor();
}

void Label::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Label::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Label::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Label_descriptor_;
}

const Label& Label::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Label* Label::default_instance_ = NULL;

Label* Label::New(::google::protobuf::Arena* arena) const {
  Label* n = new Label;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Label::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Label)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_key()) {
      key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Label::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Label)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Label.key");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Label.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Label)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Label)
  return false;
#undef DO_
}

void Label::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Label)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Label.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->key(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Label.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Label)
}

::google::protobuf::uint8* Label::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Label)
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Label.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Label.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Label)
  return target;
}

int Label::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Label)
  int total_size = 0;

  // required string key = 1;
  if (has_key()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }
  // optional string value = 2;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Label::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Label)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Label* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Label>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Label)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Label)
    MergeFrom(*source);
  }
}

void Label::MergeFrom(const Label& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Label)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_has_key();
      key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Label::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Label)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Label::CopyFrom(const Label& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Label)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Label::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Label::Swap(Label* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Label::InternalSwap(Label* other) {
  key_.Swap(&other->key_);
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Label::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Label_descriptor_;
  metadata.reflection = Label_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Label

// required string key = 1;
bool Label::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Label::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
void Label::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
void Label::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_key();
}
 const ::std::string& Label::key() const {
  // @@protoc_insertion_point(field_get:mesos.Label.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Label::set_key(const ::std::string& value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Label.key)
}
 void Label::set_key(const char* value) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Label.key)
}
 void Label::set_key(const char* value, size_t size) {
  set_has_key();
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Label.key)
}
 ::std::string* Label::mutable_key() {
  set_has_key();
  // @@protoc_insertion_point(field_mutable:mesos.Label.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Label::release_key() {
  // @@protoc_insertion_point(field_release:mesos.Label.key)
  clear_has_key();
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Label::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    set_has_key();
  } else {
    clear_has_key();
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:mesos.Label.key)
}

// optional string value = 2;
bool Label::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Label::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void Label::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void Label::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Label::value() const {
  // @@protoc_insertion_point(field_get:mesos.Label.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Label::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Label.value)
}
 void Label::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Label.value)
}
 void Label::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Label.value)
}
 ::std::string* Label::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Label.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Label::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Label.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Label::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.Label.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Port::kNumberFieldNumber;
const int Port::kNameFieldNumber;
const int Port::kProtocolFieldNumber;
const int Port::kVisibilityFieldNumber;
const int Port::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Port::Port()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Port)
}

void Port::InitAsDefaultInstance() {
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

Port::Port(const Port& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Port)
}

void Port::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  number_ = 0u;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  visibility_ = 0;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Port::~Port() {
  // @@protoc_insertion_point(destructor:mesos.Port)
  SharedDtor();
}

void Port::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  protocol_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete labels_;
  }
}

void Port::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Port::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Port_descriptor_;
}

const Port& Port::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Port* Port::default_instance_ = NULL;

Port* Port::New(::google::protobuf::Arena* arena) const {
  Port* n = new Port;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Port::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Port)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Port, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Port*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 31u) {
    ZR_(number_, visibility_);
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_protocol()) {
      protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Port::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Port)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 number = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &number_)));
          set_has_number();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Port.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_protocol;
        break;
      }

      // optional string protocol = 3;
      case 3: {
        if (tag == 26) {
         parse_protocol:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_protocol()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->protocol().data(), this->protocol().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Port.protocol");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_visibility;
        break;
      }

      // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
      case 4: {
        if (tag == 32) {
         parse_visibility:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::DiscoveryInfo_Visibility_IsValid(value)) {
            set_visibility(static_cast< ::mesos::DiscoveryInfo_Visibility >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 5;
      case 5: {
        if (tag == 42) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Port)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Port)
  return false;
#undef DO_
}

void Port::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Port)
  // required uint32 number = 1;
  if (has_number()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(1, this->number(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Port.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Port.protocol");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->protocol(), output);
  }

  // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->visibility(), output);
  }

  // optional .mesos.Labels labels = 5;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, *this->labels_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Port)
}

::google::protobuf::uint8* Port::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Port)
  // required uint32 number = 1;
  if (has_number()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(1, this->number(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Port.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional string protocol = 3;
  if (has_protocol()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->protocol().data(), this->protocol().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Port.protocol");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->protocol(), target);
  }

  // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
  if (has_visibility()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->visibility(), target);
  }

  // optional .mesos.Labels labels = 5;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        5, *this->labels_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Port)
  return target;
}

int Port::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Port)
  int total_size = 0;

  // required uint32 number = 1;
  if (has_number()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::UInt32Size(
        this->number());
  }
  if (_has_bits_[1 / 32] & 30u) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string protocol = 3;
    if (has_protocol()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->protocol());
    }

    // optional .mesos.DiscoveryInfo.Visibility visibility = 4;
    if (has_visibility()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->visibility());
    }

    // optional .mesos.Labels labels = 5;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Port::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Port)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Port* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Port>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Port)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Port)
    MergeFrom(*source);
  }
}

void Port::MergeFrom(const Port& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Port)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_number()) {
      set_number(from.number());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_protocol()) {
      set_has_protocol();
      protocol_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.protocol_);
    }
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Port::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Port)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Port::CopyFrom(const Port& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Port)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Port::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void Port::Swap(Port* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Port::InternalSwap(Port* other) {
  std::swap(number_, other->number_);
  name_.Swap(&other->name_);
  protocol_.Swap(&other->protocol_);
  std::swap(visibility_, other->visibility_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Port::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Port_descriptor_;
  metadata.reflection = Port_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Port

// required uint32 number = 1;
bool Port::has_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Port::set_has_number() {
  _has_bits_[0] |= 0x00000001u;
}
void Port::clear_has_number() {
  _has_bits_[0] &= ~0x00000001u;
}
void Port::clear_number() {
  number_ = 0u;
  clear_has_number();
}
 ::google::protobuf::uint32 Port::number() const {
  // @@protoc_insertion_point(field_get:mesos.Port.number)
  return number_;
}
 void Port::set_number(::google::protobuf::uint32 value) {
  set_has_number();
  number_ = value;
  // @@protoc_insertion_point(field_set:mesos.Port.number)
}

// optional string name = 2;
bool Port::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Port::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void Port::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void Port::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Port::name() const {
  // @@protoc_insertion_point(field_get:mesos.Port.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Port::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Port.name)
}
 void Port::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Port.name)
}
 void Port::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Port.name)
}
 ::std::string* Port::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Port.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Port::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Port.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Port::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.name)
}

// optional string protocol = 3;
bool Port::has_protocol() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void Port::set_has_protocol() {
  _has_bits_[0] |= 0x00000004u;
}
void Port::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000004u;
}
void Port::clear_protocol() {
  protocol_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_protocol();
}
 const ::std::string& Port::protocol() const {
  // @@protoc_insertion_point(field_get:mesos.Port.protocol)
  return protocol_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Port::set_protocol(const ::std::string& value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Port.protocol)
}
 void Port::set_protocol(const char* value) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Port.protocol)
}
 void Port::set_protocol(const char* value, size_t size) {
  set_has_protocol();
  protocol_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Port.protocol)
}
 ::std::string* Port::mutable_protocol() {
  set_has_protocol();
  // @@protoc_insertion_point(field_mutable:mesos.Port.protocol)
  return protocol_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Port::release_protocol() {
  // @@protoc_insertion_point(field_release:mesos.Port.protocol)
  clear_has_protocol();
  return protocol_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Port::set_allocated_protocol(::std::string* protocol) {
  if (protocol != NULL) {
    set_has_protocol();
  } else {
    clear_has_protocol();
  }
  protocol_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), protocol);
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.protocol)
}

// optional .mesos.DiscoveryInfo.Visibility visibility = 4;
bool Port::has_visibility() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void Port::set_has_visibility() {
  _has_bits_[0] |= 0x00000008u;
}
void Port::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000008u;
}
void Port::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
 ::mesos::DiscoveryInfo_Visibility Port::visibility() const {
  // @@protoc_insertion_point(field_get:mesos.Port.visibility)
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
 void Port::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:mesos.Port.visibility)
}

// optional .mesos.Labels labels = 5;
bool Port::has_labels() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void Port::set_has_labels() {
  _has_bits_[0] |= 0x00000010u;
}
void Port::clear_has_labels() {
  _has_bits_[0] &= ~0x00000010u;
}
void Port::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& Port::labels() const {
  // @@protoc_insertion_point(field_get:mesos.Port.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* Port::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.Port.labels)
  return labels_;
}
::mesos::Labels* Port::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.Port.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void Port::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.Port.labels)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Ports::kPortsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Ports::Ports()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Ports)
}

void Ports::InitAsDefaultInstance() {
}

Ports::Ports(const Ports& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Ports)
}

void Ports::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Ports::~Ports() {
  // @@protoc_insertion_point(destructor:mesos.Ports)
  SharedDtor();
}

void Ports::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Ports::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Ports::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Ports_descriptor_;
}

const Ports& Ports::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Ports* Ports::default_instance_ = NULL;

Ports* Ports::New(::google::protobuf::Arena* arena) const {
  Ports* n = new Ports;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Ports::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Ports)
  ports_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Ports::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Ports)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .mesos.Port ports = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_ports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_ports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_ports;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Ports)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Ports)
  return false;
#undef DO_
}

void Ports::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Ports)
  // repeated .mesos.Port ports = 1;
  for (unsigned int i = 0, n = this->ports_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->ports(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Ports)
}

::google::protobuf::uint8* Ports::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Ports)
  // repeated .mesos.Port ports = 1;
  for (unsigned int i = 0, n = this->ports_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, this->ports(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Ports)
  return target;
}

int Ports::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Ports)
  int total_size = 0;

  // repeated .mesos.Port ports = 1;
  total_size += 1 * this->ports_size();
  for (int i = 0; i < this->ports_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->ports(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Ports::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Ports)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Ports* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Ports>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Ports)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Ports)
    MergeFrom(*source);
  }
}

void Ports::MergeFrom(const Ports& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Ports)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  ports_.MergeFrom(from.ports_);
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Ports::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Ports)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Ports::CopyFrom(const Ports& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Ports)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Ports::IsInitialized() const {

  if (!::google::protobuf::internal::AllAreInitialized(this->ports())) return false;
  return true;
}

void Ports::Swap(Ports* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Ports::InternalSwap(Ports* other) {
  ports_.UnsafeArenaSwap(&other->ports_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Ports::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Ports_descriptor_;
  metadata.reflection = Ports_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Ports

// repeated .mesos.Port ports = 1;
int Ports::ports_size() const {
  return ports_.size();
}
void Ports::clear_ports() {
  ports_.Clear();
}
const ::mesos::Port& Ports::ports(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Ports.ports)
  return ports_.Get(index);
}
::mesos::Port* Ports::mutable_ports(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Ports.ports)
  return ports_.Mutable(index);
}
::mesos::Port* Ports::add_ports() {
  // @@protoc_insertion_point(field_add:mesos.Ports.ports)
  return ports_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Port >*
Ports::mutable_ports() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Ports.ports)
  return &ports_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Port >&
Ports::ports() const {
  // @@protoc_insertion_point(field_list:mesos.Ports.ports)
  return ports_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

const ::google::protobuf::EnumDescriptor* DiscoveryInfo_Visibility_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiscoveryInfo_Visibility_descriptor_;
}
bool DiscoveryInfo_Visibility_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const DiscoveryInfo_Visibility DiscoveryInfo::FRAMEWORK;
const DiscoveryInfo_Visibility DiscoveryInfo::CLUSTER;
const DiscoveryInfo_Visibility DiscoveryInfo::EXTERNAL;
const DiscoveryInfo_Visibility DiscoveryInfo::Visibility_MIN;
const DiscoveryInfo_Visibility DiscoveryInfo::Visibility_MAX;
const int DiscoveryInfo::Visibility_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DiscoveryInfo::kVisibilityFieldNumber;
const int DiscoveryInfo::kNameFieldNumber;
const int DiscoveryInfo::kEnvironmentFieldNumber;
const int DiscoveryInfo::kLocationFieldNumber;
const int DiscoveryInfo::kVersionFieldNumber;
const int DiscoveryInfo::kPortsFieldNumber;
const int DiscoveryInfo::kLabelsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DiscoveryInfo::DiscoveryInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.DiscoveryInfo)
}

void DiscoveryInfo::InitAsDefaultInstance() {
  ports_ = const_cast< ::mesos::Ports*>(&::mesos::Ports::default_instance());
  labels_ = const_cast< ::mesos::Labels*>(&::mesos::Labels::default_instance());
}

DiscoveryInfo::DiscoveryInfo(const DiscoveryInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.DiscoveryInfo)
}

void DiscoveryInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  visibility_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  environment_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ports_ = NULL;
  labels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DiscoveryInfo::~DiscoveryInfo() {
  // @@protoc_insertion_point(destructor:mesos.DiscoveryInfo)
  SharedDtor();
}

void DiscoveryInfo::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  environment_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  location_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete ports_;
    delete labels_;
  }
}

void DiscoveryInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DiscoveryInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DiscoveryInfo_descriptor_;
}

const DiscoveryInfo& DiscoveryInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

DiscoveryInfo* DiscoveryInfo::default_instance_ = NULL;

DiscoveryInfo* DiscoveryInfo::New(::google::protobuf::Arena* arena) const {
  DiscoveryInfo* n = new DiscoveryInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DiscoveryInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.DiscoveryInfo)
  if (_has_bits_[0 / 32] & 127u) {
    visibility_ = 0;
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_environment()) {
      environment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_location()) {
      location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_version()) {
      version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_ports()) {
      if (ports_ != NULL) ports_->::mesos::Ports::Clear();
    }
    if (has_labels()) {
      if (labels_ != NULL) labels_->::mesos::Labels::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool DiscoveryInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.DiscoveryInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .mesos.DiscoveryInfo.Visibility visibility = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::mesos::DiscoveryInfo_Visibility_IsValid(value)) {
            set_visibility(static_cast< ::mesos::DiscoveryInfo_Visibility >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }

      // optional string name = 2;
      case 2: {
        if (tag == 18) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.DiscoveryInfo.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_environment;
        break;
      }

      // optional string environment = 3;
      case 3: {
        if (tag == 26) {
         parse_environment:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_environment()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->environment().data(), this->environment().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.DiscoveryInfo.environment");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_location;
        break;
      }

      // optional string location = 4;
      case 4: {
        if (tag == 34) {
         parse_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_location()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->location().data(), this->location().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.DiscoveryInfo.location");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_version;
        break;
      }

      // optional string version = 5;
      case 5: {
        if (tag == 42) {
         parse_version:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.DiscoveryInfo.version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_ports;
        break;
      }

      // optional .mesos.Ports ports = 6;
      case 6: {
        if (tag == 50) {
         parse_ports:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ports()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_labels;
        break;
      }

      // optional .mesos.Labels labels = 7;
      case 7: {
        if (tag == 58) {
         parse_labels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labels()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.DiscoveryInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.DiscoveryInfo)
  return false;
#undef DO_
}

void DiscoveryInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.DiscoveryInfo)
  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  if (has_visibility()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->visibility(), output);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional string environment = 3;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->environment().data(), this->environment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.environment");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->environment(), output);
  }

  // optional string location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.location");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->location(), output);
  }

  // optional string version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->version(), output);
  }

  // optional .mesos.Ports ports = 6;
  if (has_ports()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, *this->ports_, output);
  }

  // optional .mesos.Labels labels = 7;
  if (has_labels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, *this->labels_, output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.DiscoveryInfo)
}

::google::protobuf::uint8* DiscoveryInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.DiscoveryInfo)
  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  if (has_visibility()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->visibility(), target);
  }

  // optional string name = 2;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional string environment = 3;
  if (has_environment()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->environment().data(), this->environment().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.environment");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->environment(), target);
  }

  // optional string location = 4;
  if (has_location()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->location().data(), this->location().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.location");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->location(), target);
  }

  // optional string version = 5;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.DiscoveryInfo.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->version(), target);
  }

  // optional .mesos.Ports ports = 6;
  if (has_ports()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        6, *this->ports_, false, target);
  }

  // optional .mesos.Labels labels = 7;
  if (has_labels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        7, *this->labels_, false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.DiscoveryInfo)
  return target;
}

int DiscoveryInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.DiscoveryInfo)
  int total_size = 0;

  // required .mesos.DiscoveryInfo.Visibility visibility = 1;
  if (has_visibility()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->visibility());
  }
  if (_has_bits_[1 / 32] & 126u) {
    // optional string name = 2;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional string environment = 3;
    if (has_environment()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->environment());
    }

    // optional string location = 4;
    if (has_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->location());
    }

    // optional string version = 5;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->version());
    }

    // optional .mesos.Ports ports = 6;
    if (has_ports()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->ports_);
    }

    // optional .mesos.Labels labels = 7;
    if (has_labels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->labels_);
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DiscoveryInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.DiscoveryInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DiscoveryInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DiscoveryInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.DiscoveryInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.DiscoveryInfo)
    MergeFrom(*source);
  }
}

void DiscoveryInfo::MergeFrom(const DiscoveryInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.DiscoveryInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_visibility()) {
      set_visibility(from.visibility());
    }
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_environment()) {
      set_has_environment();
      environment_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.environment_);
    }
    if (from.has_location()) {
      set_has_location();
      location_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.location_);
    }
    if (from.has_version()) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (from.has_ports()) {
      mutable_ports()->::mesos::Ports::MergeFrom(from.ports());
    }
    if (from.has_labels()) {
      mutable_labels()->::mesos::Labels::MergeFrom(from.labels());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void DiscoveryInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.DiscoveryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DiscoveryInfo::CopyFrom(const DiscoveryInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.DiscoveryInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DiscoveryInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_ports()) {
    if (!this->ports_->IsInitialized()) return false;
  }
  if (has_labels()) {
    if (!this->labels_->IsInitialized()) return false;
  }
  return true;
}

void DiscoveryInfo::Swap(DiscoveryInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DiscoveryInfo::InternalSwap(DiscoveryInfo* other) {
  std::swap(visibility_, other->visibility_);
  name_.Swap(&other->name_);
  environment_.Swap(&other->environment_);
  location_.Swap(&other->location_);
  version_.Swap(&other->version_);
  std::swap(ports_, other->ports_);
  std::swap(labels_, other->labels_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DiscoveryInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DiscoveryInfo_descriptor_;
  metadata.reflection = DiscoveryInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DiscoveryInfo

// required .mesos.DiscoveryInfo.Visibility visibility = 1;
bool DiscoveryInfo::has_visibility() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void DiscoveryInfo::set_has_visibility() {
  _has_bits_[0] |= 0x00000001u;
}
void DiscoveryInfo::clear_has_visibility() {
  _has_bits_[0] &= ~0x00000001u;
}
void DiscoveryInfo::clear_visibility() {
  visibility_ = 0;
  clear_has_visibility();
}
 ::mesos::DiscoveryInfo_Visibility DiscoveryInfo::visibility() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.visibility)
  return static_cast< ::mesos::DiscoveryInfo_Visibility >(visibility_);
}
 void DiscoveryInfo::set_visibility(::mesos::DiscoveryInfo_Visibility value) {
  assert(::mesos::DiscoveryInfo_Visibility_IsValid(value));
  set_has_visibility();
  visibility_ = value;
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.visibility)
}

// optional string name = 2;
bool DiscoveryInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void DiscoveryInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
void DiscoveryInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
void DiscoveryInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& DiscoveryInfo::name() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.name)
}
 void DiscoveryInfo::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.name)
}
 void DiscoveryInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.name)
}
 ::std::string* DiscoveryInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DiscoveryInfo::release_name() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.name)
}

// optional string environment = 3;
bool DiscoveryInfo::has_environment() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void DiscoveryInfo::set_has_environment() {
  _has_bits_[0] |= 0x00000004u;
}
void DiscoveryInfo::clear_has_environment() {
  _has_bits_[0] &= ~0x00000004u;
}
void DiscoveryInfo::clear_environment() {
  environment_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_environment();
}
 const ::std::string& DiscoveryInfo::environment() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.environment)
  return environment_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_environment(const ::std::string& value) {
  set_has_environment();
  environment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.environment)
}
 void DiscoveryInfo::set_environment(const char* value) {
  set_has_environment();
  environment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.environment)
}
 void DiscoveryInfo::set_environment(const char* value, size_t size) {
  set_has_environment();
  environment_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.environment)
}
 ::std::string* DiscoveryInfo::mutable_environment() {
  set_has_environment();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.environment)
  return environment_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DiscoveryInfo::release_environment() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.environment)
  clear_has_environment();
  return environment_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_allocated_environment(::std::string* environment) {
  if (environment != NULL) {
    set_has_environment();
  } else {
    clear_has_environment();
  }
  environment_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), environment);
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.environment)
}

// optional string location = 4;
bool DiscoveryInfo::has_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void DiscoveryInfo::set_has_location() {
  _has_bits_[0] |= 0x00000008u;
}
void DiscoveryInfo::clear_has_location() {
  _has_bits_[0] &= ~0x00000008u;
}
void DiscoveryInfo::clear_location() {
  location_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_location();
}
 const ::std::string& DiscoveryInfo::location() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.location)
  return location_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_location(const ::std::string& value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.location)
}
 void DiscoveryInfo::set_location(const char* value) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.location)
}
 void DiscoveryInfo::set_location(const char* value, size_t size) {
  set_has_location();
  location_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.location)
}
 ::std::string* DiscoveryInfo::mutable_location() {
  set_has_location();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.location)
  return location_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DiscoveryInfo::release_location() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.location)
  clear_has_location();
  return location_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_allocated_location(::std::string* location) {
  if (location != NULL) {
    set_has_location();
  } else {
    clear_has_location();
  }
  location_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), location);
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.location)
}

// optional string version = 5;
bool DiscoveryInfo::has_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void DiscoveryInfo::set_has_version() {
  _has_bits_[0] |= 0x00000010u;
}
void DiscoveryInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000010u;
}
void DiscoveryInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
 const ::std::string& DiscoveryInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.DiscoveryInfo.version)
}
 void DiscoveryInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.DiscoveryInfo.version)
}
 void DiscoveryInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.DiscoveryInfo.version)
}
 ::std::string* DiscoveryInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DiscoveryInfo::release_version() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DiscoveryInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.version)
}

// optional .mesos.Ports ports = 6;
bool DiscoveryInfo::has_ports() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void DiscoveryInfo::set_has_ports() {
  _has_bits_[0] |= 0x00000020u;
}
void DiscoveryInfo::clear_has_ports() {
  _has_bits_[0] &= ~0x00000020u;
}
void DiscoveryInfo::clear_ports() {
  if (ports_ != NULL) ports_->::mesos::Ports::Clear();
  clear_has_ports();
}
const ::mesos::Ports& DiscoveryInfo::ports() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.ports)
  return ports_ != NULL ? *ports_ : *default_instance_->ports_;
}
::mesos::Ports* DiscoveryInfo::mutable_ports() {
  set_has_ports();
  if (ports_ == NULL) {
    ports_ = new ::mesos::Ports;
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.ports)
  return ports_;
}
::mesos::Ports* DiscoveryInfo::release_ports() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.ports)
  clear_has_ports();
  ::mesos::Ports* temp = ports_;
  ports_ = NULL;
  return temp;
}
void DiscoveryInfo::set_allocated_ports(::mesos::Ports* ports) {
  delete ports_;
  ports_ = ports;
  if (ports) {
    set_has_ports();
  } else {
    clear_has_ports();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.ports)
}

// optional .mesos.Labels labels = 7;
bool DiscoveryInfo::has_labels() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void DiscoveryInfo::set_has_labels() {
  _has_bits_[0] |= 0x00000040u;
}
void DiscoveryInfo::clear_has_labels() {
  _has_bits_[0] &= ~0x00000040u;
}
void DiscoveryInfo::clear_labels() {
  if (labels_ != NULL) labels_->::mesos::Labels::Clear();
  clear_has_labels();
}
const ::mesos::Labels& DiscoveryInfo::labels() const {
  // @@protoc_insertion_point(field_get:mesos.DiscoveryInfo.labels)
  return labels_ != NULL ? *labels_ : *default_instance_->labels_;
}
::mesos::Labels* DiscoveryInfo::mutable_labels() {
  set_has_labels();
  if (labels_ == NULL) {
    labels_ = new ::mesos::Labels;
  }
  // @@protoc_insertion_point(field_mutable:mesos.DiscoveryInfo.labels)
  return labels_;
}
::mesos::Labels* DiscoveryInfo::release_labels() {
  // @@protoc_insertion_point(field_release:mesos.DiscoveryInfo.labels)
  clear_has_labels();
  ::mesos::Labels* temp = labels_;
  labels_ = NULL;
  return temp;
}
void DiscoveryInfo::set_allocated_labels(::mesos::Labels* labels) {
  delete labels_;
  labels_ = labels;
  if (labels) {
    set_has_labels();
  } else {
    clear_has_labels();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.DiscoveryInfo.labels)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int WeightInfo::kWeightFieldNumber;
const int WeightInfo::kRoleFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

WeightInfo::WeightInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.WeightInfo)
}

void WeightInfo::InitAsDefaultInstance() {
}

WeightInfo::WeightInfo(const WeightInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.WeightInfo)
}

void WeightInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  weight_ = 0;
  role_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WeightInfo::~WeightInfo() {
  // @@protoc_insertion_point(destructor:mesos.WeightInfo)
  SharedDtor();
}

void WeightInfo::SharedDtor() {
  role_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void WeightInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WeightInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WeightInfo_descriptor_;
}

const WeightInfo& WeightInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

WeightInfo* WeightInfo::default_instance_ = NULL;

WeightInfo* WeightInfo::New(::google::protobuf::Arena* arena) const {
  WeightInfo* n = new WeightInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void WeightInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.WeightInfo)
  if (_has_bits_[0 / 32] & 3u) {
    weight_ = 0;
    if (has_role()) {
      role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool WeightInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.WeightInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double weight = 1;
      case 1: {
        if (tag == 9) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &weight_)));
          set_has_weight();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_role;
        break;
      }

      // optional string role = 2;
      case 2: {
        if (tag == 18) {
         parse_role:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_role()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->role().data(), this->role().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.WeightInfo.role");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.WeightInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.WeightInfo)
  return false;
#undef DO_
}

void WeightInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.WeightInfo)
  // required double weight = 1;
  if (has_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->weight(), output);
  }

  // optional string role = 2;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.WeightInfo.role");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->role(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.WeightInfo)
}

::google::protobuf::uint8* WeightInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.WeightInfo)
  // required double weight = 1;
  if (has_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->weight(), target);
  }

  // optional string role = 2;
  if (has_role()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->role().data(), this->role().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.WeightInfo.role");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->role(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.WeightInfo)
  return target;
}

int WeightInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.WeightInfo)
  int total_size = 0;

  // required double weight = 1;
  if (has_weight()) {
    total_size += 1 + 8;
  }
  // optional string role = 2;
  if (has_role()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->role());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WeightInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.WeightInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const WeightInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const WeightInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.WeightInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.WeightInfo)
    MergeFrom(*source);
  }
}

void WeightInfo::MergeFrom(const WeightInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.WeightInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_weight()) {
      set_weight(from.weight());
    }
    if (from.has_role()) {
      set_has_role();
      role_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.role_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void WeightInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.WeightInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WeightInfo::CopyFrom(const WeightInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.WeightInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WeightInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void WeightInfo::Swap(WeightInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void WeightInfo::InternalSwap(WeightInfo* other) {
  std::swap(weight_, other->weight_);
  role_.Swap(&other->role_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata WeightInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WeightInfo_descriptor_;
  metadata.reflection = WeightInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// WeightInfo

// required double weight = 1;
bool WeightInfo::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void WeightInfo::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
void WeightInfo::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
void WeightInfo::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
 double WeightInfo::weight() const {
  // @@protoc_insertion_point(field_get:mesos.WeightInfo.weight)
  return weight_;
}
 void WeightInfo::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:mesos.WeightInfo.weight)
}

// optional string role = 2;
bool WeightInfo::has_role() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void WeightInfo::set_has_role() {
  _has_bits_[0] |= 0x00000002u;
}
void WeightInfo::clear_has_role() {
  _has_bits_[0] &= ~0x00000002u;
}
void WeightInfo::clear_role() {
  role_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_role();
}
 const ::std::string& WeightInfo::role() const {
  // @@protoc_insertion_point(field_get:mesos.WeightInfo.role)
  return role_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void WeightInfo::set_role(const ::std::string& value) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.WeightInfo.role)
}
 void WeightInfo::set_role(const char* value) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.WeightInfo.role)
}
 void WeightInfo::set_role(const char* value, size_t size) {
  set_has_role();
  role_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.WeightInfo.role)
}
 ::std::string* WeightInfo::mutable_role() {
  set_has_role();
  // @@protoc_insertion_point(field_mutable:mesos.WeightInfo.role)
  return role_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* WeightInfo::release_role() {
  // @@protoc_insertion_point(field_release:mesos.WeightInfo.role)
  clear_has_role();
  return role_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void WeightInfo::set_allocated_role(::std::string* role) {
  if (role != NULL) {
    set_has_role();
  } else {
    clear_has_role();
  }
  role_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), role);
  // @@protoc_insertion_point(field_set_allocated:mesos.WeightInfo.role)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VersionInfo::kVersionFieldNumber;
const int VersionInfo::kBuildDateFieldNumber;
const int VersionInfo::kBuildTimeFieldNumber;
const int VersionInfo::kBuildUserFieldNumber;
const int VersionInfo::kGitShaFieldNumber;
const int VersionInfo::kGitBranchFieldNumber;
const int VersionInfo::kGitTagFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VersionInfo::VersionInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.VersionInfo)
}

void VersionInfo::InitAsDefaultInstance() {
}

VersionInfo::VersionInfo(const VersionInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.VersionInfo)
}

void VersionInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  version_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_date_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_time_ = 0;
  build_user_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_sha_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_branch_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_tag_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VersionInfo::~VersionInfo() {
  // @@protoc_insertion_point(destructor:mesos.VersionInfo)
  SharedDtor();
}

void VersionInfo::SharedDtor() {
  version_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_date_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  build_user_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_sha_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_branch_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  git_tag_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void VersionInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VersionInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VersionInfo_descriptor_;
}

const VersionInfo& VersionInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

VersionInfo* VersionInfo::default_instance_ = NULL;

VersionInfo* VersionInfo::New(::google::protobuf::Arena* arena) const {
  VersionInfo* n = new VersionInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VersionInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.VersionInfo)
  if (_has_bits_[0 / 32] & 127u) {
    if (has_version()) {
      version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_build_date()) {
      build_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    build_time_ = 0;
    if (has_build_user()) {
      build_user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_git_sha()) {
      git_sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_git_branch()) {
      git_branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_git_tag()) {
      git_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool VersionInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.VersionInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string version = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_version()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->version().data(), this->version().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.VersionInfo.version");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_build_date;
        break;
      }

      // optional string build_date = 2;
      case 2: {
        if (tag == 18) {
         parse_build_date:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_date()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->build_date().data(), this->build_date().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.VersionInfo.build_date");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_build_time;
        break;
      }

      // optional double build_time = 3;
      case 3: {
        if (tag == 25) {
         parse_build_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &build_time_)));
          set_has_build_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_build_user;
        break;
      }

      // optional string build_user = 4;
      case 4: {
        if (tag == 34) {
         parse_build_user:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_build_user()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->build_user().data(), this->build_user().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.VersionInfo.build_user");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_git_sha;
        break;
      }

      // optional string git_sha = 5;
      case 5: {
        if (tag == 42) {
         parse_git_sha:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_git_sha()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->git_sha().data(), this->git_sha().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.VersionInfo.git_sha");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_git_branch;
        break;
      }

      // optional string git_branch = 6;
      case 6: {
        if (tag == 50) {
         parse_git_branch:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_git_branch()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->git_branch().data(), this->git_branch().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.VersionInfo.git_branch");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_git_tag;
        break;
      }

      // optional string git_tag = 7;
      case 7: {
        if (tag == 58) {
         parse_git_tag:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_git_tag()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->git_tag().data(), this->git_tag().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.VersionInfo.git_tag");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.VersionInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.VersionInfo)
  return false;
#undef DO_
}

void VersionInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.VersionInfo)
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.version");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->version(), output);
  }

  // optional string build_date = 2;
  if (has_build_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_date().data(), this->build_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.build_date");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->build_date(), output);
  }

  // optional double build_time = 3;
  if (has_build_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->build_time(), output);
  }

  // optional string build_user = 4;
  if (has_build_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_user().data(), this->build_user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.build_user");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->build_user(), output);
  }

  // optional string git_sha = 5;
  if (has_git_sha()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_sha().data(), this->git_sha().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.git_sha");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->git_sha(), output);
  }

  // optional string git_branch = 6;
  if (has_git_branch()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_branch().data(), this->git_branch().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.git_branch");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->git_branch(), output);
  }

  // optional string git_tag = 7;
  if (has_git_tag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_tag().data(), this->git_tag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.git_tag");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->git_tag(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.VersionInfo)
}

::google::protobuf::uint8* VersionInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.VersionInfo)
  // required string version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->version().data(), this->version().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.version");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->version(), target);
  }

  // optional string build_date = 2;
  if (has_build_date()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_date().data(), this->build_date().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.build_date");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->build_date(), target);
  }

  // optional double build_time = 3;
  if (has_build_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->build_time(), target);
  }

  // optional string build_user = 4;
  if (has_build_user()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->build_user().data(), this->build_user().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.build_user");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->build_user(), target);
  }

  // optional string git_sha = 5;
  if (has_git_sha()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_sha().data(), this->git_sha().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.git_sha");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->git_sha(), target);
  }

  // optional string git_branch = 6;
  if (has_git_branch()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_branch().data(), this->git_branch().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.git_branch");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->git_branch(), target);
  }

  // optional string git_tag = 7;
  if (has_git_tag()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->git_tag().data(), this->git_tag().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.VersionInfo.git_tag");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->git_tag(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.VersionInfo)
  return target;
}

int VersionInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.VersionInfo)
  int total_size = 0;

  // required string version = 1;
  if (has_version()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->version());
  }
  if (_has_bits_[1 / 32] & 126u) {
    // optional string build_date = 2;
    if (has_build_date()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_date());
    }

    // optional double build_time = 3;
    if (has_build_time()) {
      total_size += 1 + 8;
    }

    // optional string build_user = 4;
    if (has_build_user()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->build_user());
    }

    // optional string git_sha = 5;
    if (has_git_sha()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->git_sha());
    }

    // optional string git_branch = 6;
    if (has_git_branch()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->git_branch());
    }

    // optional string git_tag = 7;
    if (has_git_tag()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->git_tag());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VersionInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.VersionInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const VersionInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const VersionInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.VersionInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.VersionInfo)
    MergeFrom(*source);
  }
}

void VersionInfo::MergeFrom(const VersionInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.VersionInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_has_version();
      version_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.version_);
    }
    if (from.has_build_date()) {
      set_has_build_date();
      build_date_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.build_date_);
    }
    if (from.has_build_time()) {
      set_build_time(from.build_time());
    }
    if (from.has_build_user()) {
      set_has_build_user();
      build_user_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.build_user_);
    }
    if (from.has_git_sha()) {
      set_has_git_sha();
      git_sha_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.git_sha_);
    }
    if (from.has_git_branch()) {
      set_has_git_branch();
      git_branch_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.git_branch_);
    }
    if (from.has_git_tag()) {
      set_has_git_tag();
      git_tag_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.git_tag_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void VersionInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.VersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VersionInfo::CopyFrom(const VersionInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.VersionInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VersionInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void VersionInfo::Swap(VersionInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VersionInfo::InternalSwap(VersionInfo* other) {
  version_.Swap(&other->version_);
  build_date_.Swap(&other->build_date_);
  std::swap(build_time_, other->build_time_);
  build_user_.Swap(&other->build_user_);
  git_sha_.Swap(&other->git_sha_);
  git_branch_.Swap(&other->git_branch_);
  git_tag_.Swap(&other->git_tag_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata VersionInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VersionInfo_descriptor_;
  metadata.reflection = VersionInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VersionInfo

// required string version = 1;
bool VersionInfo::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void VersionInfo::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
void VersionInfo::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
void VersionInfo::clear_version() {
  version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_version();
}
 const ::std::string& VersionInfo::version() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.version)
  return version_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_version(const ::std::string& value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.version)
}
 void VersionInfo::set_version(const char* value) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.version)
}
 void VersionInfo::set_version(const char* value, size_t size) {
  set_has_version();
  version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.version)
}
 ::std::string* VersionInfo::mutable_version() {
  set_has_version();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.version)
  return version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VersionInfo::release_version() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.version)
  clear_has_version();
  return version_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_allocated_version(::std::string* version) {
  if (version != NULL) {
    set_has_version();
  } else {
    clear_has_version();
  }
  version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), version);
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.version)
}

// optional string build_date = 2;
bool VersionInfo::has_build_date() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void VersionInfo::set_has_build_date() {
  _has_bits_[0] |= 0x00000002u;
}
void VersionInfo::clear_has_build_date() {
  _has_bits_[0] &= ~0x00000002u;
}
void VersionInfo::clear_build_date() {
  build_date_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_date();
}
 const ::std::string& VersionInfo::build_date() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_date)
  return build_date_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_build_date(const ::std::string& value) {
  set_has_build_date();
  build_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_date)
}
 void VersionInfo::set_build_date(const char* value) {
  set_has_build_date();
  build_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.build_date)
}
 void VersionInfo::set_build_date(const char* value, size_t size) {
  set_has_build_date();
  build_date_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.build_date)
}
 ::std::string* VersionInfo::mutable_build_date() {
  set_has_build_date();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.build_date)
  return build_date_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VersionInfo::release_build_date() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.build_date)
  clear_has_build_date();
  return build_date_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_allocated_build_date(::std::string* build_date) {
  if (build_date != NULL) {
    set_has_build_date();
  } else {
    clear_has_build_date();
  }
  build_date_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_date);
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.build_date)
}

// optional double build_time = 3;
bool VersionInfo::has_build_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void VersionInfo::set_has_build_time() {
  _has_bits_[0] |= 0x00000004u;
}
void VersionInfo::clear_has_build_time() {
  _has_bits_[0] &= ~0x00000004u;
}
void VersionInfo::clear_build_time() {
  build_time_ = 0;
  clear_has_build_time();
}
 double VersionInfo::build_time() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_time)
  return build_time_;
}
 void VersionInfo::set_build_time(double value) {
  set_has_build_time();
  build_time_ = value;
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_time)
}

// optional string build_user = 4;
bool VersionInfo::has_build_user() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void VersionInfo::set_has_build_user() {
  _has_bits_[0] |= 0x00000008u;
}
void VersionInfo::clear_has_build_user() {
  _has_bits_[0] &= ~0x00000008u;
}
void VersionInfo::clear_build_user() {
  build_user_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_build_user();
}
 const ::std::string& VersionInfo::build_user() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.build_user)
  return build_user_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_build_user(const ::std::string& value) {
  set_has_build_user();
  build_user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.build_user)
}
 void VersionInfo::set_build_user(const char* value) {
  set_has_build_user();
  build_user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.build_user)
}
 void VersionInfo::set_build_user(const char* value, size_t size) {
  set_has_build_user();
  build_user_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.build_user)
}
 ::std::string* VersionInfo::mutable_build_user() {
  set_has_build_user();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.build_user)
  return build_user_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VersionInfo::release_build_user() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.build_user)
  clear_has_build_user();
  return build_user_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_allocated_build_user(::std::string* build_user) {
  if (build_user != NULL) {
    set_has_build_user();
  } else {
    clear_has_build_user();
  }
  build_user_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), build_user);
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.build_user)
}

// optional string git_sha = 5;
bool VersionInfo::has_git_sha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void VersionInfo::set_has_git_sha() {
  _has_bits_[0] |= 0x00000010u;
}
void VersionInfo::clear_has_git_sha() {
  _has_bits_[0] &= ~0x00000010u;
}
void VersionInfo::clear_git_sha() {
  git_sha_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_git_sha();
}
 const ::std::string& VersionInfo::git_sha() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_sha)
  return git_sha_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_git_sha(const ::std::string& value) {
  set_has_git_sha();
  git_sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_sha)
}
 void VersionInfo::set_git_sha(const char* value) {
  set_has_git_sha();
  git_sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_sha)
}
 void VersionInfo::set_git_sha(const char* value, size_t size) {
  set_has_git_sha();
  git_sha_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_sha)
}
 ::std::string* VersionInfo::mutable_git_sha() {
  set_has_git_sha();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_sha)
  return git_sha_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VersionInfo::release_git_sha() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.git_sha)
  clear_has_git_sha();
  return git_sha_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_allocated_git_sha(::std::string* git_sha) {
  if (git_sha != NULL) {
    set_has_git_sha();
  } else {
    clear_has_git_sha();
  }
  git_sha_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git_sha);
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_sha)
}

// optional string git_branch = 6;
bool VersionInfo::has_git_branch() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void VersionInfo::set_has_git_branch() {
  _has_bits_[0] |= 0x00000020u;
}
void VersionInfo::clear_has_git_branch() {
  _has_bits_[0] &= ~0x00000020u;
}
void VersionInfo::clear_git_branch() {
  git_branch_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_git_branch();
}
 const ::std::string& VersionInfo::git_branch() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_branch)
  return git_branch_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_git_branch(const ::std::string& value) {
  set_has_git_branch();
  git_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_branch)
}
 void VersionInfo::set_git_branch(const char* value) {
  set_has_git_branch();
  git_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_branch)
}
 void VersionInfo::set_git_branch(const char* value, size_t size) {
  set_has_git_branch();
  git_branch_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_branch)
}
 ::std::string* VersionInfo::mutable_git_branch() {
  set_has_git_branch();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_branch)
  return git_branch_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VersionInfo::release_git_branch() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.git_branch)
  clear_has_git_branch();
  return git_branch_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_allocated_git_branch(::std::string* git_branch) {
  if (git_branch != NULL) {
    set_has_git_branch();
  } else {
    clear_has_git_branch();
  }
  git_branch_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git_branch);
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_branch)
}

// optional string git_tag = 7;
bool VersionInfo::has_git_tag() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void VersionInfo::set_has_git_tag() {
  _has_bits_[0] |= 0x00000040u;
}
void VersionInfo::clear_has_git_tag() {
  _has_bits_[0] &= ~0x00000040u;
}
void VersionInfo::clear_git_tag() {
  git_tag_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_git_tag();
}
 const ::std::string& VersionInfo::git_tag() const {
  // @@protoc_insertion_point(field_get:mesos.VersionInfo.git_tag)
  return git_tag_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_git_tag(const ::std::string& value) {
  set_has_git_tag();
  git_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.VersionInfo.git_tag)
}
 void VersionInfo::set_git_tag(const char* value) {
  set_has_git_tag();
  git_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.VersionInfo.git_tag)
}
 void VersionInfo::set_git_tag(const char* value, size_t size) {
  set_has_git_tag();
  git_tag_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.VersionInfo.git_tag)
}
 ::std::string* VersionInfo::mutable_git_tag() {
  set_has_git_tag();
  // @@protoc_insertion_point(field_mutable:mesos.VersionInfo.git_tag)
  return git_tag_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* VersionInfo::release_git_tag() {
  // @@protoc_insertion_point(field_release:mesos.VersionInfo.git_tag)
  clear_has_git_tag();
  return git_tag_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void VersionInfo::set_allocated_git_tag(::std::string* git_tag) {
  if (git_tag != NULL) {
    set_has_git_tag();
  } else {
    clear_has_git_tag();
  }
  git_tag_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), git_tag);
  // @@protoc_insertion_point(field_set_allocated:mesos.VersionInfo.git_tag)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Flag::kNameFieldNumber;
const int Flag::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Flag::Flag()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Flag)
}

void Flag::InitAsDefaultInstance() {
}

Flag::Flag(const Flag& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Flag)
}

void Flag::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Flag::~Flag() {
  // @@protoc_insertion_point(destructor:mesos.Flag)
  SharedDtor();
}

void Flag::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Flag::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Flag::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Flag_descriptor_;
}

const Flag& Flag::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Flag* Flag::default_instance_ = NULL;

Flag* Flag::New(::google::protobuf::Arena* arena) const {
  Flag* n = new Flag;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Flag::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Flag)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_value()) {
      value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Flag::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Flag)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Flag.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // optional string value = 2;
      case 2: {
        if (tag == 18) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Flag.value");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Flag)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Flag)
  return false;
#undef DO_
}

void Flag::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Flag)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Flag.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Flag.value");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Flag)
}

::google::protobuf::uint8* Flag::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Flag)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Flag.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Flag.value");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Flag)
  return target;
}

int Flag::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Flag)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional string value = 2;
  if (has_value()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->value());
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Flag::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Flag)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Flag* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Flag>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Flag)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Flag)
    MergeFrom(*source);
  }
}

void Flag::MergeFrom(const Flag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Flag)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_value()) {
      set_has_value();
      value_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.value_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Flag::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Flag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Flag::CopyFrom(const Flag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Flag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Flag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Flag::Swap(Flag* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Flag::InternalSwap(Flag* other) {
  name_.Swap(&other->name_);
  value_.Swap(&other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Flag::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Flag_descriptor_;
  metadata.reflection = Flag_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Flag

// required string name = 1;
bool Flag::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Flag::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Flag::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Flag::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Flag::name() const {
  // @@protoc_insertion_point(field_get:mesos.Flag.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Flag::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Flag.name)
}
 void Flag::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Flag.name)
}
 void Flag::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Flag.name)
}
 ::std::string* Flag::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Flag.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Flag::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Flag.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Flag::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Flag.name)
}

// optional string value = 2;
bool Flag::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Flag::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void Flag::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void Flag::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_value();
}
 const ::std::string& Flag::value() const {
  // @@protoc_insertion_point(field_get:mesos.Flag.value)
  return value_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Flag::set_value(const ::std::string& value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Flag.value)
}
 void Flag::set_value(const char* value) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Flag.value)
}
 void Flag::set_value(const char* value, size_t size) {
  set_has_value();
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Flag.value)
}
 ::std::string* Flag::mutable_value() {
  set_has_value();
  // @@protoc_insertion_point(field_mutable:mesos.Flag.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Flag::release_value() {
  // @@protoc_insertion_point(field_release:mesos.Flag.value)
  clear_has_value();
  return value_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Flag::set_allocated_value(::std::string* value) {
  if (value != NULL) {
    set_has_value();
  } else {
    clear_has_value();
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:mesos.Flag.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Role::kNameFieldNumber;
const int Role::kWeightFieldNumber;
const int Role::kFrameworksFieldNumber;
const int Role::kResourcesFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Role::Role()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Role)
}

void Role::InitAsDefaultInstance() {
}

Role::Role(const Role& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Role)
}

void Role::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  weight_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Role::~Role() {
  // @@protoc_insertion_point(destructor:mesos.Role)
  SharedDtor();
}

void Role::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Role::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Role::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Role_descriptor_;
}

const Role& Role::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Role* Role::default_instance_ = NULL;

Role* Role::New(::google::protobuf::Arena* arena) const {
  Role* n = new Role;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Role::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Role)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    weight_ = 0;
  }
  frameworks_.Clear();
  resources_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Role::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Role)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Role.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_weight;
        break;
      }

      // required double weight = 2;
      case 2: {
        if (tag == 17) {
         parse_weight:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &weight_)));
          set_has_weight();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_frameworks;
        break;
      }

      // repeated .mesos.FrameworkID frameworks = 3;
      case 3: {
        if (tag == 26) {
         parse_frameworks:
          DO_(input->IncrementRecursionDepth());
         parse_loop_frameworks:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_frameworks()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_loop_frameworks;
        if (input->ExpectTag(34)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        break;
      }

      // repeated .mesos.Resource resources = 4;
      case 4: {
        if (tag == 34) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_resources:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtualNoRecursionDepth(
                input, add_resources()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_loop_resources;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Role)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Role)
  return false;
#undef DO_
}

void Role::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Role)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Role.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // required double weight = 2;
  if (has_weight()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->weight(), output);
  }

  // repeated .mesos.FrameworkID frameworks = 3;
  for (unsigned int i = 0, n = this->frameworks_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->frameworks(i), output);
  }

  // repeated .mesos.Resource resources = 4;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->resources(i), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Role)
}

::google::protobuf::uint8* Role::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Role)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Role.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required double weight = 2;
  if (has_weight()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->weight(), target);
  }

  // repeated .mesos.FrameworkID frameworks = 3;
  for (unsigned int i = 0, n = this->frameworks_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        3, this->frameworks(i), false, target);
  }

  // repeated .mesos.Resource resources = 4;
  for (unsigned int i = 0, n = this->resources_size(); i < n; i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, this->resources(i), false, target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Role)
  return target;
}

int Role::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:mesos.Role)
  int total_size = 0;

  if (has_name()) {
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }

  if (has_weight()) {
    // required double weight = 2;
    total_size += 1 + 8;
  }

  return total_size;
}
int Role::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Role)
  int total_size = 0;

  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required string name = 1;
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());

    // required double weight = 2;
    total_size += 1 + 8;

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  // repeated .mesos.FrameworkID frameworks = 3;
  total_size += 1 * this->frameworks_size();
  for (int i = 0; i < this->frameworks_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->frameworks(i));
  }

  // repeated .mesos.Resource resources = 4;
  total_size += 1 * this->resources_size();
  for (int i = 0; i < this->resources_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->resources(i));
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Role::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Role)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Role* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Role>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Role)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Role)
    MergeFrom(*source);
  }
}

void Role::MergeFrom(const Role& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Role)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  frameworks_.MergeFrom(from.frameworks_);
  resources_.MergeFrom(from.resources_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_weight()) {
      set_weight(from.weight());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Role::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Role)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Role::CopyFrom(const Role& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Role)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Role::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->frameworks())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->resources())) return false;
  return true;
}

void Role::Swap(Role* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Role::InternalSwap(Role* other) {
  name_.Swap(&other->name_);
  std::swap(weight_, other->weight_);
  frameworks_.UnsafeArenaSwap(&other->frameworks_);
  resources_.UnsafeArenaSwap(&other->resources_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Role::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Role_descriptor_;
  metadata.reflection = Role_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Role

// required string name = 1;
bool Role::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Role::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Role::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Role::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Role::name() const {
  // @@protoc_insertion_point(field_get:mesos.Role.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Role::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Role.name)
}
 void Role::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Role.name)
}
 void Role::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Role.name)
}
 ::std::string* Role::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Role.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Role::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Role.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Role::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Role.name)
}

// required double weight = 2;
bool Role::has_weight() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Role::set_has_weight() {
  _has_bits_[0] |= 0x00000002u;
}
void Role::clear_has_weight() {
  _has_bits_[0] &= ~0x00000002u;
}
void Role::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
 double Role::weight() const {
  // @@protoc_insertion_point(field_get:mesos.Role.weight)
  return weight_;
}
 void Role::set_weight(double value) {
  set_has_weight();
  weight_ = value;
  // @@protoc_insertion_point(field_set:mesos.Role.weight)
}

// repeated .mesos.FrameworkID frameworks = 3;
int Role::frameworks_size() const {
  return frameworks_.size();
}
void Role::clear_frameworks() {
  frameworks_.Clear();
}
const ::mesos::FrameworkID& Role::frameworks(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Role.frameworks)
  return frameworks_.Get(index);
}
::mesos::FrameworkID* Role::mutable_frameworks(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Role.frameworks)
  return frameworks_.Mutable(index);
}
::mesos::FrameworkID* Role::add_frameworks() {
  // @@protoc_insertion_point(field_add:mesos.Role.frameworks)
  return frameworks_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >*
Role::mutable_frameworks() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Role.frameworks)
  return &frameworks_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::FrameworkID >&
Role::frameworks() const {
  // @@protoc_insertion_point(field_list:mesos.Role.frameworks)
  return frameworks_;
}

// repeated .mesos.Resource resources = 4;
int Role::resources_size() const {
  return resources_.size();
}
void Role::clear_resources() {
  resources_.Clear();
}
const ::mesos::Resource& Role::resources(int index) const {
  // @@protoc_insertion_point(field_get:mesos.Role.resources)
  return resources_.Get(index);
}
::mesos::Resource* Role::mutable_resources(int index) {
  // @@protoc_insertion_point(field_mutable:mesos.Role.resources)
  return resources_.Mutable(index);
}
::mesos::Resource* Role::add_resources() {
  // @@protoc_insertion_point(field_add:mesos.Role.resources)
  return resources_.Add();
}
::google::protobuf::RepeatedPtrField< ::mesos::Resource >*
Role::mutable_resources() {
  // @@protoc_insertion_point(field_mutable_list:mesos.Role.resources)
  return &resources_;
}
const ::google::protobuf::RepeatedPtrField< ::mesos::Resource >&
Role::resources() const {
  // @@protoc_insertion_point(field_list:mesos.Role.resources)
  return resources_;
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Metric::kNameFieldNumber;
const int Metric::kValueFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Metric::Metric()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.Metric)
}

void Metric::InitAsDefaultInstance() {
}

Metric::Metric(const Metric& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.Metric)
}

void Metric::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  name_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  value_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Metric::~Metric() {
  // @@protoc_insertion_point(destructor:mesos.Metric)
  SharedDtor();
}

void Metric::SharedDtor() {
  name_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Metric::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Metric::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Metric_descriptor_;
}

const Metric& Metric::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

Metric* Metric::default_instance_ = NULL;

Metric* Metric::New(::google::protobuf::Arena* arena) const {
  Metric* n = new Metric;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Metric::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.Metric)
  if (_has_bits_[0 / 32] & 3u) {
    if (has_name()) {
      name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    value_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool Metric::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.Metric)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.Metric.name");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_value;
        break;
      }

      // optional double value = 2;
      case 2: {
        if (tag == 17) {
         parse_value:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &value_)));
          set_has_value();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.Metric)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.Metric)
  return false;
#undef DO_
}

void Metric::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.Metric)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Metric.name");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->name(), output);
  }

  // optional double value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->value(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.Metric)
}

::google::protobuf::uint8* Metric::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.Metric)
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.Metric.name");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // optional double value = 2;
  if (has_value()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->value(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.Metric)
  return target;
}

int Metric::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.Metric)
  int total_size = 0;

  // required string name = 1;
  if (has_name()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->name());
  }
  // optional double value = 2;
  if (has_value()) {
    total_size += 1 + 8;
  }

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Metric::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.Metric)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Metric* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Metric>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.Metric)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.Metric)
    MergeFrom(*source);
  }
}

void Metric::MergeFrom(const Metric& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.Metric)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_has_name();
      name_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void Metric::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Metric::CopyFrom(const Metric& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.Metric)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Metric::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Metric::Swap(Metric* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Metric::InternalSwap(Metric* other) {
  name_.Swap(&other->name_);
  std::swap(value_, other->value_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Metric::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Metric_descriptor_;
  metadata.reflection = Metric_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Metric

// required string name = 1;
bool Metric::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void Metric::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
void Metric::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
void Metric::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
 const ::std::string& Metric::name() const {
  // @@protoc_insertion_point(field_get:mesos.Metric.name)
  return name_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Metric::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.Metric.name)
}
 void Metric::set_name(const char* value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.Metric.name)
}
 void Metric::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.Metric.name)
}
 ::std::string* Metric::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:mesos.Metric.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Metric::release_name() {
  // @@protoc_insertion_point(field_release:mesos.Metric.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Metric::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:mesos.Metric.name)
}

// optional double value = 2;
bool Metric::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void Metric::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
void Metric::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
void Metric::clear_value() {
  value_ = 0;
  clear_has_value();
}
 double Metric::value() const {
  // @@protoc_insertion_point(field_get:mesos.Metric.value)
  return value_;
}
 void Metric::set_value(double value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:mesos.Metric.value)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int FileInfo::kPathFieldNumber;
const int FileInfo::kNlinkFieldNumber;
const int FileInfo::kSizeFieldNumber;
const int FileInfo::kMtimeFieldNumber;
const int FileInfo::kModeFieldNumber;
const int FileInfo::kUidFieldNumber;
const int FileInfo::kGidFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

FileInfo::FileInfo()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:mesos.FileInfo)
}

void FileInfo::InitAsDefaultInstance() {
  mtime_ = const_cast< ::mesos::TimeInfo*>(&::mesos::TimeInfo::default_instance());
}

FileInfo::FileInfo(const FileInfo& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:mesos.FileInfo)
}

void FileInfo::SharedCtor() {
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  path_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlink_ = 0;
  size_ = GOOGLE_ULONGLONG(0);
  mtime_ = NULL;
  mode_ = 0u;
  uid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileInfo::~FileInfo() {
  // @@protoc_insertion_point(destructor:mesos.FileInfo)
  SharedDtor();
}

void FileInfo::SharedDtor() {
  path_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  uid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  gid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete mtime_;
  }
}

void FileInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileInfo_descriptor_;
}

const FileInfo& FileInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_mesos_2eproto();
  return *default_instance_;
}

FileInfo* FileInfo::default_instance_ = NULL;

FileInfo* FileInfo::New(::google::protobuf::Arena* arena) const {
  FileInfo* n = new FileInfo;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void FileInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:mesos.FileInfo)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(FileInfo, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<FileInfo*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  if (_has_bits_[0 / 32] & 127u) {
    ZR_(size_, mode_);
    if (has_path()) {
      path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_mtime()) {
      if (mtime_ != NULL) mtime_->::mesos::TimeInfo::Clear();
    }
    if (has_uid()) {
      uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
    if (has_gid()) {
      gid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    }
  }

#undef ZR_HELPER_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  if (_internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->Clear();
  }
}

bool FileInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:mesos.FileInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string path = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_path()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->path().data(), this->path().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FileInfo.path");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_nlink;
        break;
      }

      // optional int32 nlink = 2;
      case 2: {
        if (tag == 16) {
         parse_nlink:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &nlink_)));
          set_has_nlink();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_size;
        break;
      }

      // optional uint64 size = 3;
      case 3: {
        if (tag == 24) {
         parse_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_UINT64>(
                 input, &size_)));
          set_has_size();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_mtime;
        break;
      }

      // optional .mesos.TimeInfo mtime = 4;
      case 4: {
        if (tag == 34) {
         parse_mtime:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mtime()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_mode;
        break;
      }

      // optional uint32 mode = 5;
      case 5: {
        if (tag == 40) {
         parse_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_UINT32>(
                 input, &mode_)));
          set_has_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_uid;
        break;
      }

      // optional string uid = 6;
      case 6: {
        if (tag == 50) {
         parse_uid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_uid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->uid().data(), this->uid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FileInfo.uid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_gid;
        break;
      }

      // optional string gid = 7;
      case 7: {
        if (tag == 58) {
         parse_gid:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_gid()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
            this->gid().data(), this->gid().length(),
            ::google::protobuf::internal::WireFormat::PARSE,
            "mesos.FileInfo.gid");
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:mesos.FileInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:mesos.FileInfo)
  return false;
#undef DO_
}

void FileInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:mesos.FileInfo)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FileInfo.path");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->path(), output);
  }

  // optional int32 nlink = 2;
  if (has_nlink()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->nlink(), output);
  }

  // optional uint64 size = 3;
  if (has_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt64(3, this->size(), output);
  }

  // optional .mesos.TimeInfo mtime = 4;
  if (has_mtime()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, *this->mtime_, output);
  }

  // optional uint32 mode = 5;
  if (has_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteUInt32(5, this->mode(), output);
  }

  // optional string uid = 6;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uid().data(), this->uid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FileInfo.uid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->uid(), output);
  }

  // optional string gid = 7;
  if (has_gid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gid().data(), this->gid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FileInfo.gid");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      7, this->gid(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:mesos.FileInfo)
}

::google::protobuf::uint8* FileInfo::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:mesos.FileInfo)
  // required string path = 1;
  if (has_path()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->path().data(), this->path().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FileInfo.path");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->path(), target);
  }

  // optional int32 nlink = 2;
  if (has_nlink()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->nlink(), target);
  }

  // optional uint64 size = 3;
  if (has_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt64ToArray(3, this->size(), target);
  }

  // optional .mesos.TimeInfo mtime = 4;
  if (has_mtime()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        4, *this->mtime_, false, target);
  }

  // optional uint32 mode = 5;
  if (has_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteUInt32ToArray(5, this->mode(), target);
  }

  // optional string uid = 6;
  if (has_uid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->uid().data(), this->uid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FileInfo.uid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->uid(), target);
  }

  // optional string gid = 7;
  if (has_gid()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8StringNamedField(
      this->gid().data(), this->gid().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE,
      "mesos.FileInfo.gid");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->gid(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:mesos.FileInfo)
  return target;
}

int FileInfo::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:mesos.FileInfo)
  int total_size = 0;

  // required string path = 1;
  if (has_path()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->path());
  }
  if (_has_bits_[1 / 32] & 126u) {
    // optional int32 nlink = 2;
    if (has_nlink()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->nlink());
    }

    // optional uint64 size = 3;
    if (has_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt64Size(
          this->size());
    }

    // optional .mesos.TimeInfo mtime = 4;
    if (has_mtime()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *this->mtime_);
    }

    // optional uint32 mode = 5;
    if (has_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::UInt32Size(
          this->mode());
    }

    // optional string uid = 6;
    if (has_uid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->uid());
    }

    // optional string gid = 7;
    if (has_gid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->gid());
    }

  }
  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileInfo::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:mesos.FileInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const FileInfo* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const FileInfo>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:mesos.FileInfo)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:mesos.FileInfo)
    MergeFrom(*source);
  }
}

void FileInfo::MergeFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:mesos.FileInfo)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_path()) {
      set_has_path();
      path_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.path_);
    }
    if (from.has_nlink()) {
      set_nlink(from.nlink());
    }
    if (from.has_size()) {
      set_size(from.size());
    }
    if (from.has_mtime()) {
      mutable_mtime()->::mesos::TimeInfo::MergeFrom(from.mtime());
    }
    if (from.has_mode()) {
      set_mode(from.mode());
    }
    if (from.has_uid()) {
      set_has_uid();
      uid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.uid_);
    }
    if (from.has_gid()) {
      set_has_gid();
      gid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.gid_);
    }
  }
  if (from._internal_metadata_.have_unknown_fields()) {
    mutable_unknown_fields()->MergeFrom(from.unknown_fields());
  }
}

void FileInfo::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:mesos.FileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileInfo::CopyFrom(const FileInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:mesos.FileInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileInfo::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_mtime()) {
    if (!this->mtime_->IsInitialized()) return false;
  }
  return true;
}

void FileInfo::Swap(FileInfo* other) {
  if (other == this) return;
  InternalSwap(other);
}
void FileInfo::InternalSwap(FileInfo* other) {
  path_.Swap(&other->path_);
  std::swap(nlink_, other->nlink_);
  std::swap(size_, other->size_);
  std::swap(mtime_, other->mtime_);
  std::swap(mode_, other->mode_);
  uid_.Swap(&other->uid_);
  gid_.Swap(&other->gid_);
  std::swap(_has_bits_[0], other->_has_bits_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata FileInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileInfo_descriptor_;
  metadata.reflection = FileInfo_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// FileInfo

// required string path = 1;
bool FileInfo::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
void FileInfo::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
void FileInfo::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
void FileInfo::clear_path() {
  path_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_path();
}
 const ::std::string& FileInfo::path() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.path)
  return path_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileInfo::set_path(const ::std::string& value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FileInfo.path)
}
 void FileInfo::set_path(const char* value) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.path)
}
 void FileInfo::set_path(const char* value, size_t size) {
  set_has_path();
  path_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.path)
}
 ::std::string* FileInfo::mutable_path() {
  set_has_path();
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.path)
  return path_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileInfo::release_path() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.path)
  clear_has_path();
  return path_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileInfo::set_allocated_path(::std::string* path) {
  if (path != NULL) {
    set_has_path();
  } else {
    clear_has_path();
  }
  path_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), path);
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.path)
}

// optional int32 nlink = 2;
bool FileInfo::has_nlink() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
void FileInfo::set_has_nlink() {
  _has_bits_[0] |= 0x00000002u;
}
void FileInfo::clear_has_nlink() {
  _has_bits_[0] &= ~0x00000002u;
}
void FileInfo::clear_nlink() {
  nlink_ = 0;
  clear_has_nlink();
}
 ::google::protobuf::int32 FileInfo::nlink() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.nlink)
  return nlink_;
}
 void FileInfo::set_nlink(::google::protobuf::int32 value) {
  set_has_nlink();
  nlink_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.nlink)
}

// optional uint64 size = 3;
bool FileInfo::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
void FileInfo::set_has_size() {
  _has_bits_[0] |= 0x00000004u;
}
void FileInfo::clear_has_size() {
  _has_bits_[0] &= ~0x00000004u;
}
void FileInfo::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
 ::google::protobuf::uint64 FileInfo::size() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.size)
  return size_;
}
 void FileInfo::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.size)
}

// optional .mesos.TimeInfo mtime = 4;
bool FileInfo::has_mtime() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
void FileInfo::set_has_mtime() {
  _has_bits_[0] |= 0x00000008u;
}
void FileInfo::clear_has_mtime() {
  _has_bits_[0] &= ~0x00000008u;
}
void FileInfo::clear_mtime() {
  if (mtime_ != NULL) mtime_->::mesos::TimeInfo::Clear();
  clear_has_mtime();
}
const ::mesos::TimeInfo& FileInfo::mtime() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.mtime)
  return mtime_ != NULL ? *mtime_ : *default_instance_->mtime_;
}
::mesos::TimeInfo* FileInfo::mutable_mtime() {
  set_has_mtime();
  if (mtime_ == NULL) {
    mtime_ = new ::mesos::TimeInfo;
  }
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.mtime)
  return mtime_;
}
::mesos::TimeInfo* FileInfo::release_mtime() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.mtime)
  clear_has_mtime();
  ::mesos::TimeInfo* temp = mtime_;
  mtime_ = NULL;
  return temp;
}
void FileInfo::set_allocated_mtime(::mesos::TimeInfo* mtime) {
  delete mtime_;
  mtime_ = mtime;
  if (mtime) {
    set_has_mtime();
  } else {
    clear_has_mtime();
  }
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.mtime)
}

// optional uint32 mode = 5;
bool FileInfo::has_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
void FileInfo::set_has_mode() {
  _has_bits_[0] |= 0x00000010u;
}
void FileInfo::clear_has_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
void FileInfo::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
 ::google::protobuf::uint32 FileInfo::mode() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.mode)
  return mode_;
}
 void FileInfo::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
  // @@protoc_insertion_point(field_set:mesos.FileInfo.mode)
}

// optional string uid = 6;
bool FileInfo::has_uid() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
void FileInfo::set_has_uid() {
  _has_bits_[0] |= 0x00000020u;
}
void FileInfo::clear_has_uid() {
  _has_bits_[0] &= ~0x00000020u;
}
void FileInfo::clear_uid() {
  uid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_uid();
}
 const ::std::string& FileInfo::uid() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.uid)
  return uid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileInfo::set_uid(const ::std::string& value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FileInfo.uid)
}
 void FileInfo::set_uid(const char* value) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.uid)
}
 void FileInfo::set_uid(const char* value, size_t size) {
  set_has_uid();
  uid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.uid)
}
 ::std::string* FileInfo::mutable_uid() {
  set_has_uid();
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.uid)
  return uid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileInfo::release_uid() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.uid)
  clear_has_uid();
  return uid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileInfo::set_allocated_uid(::std::string* uid) {
  if (uid != NULL) {
    set_has_uid();
  } else {
    clear_has_uid();
  }
  uid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), uid);
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.uid)
}

// optional string gid = 7;
bool FileInfo::has_gid() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
void FileInfo::set_has_gid() {
  _has_bits_[0] |= 0x00000040u;
}
void FileInfo::clear_has_gid() {
  _has_bits_[0] &= ~0x00000040u;
}
void FileInfo::clear_gid() {
  gid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_gid();
}
 const ::std::string& FileInfo::gid() const {
  // @@protoc_insertion_point(field_get:mesos.FileInfo.gid)
  return gid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileInfo::set_gid(const ::std::string& value) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:mesos.FileInfo.gid)
}
 void FileInfo::set_gid(const char* value) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:mesos.FileInfo.gid)
}
 void FileInfo::set_gid(const char* value, size_t size) {
  set_has_gid();
  gid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:mesos.FileInfo.gid)
}
 ::std::string* FileInfo::mutable_gid() {
  set_has_gid();
  // @@protoc_insertion_point(field_mutable:mesos.FileInfo.gid)
  return gid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* FileInfo::release_gid() {
  // @@protoc_insertion_point(field_release:mesos.FileInfo.gid)
  clear_has_gid();
  return gid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void FileInfo::set_allocated_gid(::std::string* gid) {
  if (gid != NULL) {
    set_has_gid();
  } else {
    clear_has_gid();
  }
  gid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), gid);
  // @@protoc_insertion_point(field_set_allocated:mesos.FileInfo.gid)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace mesos

// @@protoc_insertion_point(global_scope)
